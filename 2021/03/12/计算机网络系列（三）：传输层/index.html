<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"24suixinsuoyu.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1. TCP 三次握手和四次挥手机制 ★★★★★">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络系列（三）：传输层">
<meta property="og:url" content="http://24suixinsuoyu.com/2021/03/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82/index.html">
<meta property="og:site_name" content="隋钟元’s Blog">
<meta property="og:description" content="1. TCP 三次握手和四次挥手机制 ★★★★★">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1gokj7w0h9yj20bv09caal.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1gokk2bw4s7j20ob0oumxs.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1goky1az4xdj215t0jtgma.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1goky71gxjuj216y0jodgo.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1gom2dpdiowj21ce0tj755.jpg">
<meta property="article:published_time" content="2021-03-11T16:01:20.000Z">
<meta property="article:modified_time" content="2021-03-17T07:02:40.893Z">
<meta property="article:author" content="隋钟元">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="传输层">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1gokj7w0h9yj20bv09caal.jpg">

<link rel="canonical" href="http://24suixinsuoyu.com/2021/03/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>计算机网络系列（三）：传输层 | 隋钟元’s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">隋钟元’s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-university"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th-list"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-english">

    <a href="/english/" rel="section"><i class="fa fa-fw fa-graduation-cap"></i>英语</a>

  </li>
        <li class="menu-item menu-item-life">

    <a href="/life/" rel="section"><i class="fa fa-fw fa-balance-scale"></i>生活</a>

  </li>
        <li class="menu-item menu-item-resume">

    <a href="/resume/" rel="section"><i class="fa fa-fw fa-user-circle-o"></i>简历</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/commonweal/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/24suixinsuoyu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://24suixinsuoyu.com/2021/03/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="隋钟元">
      <meta itemprop="description" content="技术创造价值">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="隋钟元’s Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络系列（三）：传输层
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-12 00:01:20" itemprop="dateCreated datePublished" datetime="2021-03-12T00:01:20+08:00">2021-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-17 15:02:40" itemprop="dateModified" datetime="2021-03-17T15:02:40+08:00">2021-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%E3%80%8B/" itemprop="url" rel="index"><span itemprop="name">《计算机网络系列》</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="1-TCP-三次握手和四次挥手机制-★★★★★"><a href="#1-TCP-三次握手和四次挥手机制-★★★★★" class="headerlink" title="1. TCP 三次握手和四次挥手机制 ★★★★★"></a>1. TCP 三次握手和四次挥手机制 ★★★★★</h4><a id="more"></a>

<ol>
<li><p><strong>三次握手机制</strong></p>
<ul>
<li><p><strong>三次握手机制示意图</strong></p>
<p>  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gokj7w0h9yj20bv09caal.jpg" alt="三次握手机制"></p>
</li>
<li><p><strong>三次握手是 TCP 连接的建立过程</strong>。在握手之前，主动打开连接的客户端结束 <strong>CLOSE</strong> 阶段，被动打开的服务器也结束 <strong>CLOSE</strong> 阶段，并进入 <strong>LISTEN</strong> 阶段。随后进入三次握手阶段：</p>
<ol>
<li><p><strong>首先客户端向服务器发送一个 SYN 包，并等待服务器确认</strong>，其中：</p>
<ul>
<li><strong>标志位为 SYN</strong>，表示请求建立连接</li>
<li><strong>序号为 Seq = x（x 一般为 1）</strong></li>
<li>随后客户端进入 <strong>SYN-SENT</strong> 阶段</li>
</ul>
</li>
<li><p><strong>服务器接收到客户端发来的 SYN 包后，对该包进行确认后结束 LISTEN 阶段，并返回一段 TCP 报文</strong>，其中：</p>
<ul>
<li><strong>标志位为 SYN 和 ACK</strong>，表示确认客户端的报文 Seq 序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接</li>
<li><strong>序号为 Seq = y</strong></li>
<li><strong>确认号为 Ack = x + 1</strong>，表示收到客户端的序号 Seq 并将其值加 1 作为自己确认号 Ack 的值，随后服务器但进入 <strong>SYN-RECV</strong> 阶段</li>
</ul>
</li>
<li><p><strong>客户端收到发送的 SYN + ACK 包后，明确了从客户端到服务器的数据传输是正常的，从而结束 SYN-SENT 阶段。并返回最后一段报文</strong>。其中：</p>
<ul>
<li><p><strong>标志位为 ACK</strong>，表示确认收到服务器端同意连接的信号</p>
</li>
<li><p><strong>序号为 Seq = x + 1</strong>，表示收到服务端的确认号 Ack，并将其值作为自己的序号值</p>
</li>
<li><p><strong>确认号 Ack = y + 1</strong>，表示收到服务端序号 Seq，并将其值加 1 作为自己的确认号 Ack 的值</p>
</li>
<li><p>随后客户端进入 <strong>ESTABLISHED</strong></p>
<blockquote>
<p>当服务器端收到来自客户端确认收到服务器数据的报文后，得知从服务器到客户端的数据传输是正常的，从而结束 <strong>SYN-RECV</strong> 阶段，进入 <strong>ESTABLISHED</strong> 阶段，从而完成三次握手</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>四次挥手机制</strong></p>
<ul>
<li><p><strong>四次挥手机制示意图</strong></p>
<p>  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gokk2bw4s7j20ob0oumxs.jpg" alt="四次挥手机制"></p>
</li>
<li><p><strong>四次挥手即 TCP 连接的释放，这里假设客户端主动释放连接</strong>。在挥手之前主动释放连接的客户端结束 <strong>ESTABLISHED</strong> 阶段，随后开始四次挥手：</p>
<ol>
<li><p><strong>首先客户端向服务器发送一段 TCP 报文表明其想要释放 TCP 连接</strong>，其中：</p>
<ul>
<li><strong>标志位为 FIN</strong>，表示请求释放连接</li>
<li><strong>序号为 Seq = u</strong></li>
<li>随后客户端进入 <strong>FIN-WAIT-1</strong> 阶段，即<strong>半关闭</strong>阶段，并且停止向服务端发送通信数据</li>
</ul>
</li>
<li><p><strong>服务器接收到客户端请求断开连接的 FIN 报文后，结束 ESTABLISHED 阶段，进入 CLOSE-WAIT 阶段并返回一段 TCP 报文</strong>，其中：</p>
<ul>
<li><strong>标志位为 ACK</strong>，表示接收到客户端释放连接的请求</li>
<li><strong>序号为 Seq = v</strong></li>
<li><strong>确认号为 Ack = u + 1</strong>，表示是在收到客户端报文的基础上，将其序号值加 1 作为本段报文确认号 Ack 的值</li>
<li>随后服务器开始<strong>准备释放</strong>服务端到客户端方向上的连接</li>
</ul>
<blockquote>
<p>客户端收到服务器发送过来的 TCP 报文后，确认服务器已经收到了客户端连接释放的请求，随后客户端<strong>结束 FIN-WAIT-1</strong> 阶段，<strong>进入 FIN-WAIT-2</strong> 阶段</p>
</blockquote>
</li>
<li><p><strong>服务器端在发出 ACK 确认报文后，服务器端会将遗留的待传数据传送给客户端，待传输完成后即经过 CLOSE-WAIT 阶段，便做好了释放服务器端到客户端连接的准备，再次向客户端发出一段 TCP 报文</strong>，其中：</p>
<ul>
<li><strong>标志位为 FIN 和 ACK</strong>，表示已经准备好释放连接了</li>
<li><strong>序号为 Seq = w</strong></li>
<li><strong>确认号 Ack = u + 1</strong>，表示是在收到客户端报文的基础上，将其序号 Seq 的值加 1 作为本段报文确认号 Ack 的值</li>
</ul>
<blockquote>
<p>随后服务器端<strong>结束 CLOSE-WAIT</strong> 阶段，<strong>进入 LAST-ACK</strong> 阶段，并且停止向客户端发送数据</p>
</blockquote>
</li>
<li><p><strong>客户端收到从服务器发来的 TCP 报文，确认了服务器已经做好释放连接的准备，于是结束 FIN-WAIT-2 阶段，进入 TIME-WAIT 阶段，并向服务器发送一段报文</strong>，其中：</p>
<ul>
<li><p><strong>标志位为 ACK</strong>，表示接受到服务器准备好释放连接的信号</p>
</li>
<li><p><strong>序号为 Seq = u + 1</strong>，表示是在已收到服务器报文的基础上，将其确认号 Ack 的值作为本段序号的值</p>
</li>
<li><p><strong>确认号为 Ack = w + 1</strong>，表示是在收到了服务器报文的基础上，将其序号 Seq 的值作为本段报文确认号的值</p>
<blockquote>
<p><strong>随后客户端开始在 TIME-WAIT 阶段等待 2MSL</strong>。服务器段收到从客户端发出的 TCP 报文之后<strong>结束 LAST-ACK</strong> 阶段，<strong>进入 CLOSED</strong> 阶段。由此正式确认关闭服务器端到客户端方向上的连接。客户端等待完 2MSL 之后，<strong>结束 TIME-WAIT</strong> 阶段，<strong>进入 CLOSED</strong> 阶段，由此完成四次挥手</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="2-如果三次握手的时候每次握手信息对方没有收到会怎么样-★★★★"><a href="#2-如果三次握手的时候每次握手信息对方没有收到会怎么样-★★★★" class="headerlink" title="2. 如果三次握手的时候每次握手信息对方没有收到会怎么样 ★★★★"></a>2. 如果三次握手的时候每次握手信息对方没有收到会怎么样 ★★★★</h4><ol>
<li>若第一次握手服务器未接收到客户端请求建立连接的数据包时，服务器不会进行任何响应的动作，而客户端由于在一段时间内没有收到服务器发来的确认报文，因此会等待一段时间后<strong>重新发送 SYN 同步报文</strong>，若仍然没有回应，则重复上述过程直到发送次数超过<strong>最大重传次数</strong>限制后，建立连接的系统调用会返回 -1</li>
<li>若第二次握手客户端未接收到服务器回应的 ACK 报文时，客户端会采取第一次握手失败时的动作，这里不再重复，而服务器此时将阻塞在 <strong>accept()</strong> 系统调用处等待 client 再次发送 ACK 报文</li>
<li>若第三次握手服务器未接收到客户端发送过来的 ACK 报文，同样会采取类似于客户端的<strong>超时重传机制</strong>，若重传次数超过限制后仍然没有回应，则 accept() 系统调用返回 -1，服务器端连接建立失败。<strong>但此时客户端认为自己已经连接成功了，因此开始向服务器端发送数据，但是服务器端的 accept() 系统调用已经返回，此时没有在监听状态</strong>。因此服务器端接收到来自客户端发送来的数据时会发送 <strong>RST</strong> 报文给客户端，<strong>消除客户端单方面建立连接的状态</strong></li>
</ol>
<h4 id="3-为什么要进行三次握手，两次握手是否可行-★★★★★"><a href="#3-为什么要进行三次握手，两次握手是否可行-★★★★★" class="headerlink" title="3. 为什么要进行三次握手，两次握手是否可行 ★★★★★"></a>3. 为什么要进行三次握手，两次握手是否可行 ★★★★★</h4><ul>
<li>三次握手的主要目的是<strong>确认自己和对方的发送和接收都是正常的</strong>，从而保证了双方能够进行<strong>可靠通信</strong>。若采用两次握手，当第二次握手后将建立连接的话，此<strong>时客户端知道服务器能够正常接收到自己发送的数据，而服务器并不知道客户端是否能够收到自己发送的数据</strong></li>
<li>我们知道<strong>网络往往是非理想状态的（存在丢包和延迟）</strong>，当客户端发起创建连接的请求时，如果服务器直接创建了这个连接并返回包含 SYN、ACK 和 Seq 等内容的数据包给客户端，这个数据包<strong>因为网络传输的原因丢失</strong>了，丢失之后客户端就一直收不到返回的数据包</li>
<li>由于<strong>客户端可能设置了一个超时时间</strong>，一段时间后就关闭了连接建立的请求，<strong>再重新发起新的请求</strong>，而服务器端是不知道的，如果没有第三次握手告知服务器客户端能否收到服务器传输的数据的话，<strong>服务器端的端口就会一直开着</strong>，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。<strong>长此以往，这样的端口越来越多，就会造成服务器开销的浪费</strong></li>
</ul>
<h4 id="4-第-2-次握手传回了-ACK，为什么还要传回-SYN-★★★★"><a href="#4-第-2-次握手传回了-ACK，为什么还要传回-SYN-★★★★" class="headerlink" title="4. 第 2 次握手传回了 ACK，为什么还要传回 SYN ★★★★"></a>4. 第 2 次握手传回了 ACK，为什么还要传回 SYN ★★★★</h4><ul>
<li>传回 <strong>ACK</strong> 是为了告诉客户端，发来的数据<strong>已经接收无误</strong></li>
<li>传回 <strong>SYN</strong> 是为了告诉客户端，服务端收到的消息<strong>确实是客户端发送的消息</strong></li>
</ul>
<h4 id="5-为什么要四次挥手-★★★★"><a href="#5-为什么要四次挥手-★★★★" class="headerlink" title="5. 为什么要四次挥手 ★★★★"></a>5. 为什么要四次挥手 ★★★★</h4><ul>
<li>释放 TCP 连接时之所以需要四次挥手，<strong>是因为 FIN 释放连接报文和 ACK 确认接收报文是分别在两次握手中传输的</strong></li>
<li>当主动方客户端在数据传送结束后发出连接释放的通知，<strong>由于被动方服务器端可能还有必要的数据要处理，所以会先返回 ACK 确认收到报文</strong>。当被动方服务器端也没有数据再发送的时候，再发出连接释放通知，对方确认后才完全关闭 TCP 连接</li>
</ul>
<h4 id="6-CLOSE-WAIT-和-TIME-WAIT-的状态和意义-★★★★★"><a href="#6-CLOSE-WAIT-和-TIME-WAIT-的状态和意义-★★★★★" class="headerlink" title="6. CLOSE-WAIT 和 TIME-WAIT 的状态和意义 ★★★★★"></a>6. CLOSE-WAIT 和 TIME-WAIT 的状态和意义 ★★★★★</h4><ul>
<li>在服务器收到客户端关闭连接的请求并告诉客户端自己已经成功收到了该请求之后，服务器进入了 <strong>CLOSE-WAIT</strong> 状态，然而此时有可能服务器端还有一些数据没有传输完成，因此不能立即关闭连接，<strong>所以 CLOSE-WAIT 状态就是为了保证服务器在关闭连接之前将待发送的数据发送完成</strong></li>
<li><strong>TIME-WAIT</strong> 发生在第四次挥手，当客户端向服务器端发送 ACK 确认报文后进入该状态，若取消该状态，即客户端在收到服务端的 FIN 报文后立即关闭连接，<strong>此时服务端相应的端口并没有关闭，若客户端在相同的端口立即建立新的连接，则有可能接收到上一次连接中残留的数据包，可能会导致不可预料的异常出现</strong></li>
<li>除此之外，假设客户端最后一次发送的 ACK 包传输的时候丢失了，由于 TCP 协议的<strong>超时重传机制</strong>，服务端将重发 FIN 报文，若客户端并没有维持 TIME-WAIT 状态而直接关闭的话，<strong>当收到服务端重新发送的 FIN 包时，客户端就会用 RST 包来响应服务端，这将会使得服务端认为是有错误发生</strong>，然而其实只是正常的关闭连接过程，并没有出现异常情况</li>
</ul>
<h4 id="7-TIME-WAIT-状态会导致什么问题，怎么解决-★★★"><a href="#7-TIME-WAIT-状态会导致什么问题，怎么解决-★★★" class="headerlink" title="7. TIME-WAIT 状态会导致什么问题，怎么解决 ★★★"></a>7. TIME-WAIT 状态会导致什么问题，怎么解决 ★★★</h4><ul>
<li>我们考虑<strong>高并发短连接</strong>的业务场景，在高并发短连接的 TCP 服务器上，<strong>当服务器处理完请求后主动请求关闭连接</strong>，这样服务器上会有大量的连接处于 TIME-WAIT 状态，<strong>服务器维护每一个连接需要一个 socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用时有上限的，如果持续高并发，会导致一些正常的连接失败</strong></li>
<li>解决方案：<strong>修改配置或设置 SO-REUSEADDR 套接字，使得服务器处于 TIIME-WAIT 状态下的端口能够快速回收和重用</strong></li>
</ul>
<h4 id="8-TIME-WAIT-为什么是-2MSL-★★★★"><a href="#8-TIME-WAIT-为什么是-2MSL-★★★★" class="headerlink" title="8. TIME-WAIT 为什么是 2MSL ★★★★"></a>8. TIME-WAIT 为什么是 2MSL ★★★★</h4><ul>
<li>当客户端发出最后的 ACK 确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完 ACK 确认报文之后，会设置一个时长为 <strong>2MSL</strong> 的计时器。<strong>MSL(Maximum Segment Lifetime)，指一段 TCP 报文在传输过程中的最大生命周期</strong>。<strong>2MSL 即是服务器端发出 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长</strong></li>
<li>若服务器在 1MSL 内没有收到客户端发出的 ACK 确认报文，再次向客户端发出 FIN 报文。如果客户端在 2MSL 内收到了服务器再次发来的 FIN 报文，说明服务器由于一些原因并没有收到客户端发出的 ACK 确认报文。客户端将再次向服务器端发出 ACK 确认报文，并<strong>重新开始 2MSL 的计时</strong></li>
<li>若客户端在 2MSL 内没有再次收到服务器发送的 FIN 报文，则说明服务器正常接收到客户端 ACK 确认报文，客户端可以进入 <strong>CLOSE</strong> 阶段，即完成四次挥手</li>
<li>所以<strong>客户端要经历 2MSL 时长的 TIME-WAIT 阶段，为的是确认服务器能否接收到客户端发出的 ACK 确认报文</strong></li>
</ul>
<h4 id="9-有很多-TIME-WAIT-状态如何解决-★★★"><a href="#9-有很多-TIME-WAIT-状态如何解决-★★★" class="headerlink" title="9. 有很多 TIME-WAIT 状态如何解决 ★★★"></a>9. 有很多 TIME-WAIT 状态如何解决 ★★★</h4><ul>
<li>服务器可以设置 <strong>SO-REUSEADDR 套接字</strong>选项来通知内核，如果端口被占用，但 TCP 连接位于 TIME-WAIT 状态时可以<strong>重用端口</strong>。如果服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时 SO-REUSEADDR 选项就可以避免 TIME-WAIT 状态</li>
<li>也可以采用<strong>长连接</strong>的方式减少 TCP 的连接与断开，在长连接的业务中往往不需要考虑 TIME-WAIT 状态，但其实在长连接的业务中并发量一般不会太高</li>
</ul>
<h4 id="10-有很多-CLOSE-WAIT-怎么解决-★★★"><a href="#10-有很多-CLOSE-WAIT-怎么解决-★★★" class="headerlink" title="10. 有很多 CLOSE-WAIT 怎么解决 ★★★"></a>10. 有很多 CLOSE-WAIT 怎么解决 ★★★</h4><ul>
<li>首先<strong>检查是不是自己的代码问题</strong>（看是否服务端程序忘记关闭连接），如果是，则修改代码</li>
<li><strong>调整系统参数</strong>，包括句柄相关参数和 TCP/IP 的参数，<strong>一般一个 CLOSE-WAIT 会维持至少 2 个小时的时间</strong>，我们可以通过调整参数来缩短这个时间</li>
</ul>
<h4 id="11-TCP-和-UDP-的区别-★★★★★"><a href="#11-TCP-和-UDP-的区别-★★★★★" class="headerlink" title="11. TCP 和 UDP 的区别 ★★★★★"></a>11. TCP 和 UDP 的区别 ★★★★★</h4><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">是否面向连接</th>
<th align="center">传输可靠性</th>
<th align="center">传输形式</th>
<th align="center">传输效率</th>
<th align="center">所需资源</th>
<th align="center">应用场景</th>
<th align="center">首部字节</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TCP</td>
<td align="center">是</td>
<td align="center">可靠</td>
<td align="center">字节流</td>
<td align="center">慢</td>
<td align="center">多</td>
<td align="center">文件传输、邮件传输</td>
<td align="center">20 ~ 60</td>
</tr>
<tr>
<td align="center">UDP</td>
<td align="center">否</td>
<td align="center">不可靠</td>
<td align="center">数据报文段</td>
<td align="center">快</td>
<td align="center">少</td>
<td align="center">即时通讯、域名转换</td>
<td align="center">8 个字节</td>
</tr>
</tbody></table>
<h4 id="12-TCP-协议中的定时器-★★"><a href="#12-TCP-协议中的定时器-★★" class="headerlink" title="12. TCP 协议中的定时器 ★★"></a>12. TCP 协议中的定时器 ★★</h4><ul>
<li><p><strong>建立连接定时器</strong>：顾名思义，该定时器是建立 TCP 连接的时候使用的，在 TCP 三次握手的过程中，发送方发送 SYN 时，会启动一个定时器（<strong>默认为 3 秒</strong>），若 SYN 包丢失了，那么 3 秒以后会重新发送 SYN 包，直到达到<strong>重传次数</strong></p>
</li>
<li><p><strong>重传定时器</strong>：该计时器主要用于 TCP <strong>超时重传机制</strong>中，当 TCP 发送报文段时，就会创建特定报文的重传计时器，并可能出现两种情况：</p>
<ol>
<li>若在计时器截止之前发送方收到了接收方的 ACK 报文，则<strong>撤销</strong>该计时器</li>
<li>若在计时器截止时间内并没有收到接收方的 ACK 报文，则发送方重传报文，并将计时器<strong>复位</strong></li>
</ol>
</li>
<li><p><strong>坚持计时器</strong>：我们知道 <strong>TCP 通过让接收方指明希望从发送方接收的数据字节数（窗口大小）来进行流量控制</strong>，当接收端的接收窗口满时，接收端会告诉发送端此时窗口已满，请停止发送数据。此时发送端和接收端的窗口大小均为 0，直到窗口变为非 0 时，接收端将发送一个确认 ACK 告诉发送端可以再次发送数据，但是该报文有可能在传输时丢失。<strong>若该 ACK 报文丢失</strong>，则双方可能会一直等待下去，为了避免这种<strong>死锁</strong>情况的发生，<strong>发送方使用一个坚持计时器来周期性地向接收方发送探测报文段，以查看接收方窗口是否变大</strong></p>
</li>
<li><p><strong>延迟应答计时器</strong>：延迟应答也被称为<strong>捎带 ACK</strong>，这个定时器是在延迟应答的时候使用的，为了提高网络传输的效率，当服务器接收到客户端的数据后，<strong>不是立即回 ACK 给客户端，而是等一段时间</strong>，这样如果服务端有数据需要发送给客户端的话，就可以把数据和 ACK 一起发送给客户端了</p>
</li>
<li><p><strong>保活定时器</strong>：该定时器是在建立 TCP 连接时指定 <strong>SO_KEEPLIVE</strong> 时才会生效，当发送方和接收方长时间没有进行数据交互时，该定时器可以<strong>用于确定对端是否还活着</strong></p>
</li>
<li><p><strong><code>FIN_WAIT_2</code> 定时器</strong>：当主动请求关闭的一方发送 FIN 报文给接收端并且收到其对 FIN 的确认 ACK 后进入 <strong>FIN-WAIT-2</strong> 状态。如果这个时候因为<strong>网络突然断掉、被动关闭的一端宕机</strong>等原因，导致请求方没有收到接收方发来的 FIN，主动关闭的一方会一直等待。该定时器的作用就是为了避免这种情况的发生。<strong>当该定时器超时的时候，请求关闭方将不再等待，直接释放连接</strong></p>
</li>
<li><p><strong><code>TIME_WAIT</code> 定时器</strong>：在 TCP 四次挥手中，发送方在最后一次挥手之后进入 <strong>TIME-WAIT</strong> 状态，不直接进入 CLOSE 状态的主要原因是被动关闭方万一在超时时间内没有收到最后一个 ACK，则会重发最后的 FIN，<strong>2MSL 等待时间</strong>保证了重发的 FIN 会被主动关闭的一端收到且重新发送最后一个 ACK。还有一个原因是，<strong>在这 2MSL 的时间段内任何迟到的报文段会被接收方丢弃，从而防止老的 TCP 连接的包在新的 TCP 连接里面出现</strong></p>
</li>
</ul>
<h4 id="13-TCP-是如何保证可靠性的-★★★★"><a href="#13-TCP-是如何保证可靠性的-★★★★" class="headerlink" title="13. TCP 是如何保证可靠性的 ★★★★"></a>13. TCP 是如何保证可靠性的 ★★★★</h4><ul>
<li><strong>数据分块</strong>：应用数据被分割成 TCP 认为<strong>最适合发送</strong>的数据块</li>
<li><strong>序列号和确认应答</strong>：TCP 给发送的每一个包进行<strong>编号</strong>，在传输的过程中，每次接收方收到数据后，都会对传输方进行<strong>确认应答</strong>，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行<strong>排序</strong>，把有序数据传送给应用层，并<strong>丢弃重复</strong>的数据</li>
<li><strong>校验和</strong>：TCP 将保持它首部和数据部分的检验和。这是一个端到端的检验和，<strong>目的是检测数据在传输过程中的任何变化</strong>。如果收到报文段的检验和有差错，TCP 将<strong>丢弃</strong>这个报文段并且不确认收到此报文段</li>
<li><strong>流量控制</strong>：TCP 连接的双方都有一个<strong>固定大小的缓冲空间</strong>，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，<strong>防止产生丢包</strong>。TCP 通过<strong>滑动窗口协议</strong>来支持流量控制机制</li>
<li><strong>拥塞控制</strong>：当网络某个节点发送<strong>拥塞</strong>时，<strong>减少</strong>数据的发送</li>
<li><strong>ARQ 协议</strong>：也是为了实现可靠传输的，它的基本原理就是<strong>每发完一个分组就停止发送，等待对方确认</strong>。在收到确认后再发下一个分组</li>
<li><strong>超时重传</strong>：当 TCP 发出一个报文段后，它启动一个<strong>定时器</strong>，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段</li>
</ul>
<h4 id="14-UDP-为什么是不可靠的，bind-和-connect-对于-UDP-的作用是什么-★★★"><a href="#14-UDP-为什么是不可靠的，bind-和-connect-对于-UDP-的作用是什么-★★★" class="headerlink" title="14. UDP 为什么是不可靠的，bind 和 connect 对于 UDP 的作用是什么 ★★★"></a>14. UDP 为什么是不可靠的，bind 和 connect 对于 UDP 的作用是什么 ★★★</h4><ul>
<li><strong>UDP 只有一个 socket 接收缓冲区，没有 socket 发送缓冲区，即只要有数据就发，不管对方是否可以正确接收</strong>。而在对方的 socket 接收缓冲区满了之后，新来的数据报无法进入到 socket 接收缓冲区，此数据报就会<strong>被丢弃</strong>，因此 UDP 不能保证数据能够到达目的地。此外，<strong>UDP 也没有流量控制和重传机制</strong>，故 UDP 的数据传输是不可靠的</li>
<li>和 TCP 建立连接时采用 三次握手不同，UDP 中调用 <strong>connect</strong> 只是把对端的 IP 和端口号记录下来，并且 UDP 可以多次调用 connect 来指定一个新的 IP 和端口号，或者断开旧的 IP 和端口号（通过设置 connect 函数的第二个参数）。和普通的 UDP 相比，调用 connect 的 UDP 会提升效率，并且在高并发服务中会增加系统稳定性</li>
<li>当 UDP 的发送端调用 <strong>bind</strong> 函数时，就会将这个套接字指定一个端口，若不调用 bind 函数，系统内核会随机分配一个端口给该套接字。当手动绑定时，能够避免内核来执行这一操作，从而在一定程度上提高性能</li>
</ul>
<h4 id="15-TCP-超时重传的原理-★★★"><a href="#15-TCP-超时重传的原理-★★★" class="headerlink" title="15. TCP 超时重传的原理 ★★★"></a>15. TCP 超时重传的原理 ★★★</h4><ul>
<li>发送方在发送一次数据后就开启一个<strong>定时器</strong>，在一定时间内如果没有得到发送数据包的 <strong>ACK 报文</strong>，那么就<strong>重新发送</strong>数据，在达到一定次数还没有成功的话就<strong>放弃重传</strong>并发送一个<strong>复位信号</strong></li>
<li><strong>超时时间的计算是超时的核心</strong>，而定时时间的确定往往需要进行适当的<strong>权衡</strong>，因为当<strong>定时时间过长</strong>会造成网络利用率不高，<strong>定时太短</strong>会造成多次重传，使得网络阻塞。在 TCP 连接过程中，会参考当前的网络状况从而找到一个合适的超时时间</li>
</ul>
<h4 id="16-TCP-的停止等待协议是什么-★★★"><a href="#16-TCP-的停止等待协议是什么-★★★" class="headerlink" title="16. TCP 的停止等待协议是什么 ★★★"></a>16. TCP 的停止等待协议是什么 ★★★</h4><ul>
<li><p><strong>停止等待协议</strong>是为了实现 TCP 可靠传输而提出的一种相对简单的协议，该协议指的是<strong>发送方每发完一组数据后，直到收到接收方的确认信号才继续发送下一组数据</strong></p>
</li>
<li><p>停止等待协议实现<strong>可靠传输</strong>有如下四种情形：</p>
<p>  <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1goky1az4xdj215t0jtgma.jpg" alt="TCP 的停止等待协议"></p>
<p>  <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1goky71gxjuj216y0jodgo.jpg" alt="TCP 的停止等待协议"></p>
<ol>
<li><p><strong>无差错传输</strong>：A 发送分组 Msg 1，<strong>发完就暂停发送</strong>，直到收到接收方确认收到 Msg 1 的报文后，继续发送 Msg 2，以此类推，该情形是通信中的一种<strong>理想状态</strong></p>
</li>
<li><p><strong>出现差错</strong>：发送方发送的报文出现差错导致接收方不能正确接收数据，出现差错的情况主要分为两种：</p>
<ul>
<li><p>发送方发送的 Msg 1 <strong>在中途丢失了</strong>，接收方完全没收到数据</p>
</li>
<li><p>接收方收到 Msg 1 后<strong>检测出现了差错</strong>，直接丢弃 Msg 1</p>
<blockquote>
<p>上面两种情形，接收方都不会回任何消息给发送方，此时就会触发<strong>超时传输机制</strong>，即发送方在等待一段时间后仍然没有收到接收方的确认，就认为刚才发送的数据丢失了，因此重传前面发送过的数据</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>确认丢失</strong>：当接收方回应的 Msg 1 确认报文在传输过程中丢失，发送方无法接收到确认报文。于是发送方等待一段时间后重传 Msg 1，接收方将收到的重复的 Msg 1 数据包，此时接收方会<strong>丢弃掉这个重复报文</strong>并向发送方<strong>再次发送</strong> Msg 1 确认报文</p>
</li>
<li><p><strong>确认迟到</strong>：当接收方回应的 Msg 1 确认报文由于网络各种原因导致发送方没有及时收到，此时发送方在超时重传机制的作用下再次发送了 Msg 数据包，接收方此时进行和确认丢失情形下相同的动作（丢弃重复的数据包并再次发送 Msg 1 确认报文）。发送方此时收到了接收方的确认数据包，于是继续进行数据发送。过了一段时间后，发送方<strong>收到了延迟到的</strong> Msg 1 确认包会<strong>直接丢弃</strong></p>
</li>
</ol>
</li>
</ul>
<h4 id="17-TCP-最大连接数限制-★★"><a href="#17-TCP-最大连接数限制-★★" class="headerlink" title="17. TCP 最大连接数限制 ★★"></a>17. TCP 最大连接数限制 ★★</h4><ul>
<li><p><strong>Client 最大 TCP 连接数</strong></p>
<ul>
<li>client 在每次发起连接请求时，如果自己并不能指定端口的话，系统会随机选择一个<strong>本地端口（local port）</strong>，该端口是<strong>独占</strong>的，不能和其他 TCP 连接共享</li>
<li><strong>TCP 端口的数据类型是 unsigned short</strong>，因此本地端口个数最大只有 <strong>65536</strong>，除了<strong>端口 0</strong> 不能使用外，其他端口在空闲时都可以正常使用，<strong>这样可用端口最多有 65535 个</strong></li>
</ul>
</li>
<li><p><strong>Server 最大 TCP 连接数</strong></p>
<ul>
<li>server 通常固定在某个本地端口上监听，等待 client 的连接请求。<strong>不考虑地址重用</strong>（Unix 的 SO_REUSEADDR 选项）的情况下，即使 server 端有多个 IP，本地监听端口也是独占的，因此 server 端 TCP 连接 4 元组中只有客户端的 IP 地址和端口号是可变的，因此最大 TCP 连接为客户端 IP 数✖️客户端 port 数。<strong>对 IPv4，在不考虑 IP 地址分类的情况下，最大 TCP 连接数约为 2 的 32 次方（IP 数）✖️2 的 16 次方（port 数），也就是 server 端单机最大 TCP 连接数约为 2 的 48 次方</strong></li>
<li>上面给出的只是理论上的单机最大连接数，<strong>在实际环境中，受到明文规定（一些 IP 地址和端口具有特殊含义，没有对外开放）、机器资源、操作系统等的限制</strong>，特别是 server 端，其最大并发 TCP 连接数远不能达到理论上限。对 server 端，<strong>通过增加内存、修改最大文件描述符个数等参数</strong>，单机最大并发 TCP 连接数<strong>超过 10 万</strong>是没问题的</li>
</ul>
</li>
</ul>
<h4 id="18-TCP-流量控制与拥塞控制-★★★★"><a href="#18-TCP-流量控制与拥塞控制-★★★★" class="headerlink" title="18. TCP 流量控制与拥塞控制 ★★★★"></a>18. TCP 流量控制与拥塞控制 ★★★★</h4><ul>
<li><p><strong>流量控制</strong></p>
<ul>
<li><strong>所谓流量控制就是让发送方的发送速率不要太快，让接收方来得及接收</strong>。如果接收方来不及接收发送方发送的数据，那么就会有<strong>分组丢失</strong></li>
<li>在 TCP 中利用<strong>可变长的滑动窗口机制</strong>可以很方便的在 TCP 连接上实现对发送方的流量控制，主要的方式是<strong>接收方返回的 ACK 中会包含自己的接收窗口大小</strong>，以控制发送方此次发送的数据量大小（发送窗口大小）</li>
</ul>
</li>
<li><p><strong>拥塞控制</strong></p>
<ul>
<li>在实际的网络通信系统中，除了发送方和接收方外，还有<strong>路由器</strong>、<strong>交换机</strong>等复杂的网络传输线路，此时就需要拥塞控制</li>
<li><strong>拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况</strong></li>
<li>常用的解决方法有：<strong>慢开始</strong>和<strong>拥塞避免</strong>、<strong>快重传</strong>和<strong>快恢复</strong></li>
</ul>
</li>
<li><p><strong>拥塞控制和流量控制的区别</strong></p>
<ul>
<li><strong>拥塞控制往往是一种全局的，防止过多的数据注入到网络之中</strong>，而 TCP 连接的端点只要不能收到对方的确认信息，猜想在网络中发生了拥塞，但并不知道发生在何处</li>
<li>因此，<strong>流量控制往往指点对点通信量的控制，是端到端的问题</strong></li>
</ul>
</li>
</ul>
<h4 id="19-如果接收方滑动窗口满了，发送方会怎么做-★★★★"><a href="#19-如果接收方滑动窗口满了，发送方会怎么做-★★★★" class="headerlink" title="19. 如果接收方滑动窗口满了，发送方会怎么做 ★★★★"></a>19. 如果接收方滑动窗口满了，发送方会怎么做 ★★★★</h4><ul>
<li>基于 TCP 流量控制中的<strong>滑动窗口协议</strong>，我们知道接收方返回给发送方的 ACK 包中会包含自己的接收窗口大小，<strong>若接收窗口已满，此时接收方返回给发送方的接收窗口大小为 0，此时发送方会等待接收方发送的窗口大小直到变为非 0 为止</strong></li>
<li>然而，接收方回应的 ACK 包是<strong>存在丢失的可能</strong>的，为了防止双方一直等待而出现<strong>死锁</strong>情况，此时就<strong>需要坚持计时器来辅助发送方周期性地向接收方查询，以便发现窗口是否变大</strong>，当发现窗口大小变为非零时，发送方便继续发送数据</li>
</ul>
<h4 id="20-TCP-拥塞控制采用的四种算法-★★★"><a href="#20-TCP-拥塞控制采用的四种算法-★★★" class="headerlink" title="20. TCP 拥塞控制采用的四种算法 ★★★"></a>20. TCP 拥塞控制采用的四种算法 ★★★</h4><ul>
<li><p><strong>慢开始</strong></p>
<ul>
<li>当发送方开始发送数据时，<strong>由于一开始不知道网络负荷情况</strong>，如果立即将大量的数据字节传输到网络中，那么就有可能引起网络拥塞。一个较好的方法是<strong>在一开始发送少量的数据先探测一下网络状况，即有小到大地增大发送窗口（拥塞窗口 cwnd）</strong></li>
<li><strong>慢开始的慢指的是初始时令 cwnd 为 1，即一开始发送一个报文段</strong>。如果收到确认，则 cwnd = 2，之后每收到一个确认报文，就令 <strong>cwnd = cwnd * 2</strong>。但是，为了防止拥塞窗口增长过大而引起网络拥塞，另外设置了一个<strong>慢开始门限 ssthresh</strong><ol>
<li>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法</li>
<li>当 cwnd &gt; ssthresh 时，停止使用慢开始，转而使用拥塞避免算法</li>
<li>当 cwnd == ssthresh 时，两者均可</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>拥塞避免</strong></p>
<ul>
<li>拥塞控制是为了让拥塞窗口 cwnd 缓慢地增大，<strong>即每经过一个往返时间 RTT（往返时间定义为发送方发送数据到收到确认报文所经历的时间）就把发送方的 cwnd 值加 1</strong>，通过<strong>让 cwnd 线性增长</strong>，防止很快就遇到网络拥塞状态</li>
<li>当网络拥塞发生时，<strong>让新的慢开始门限值变为发生拥塞时候的值的一半，并将拥塞窗口置为 1</strong>，然后再次重复两种算法（慢开始和拥塞避免），这时一瞬间会将网络中的数据量大量降低</li>
</ul>
</li>
<li><p><strong>快重传</strong></p>
<ul>
<li><strong>快重传算法要求接收方每收到一个失序的报文就立即发送重复确认，而不要等到自己发送数据时才捎带进行确认</strong></li>
<li>假定发送方发送了 Msg 1 ~ Msg 4 这 4 个报文，已知接收方收到了 Msg 1、Msg 3 和 Msg 4 报文，此时因为接收到了<strong>失序</strong>的数据包，按照快重传的约定，接收方应立即向发送方发送 Msg 1 的<strong>重复确认</strong>。于是在接收方收到 Msg 4 报文的时候，向发送方发送的仍然是 Msg 1 的重复确认。这样，发送方就收到了 3 次 Msg 1 的重复确认，于是<strong>立即重传</strong>对方未收到的 Msg 报文</li>
<li><strong>由于发送方尽早重传未被确认的报文段，因此，快重传算法可以提高网络的吞吐量</strong></li>
</ul>
</li>
<li><p><strong>快恢复</strong></p>
<ul>
<li><strong>快恢复算法是和快重传算法配合使用的</strong>，该算法主要有以下两个要点<ol>
<li>当发送方连续收到三个重复确认，<strong>执行乘法减小，慢开始门限 ssthresh 值减半</strong></li>
<li>由于发送方可能认为网络现在没有拥塞，因此与慢开始不同，<strong>把 cwnd 值设置为 ssthresh 减半之后的值，然后执行拥塞避免算法，线性增大 cwnd</strong></li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="21-TCP-粘包问题-★★★"><a href="#21-TCP-粘包问题-★★★" class="headerlink" title="21. TCP 粘包问题 ★★★"></a>21. TCP 粘包问题 ★★★</h4><ul>
<li><p><strong>发生 TCP 粘包和拆包的原因</strong></p>
<ol>
<li>发送方写入的数据<strong>大于</strong>套接字缓冲区的大小，此时将发生<strong>拆包</strong></li>
<li>发送方写入的数据<strong>小于</strong>套接字缓冲区大小，由于 TCP 默认使用 Nagle 算法，只有当收到一个确认后，才将分组发送给对端，<strong>当发送方收集了多个较小的分组，就会一起发送给对端，这将会发生粘包</strong></li>
<li>进行 <strong>MSS（最大报文长度）</strong>大小的 TCP 分段，<strong>当 TCP 报文的数据大部分大于 MSS 的时候将发生拆包</strong></li>
<li><strong>发送方发送的数据太快</strong>，接收方处理数据的速度赶不上发送端的速度，将发生<strong>粘包</strong></li>
</ol>
</li>
<li><p><strong>常见解决方法</strong></p>
<ol>
<li>在消息的头部<strong>添加消息长度字段</strong>，服务端<strong>获取</strong>消息头的时候<strong>解析</strong>消息长度，然后<strong>向后读取</strong>相应长度的内容</li>
<li><strong>固定消息数据的长度</strong>，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，空位补上固定字符。但是该方法会<strong>浪费网络资源</strong></li>
<li><strong>设置消息边界</strong>，也可以理解为<strong>分隔符</strong>，服务端从数据流中按消息边界分离出消息内容，一般使用<strong>换行符</strong></li>
</ol>
</li>
<li><p><strong>需要处理粘包问题的时机</strong></p>
<ul>
<li>当接收端同时收到多个分组，并且这些<strong>分组之间毫无关系</strong>时，需要处理粘包</li>
<li>而当多个分组<strong>属于同一数据的不同部分</strong>时，并不需要处理粘包问题</li>
</ul>
</li>
</ul>
<h4 id="22-TCP-报文包含哪些信息-★★"><a href="#22-TCP-报文包含哪些信息-★★" class="headerlink" title="22. TCP 报文包含哪些信息 ★★"></a>22. TCP 报文包含哪些信息 ★★</h4><ul>
<li><p><strong>TCP 报文是 TCP 传输的数据单元，也叫报文段</strong>，其<strong>报文格式</strong>如下图所示：</p>
<p>  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gom2dpdiowj21ce0tj755.jpg" alt="TCP 报文格式"></p>
</li>
<li><p><strong>源端口和目的端口号</strong>：它用于<strong>多路复用/分解</strong>来自或送往上层应用的数据，其和 IP 数据报中的源 IP 与目的 IP 地址一同确定一条 TCP 连接</p>
</li>
<li><p><strong>序号和确认号字段</strong>：序号是本报文段发送的数据部分中<strong>第一个字节的编号</strong>，在 TCP 传送的流中，<strong>每一个字节一个序号</strong>。例如一个报文段的序号为 100，此报文段数据部分共有 100 个字节，则下一个报文段的序号为 200。序号确保了 TCP 传输的有序性。确认号，即 ACK，指明下一个想要收到的字节序号，发送 ACK 时表明当前序号之前的所有数据已经正确接收。这两个字段的主要目的是<strong>保证数据可靠传输</strong></p>
</li>
<li><p><strong>首部长度</strong>：该字段指示了以 32 比特的字为单位的 TCP 的首部长度。其中固定字段长度为 20 字节，<strong>由于首部长度可能含有可选项内容，因此 TCP 报头的长度是不确定的，20 字节是 TCP 首部的最小长度</strong></p>
</li>
<li><p><strong>保留</strong>：为将来用于新的用途而保留</p>
</li>
<li><p><strong>控制位</strong>：<strong>URG 表示紧急指针标志</strong>，该位为 1 时表示紧急指针有效，为 0 则忽略；<strong>ACK 为确认序号标志</strong>，即相应报文段包括一个对已被成功接收报文段的确认；<strong>PSH 为 push 标志</strong>，当该位为 1 时，则指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队； <strong>RST 为重置连接标志</strong>，当出现错误连接时，使用此标志来拒绝非法的请求；<strong>SYN 为同步序号</strong>，在连接的建立过程中使用，例如三次握手时，发送方发送 SYN 包表示请求建立连接；<strong>FIN 为 finish 标志</strong>，用于释放连接，为 1 时表示发送方已经没有数据发送了，即关闭本方数据流</p>
</li>
<li><p><strong>接收窗口</strong>：主要用于 TCP 流量控制。该字段用来告诉发送方其<strong>窗口（缓冲区）</strong>大小，以此控制发送速率，从而达到流量控制的目的</p>
</li>
<li><p><strong>校验和</strong>：奇偶校验，此校验和是对整个 TCP 报文段，包括 TCP 头部和数据部分。该校验和是一个端到端的校验和，<strong>由发送端计算和存储，并由接收端进行验证，主要目的是检验数据是否发生改动</strong>，若检测出错，接收方会丢弃该 TCP 报文</p>
</li>
<li><p><strong>紧急数据指针</strong>：紧急数据指针用于<strong>告知紧急数据所在的位置</strong>，在 URG 的标志位为 1 时才有效。当紧急数据存在时，TCP 必须通知接收方的上层实体，接收方会对紧急模式采取相应的处理</p>
</li>
<li><p><strong>选项</strong>：该字段<strong>一般为空</strong>，可根据首部长度进行推算，主要有以下作用</p>
<ol>
<li>TCP 连接初始化时，通信双方<strong>确认最大报文长度</strong></li>
<li>在高速数据传输时，可使用该选项<strong>协商窗口扩大因子</strong></li>
<li>作为<strong>时间戳</strong>时，提供一个较为精准的 <strong>RTT（往返时间定义为发送方发送数据到收到确认报文所经历的时间）</strong>，主要为了更好的实现 TCP 流量控制协议</li>
</ol>
</li>
<li><p><strong>数据</strong>：TCP 报文中的数据部分也<strong>是可选的</strong>，例如在 TCP 三次握手和四次挥手过程中，<strong>通信双方交换的报文只包含头部信息，数据部分为空，只有当连接成功建立后，TCP 包才真正携带数据</strong></p>
</li>
</ul>
<h4 id="23-SYN-FLOOD-是什么-★★★"><a href="#23-SYN-FLOOD-是什么-★★★" class="headerlink" title="23. SYN FLOOD 是什么 ★★★"></a>23. SYN FLOOD 是什么 ★★★</h4><ul>
<li><strong>SYN Flood 是典型的 Dos（拒绝服务）攻击</strong>，其目的是<strong>通过消耗服务器所有可用资源使服务器无法用于处理合法请求</strong></li>
<li>通过重复发送<strong>初始连接请求（SYN）数据包</strong>，攻击者能够压倒目标服务器上的<strong>所有可用端口</strong>，导致目标设备根本<strong>不响应合法请求</strong></li>
</ul>
<h4 id="24-为什么服务端易收到-SYN-攻击-★★★"><a href="#24-为什么服务端易收到-SYN-攻击-★★★" class="headerlink" title="24. 为什么服务端易收到 SYN 攻击 ★★★"></a>24. 为什么服务端易收到 SYN 攻击 ★★★</h4><ul>
<li><p><strong>原因</strong></p>
<ul>
<li>在 TCP 建立连接的过程中，因为服务器不确定自己发给客户端的 SYN-ACK 消息或客户端反馈的 ACK 消息<strong>是否会丢在半路</strong>，所以会给每个待完成的半开连接状态设一个<strong>定时器</strong>，如果超过时间还没有收到客户端的 ACK 消息，则<strong>重新发送</strong>一个 SYN-ACK 消息给客户端，直到重试超过一定次数时才会放弃</li>
<li><strong>服务端为了维持半开连接状态，需要分配内核资源维护半开连接</strong>。当攻击者伪造海量的虚假 IP 向服务端发送 SYN 包时，就形成了 SYN FLOOD 攻击。<strong>攻击者故意不响应 ACK 消息</strong>，导致服务端被大量注定不能完成的半开连接占据，直到资源耗尽，停止响应正常的连接请求</li>
</ul>
</li>
<li><p><strong>解决方法</strong></p>
<ul>
<li><p>直接的方法是<strong>提高 TCP 端口容量</strong>的同时<strong>减少半开连接的资源占用时间</strong>，然而该方法只是稍稍提高了<strong>防御</strong>能力</p>
</li>
<li><p><strong>部署能够辨别恶意 IP 的路由器</strong>，将伪造 IP 地址的发送方发送的 SYN 消息过滤掉，该方案作用一般不是太大</p>
<blockquote>
<p>上述两种方法虽然在一定程度上能够提高服务器的<strong>防御</strong>能力，但是没有从根本上解决服务器资源消耗殆尽的问题，而以下几种方法的出发点都是在发送方发送确认回复后才开始分配传输资源，从而避免服务器资源消耗殆尽</p>
</blockquote>
</li>
<li><p><strong>SYN Cache</strong>：该方法<strong>首先构造一个全局 Hash Table，用来缓存系统当前所有的半开连接信息</strong>。在 Hash Table 中的每个桶的容量大小是有限制的，当桶满时，会主动丢掉早来的信息。当服务端收到一个 SYN 消息后，会通过一个映射函数生成一个相应的 Key 值，使得当前半连接信息存入相应的桶中。当收到客户端正确的确认报文后，服务端才开始分配传输资源块，并将相应的半开连接信息从表中删除。<strong>和服务器传输资源相比，维护表的开销要小得多</strong></p>
</li>
<li><p><strong>SYN Cookies</strong>：该方案原理和 HTTP Cookies 技术类似，<strong>服务端通过特定的算法将半开连接信息编码成序列号或者时间戳，用作服务端给客户端的消息编号</strong>，随 SYN-ACK 消息一同返回给连接发起方，这样在连接建立完成前服务端不保存任何信息，直到发送方发送 ACK 确认报文并且服务端成功验证编码信息后，服务端才开始分配传输资源。<strong>若请求方是攻击者，则不会向服务端发送 ACK 消息，由于未成功建立连接，因此服务端并没有花费任何额外的开销</strong></p>
<blockquote>
<p>然而该方案也存在一些缺点，<strong>由于服务端并不保存半开连接状态，因此也就丧失了超时重传的能力，这在一定程度上降低了正常用户的连接成功率</strong>。此外，客户端发送给服务端的确认报文<strong>存在传输丢失的可能</strong>，当 ACK 确认报文丢失时，服务端和客户端会对连接的成功与否产生歧义，此时就需要上层应用采取相应的策略进行处理了</p>
</blockquote>
</li>
<li><p><strong>SYN Proxy</strong>：在客户端和服务器之间部署一个<strong>代理服务器</strong>，类似于<strong>防火墙</strong>的作用。通过代理服务器与客户端进行建立连接的过程，之后代理服务器充当客户端将成功建立连接的客户端信息发送给服务器。<strong>这种方法基于不消化服务器的资源，但是建立连接的时间变长了（总共需要 6 次握手）</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="25-高并发服务器客户端主动关闭连接和服务端主动关闭连接的区别（针对-TCP-服务）-★"><a href="#25-高并发服务器客户端主动关闭连接和服务端主动关闭连接的区别（针对-TCP-服务）-★" class="headerlink" title="25. 高并发服务器客户端主动关闭连接和服务端主动关闭连接的区别（针对 TCP 服务） ★"></a>25. 高并发服务器客户端主动关闭连接和服务端主动关闭连接的区别（针对 TCP 服务） ★</h4><ul>
<li><p><strong>服务端主动关闭连接</strong></p>
<ul>
<li>在高并发场景下，当服务端主动关闭连接时，此时服务器上就会有大量的连接处于 <strong>TIME-WAIT</strong> 状态（详见问题 7、8、9）</li>
</ul>
</li>
<li><p><strong>客户端主动关闭连接</strong></p>
<ul>
<li>当客户端主动关闭连接时，我们并不需要关心 TIME-WAIT 状态过多造成的问题，但是需要关注服务端保持大量的 <strong>CLOSE-WAIT</strong> 状态时会产生的问题（见问题 10 的解决方法）</li>
<li>无论是客户端还是服务器主动关闭连接，<strong>从本质上来说，在高并发场景下主要关心的就是服务端的资源占用问题</strong>，而这也是采用 TCP 传输协议必须要面对的问题，其问题解决的出发点也是如何处理好<strong>服务质量</strong>和<strong>资源消耗</strong>之间的关系</li>
</ul>
</li>
</ul>

    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;margin-top:80px">-------------------- 本文结束<i class="fa fa-paw"></i>感谢您的阅读 --------------------</div>
    
</div>
      
    </div>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>隋钟元
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://24suixinsuoyu.com/2021/03/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82/" title="计算机网络系列（三）：传输层">http://24suixinsuoyu.com/2021/03/12/计算机网络系列（三）：传输层/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"><i class="fa fa-tag"></i> 计算机网络</a>
              <a href="/tags/%E4%BC%A0%E8%BE%93%E5%B1%82/" rel="tag"><i class="fa fa-tag"></i> 传输层</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/" rel="prev" title="计算机网络系列（二）：应用层">
      <i class="fa fa-chevron-left"></i> 计算机网络系列（二）：应用层
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/" rel="next" title="计算机网络系列（四）：网络层">
      计算机网络系列（四）：网络层 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-TCP-三次握手和四次挥手机制-★★★★★"><span class="nav-text">1. TCP 三次握手和四次挥手机制 ★★★★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-如果三次握手的时候每次握手信息对方没有收到会怎么样-★★★★"><span class="nav-text">2. 如果三次握手的时候每次握手信息对方没有收到会怎么样 ★★★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-为什么要进行三次握手，两次握手是否可行-★★★★★"><span class="nav-text">3. 为什么要进行三次握手，两次握手是否可行 ★★★★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-第-2-次握手传回了-ACK，为什么还要传回-SYN-★★★★"><span class="nav-text">4. 第 2 次握手传回了 ACK，为什么还要传回 SYN ★★★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-为什么要四次挥手-★★★★"><span class="nav-text">5. 为什么要四次挥手 ★★★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-CLOSE-WAIT-和-TIME-WAIT-的状态和意义-★★★★★"><span class="nav-text">6. CLOSE-WAIT 和 TIME-WAIT 的状态和意义 ★★★★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-TIME-WAIT-状态会导致什么问题，怎么解决-★★★"><span class="nav-text">7. TIME-WAIT 状态会导致什么问题，怎么解决 ★★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-TIME-WAIT-为什么是-2MSL-★★★★"><span class="nav-text">8. TIME-WAIT 为什么是 2MSL ★★★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-有很多-TIME-WAIT-状态如何解决-★★★"><span class="nav-text">9. 有很多 TIME-WAIT 状态如何解决 ★★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-有很多-CLOSE-WAIT-怎么解决-★★★"><span class="nav-text">10. 有很多 CLOSE-WAIT 怎么解决 ★★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-TCP-和-UDP-的区别-★★★★★"><span class="nav-text">11. TCP 和 UDP 的区别 ★★★★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-TCP-协议中的定时器-★★"><span class="nav-text">12. TCP 协议中的定时器 ★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-TCP-是如何保证可靠性的-★★★★"><span class="nav-text">13. TCP 是如何保证可靠性的 ★★★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-UDP-为什么是不可靠的，bind-和-connect-对于-UDP-的作用是什么-★★★"><span class="nav-text">14. UDP 为什么是不可靠的，bind 和 connect 对于 UDP 的作用是什么 ★★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-TCP-超时重传的原理-★★★"><span class="nav-text">15. TCP 超时重传的原理 ★★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-TCP-的停止等待协议是什么-★★★"><span class="nav-text">16. TCP 的停止等待协议是什么 ★★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-TCP-最大连接数限制-★★"><span class="nav-text">17. TCP 最大连接数限制 ★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-TCP-流量控制与拥塞控制-★★★★"><span class="nav-text">18. TCP 流量控制与拥塞控制 ★★★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-如果接收方滑动窗口满了，发送方会怎么做-★★★★"><span class="nav-text">19. 如果接收方滑动窗口满了，发送方会怎么做 ★★★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-TCP-拥塞控制采用的四种算法-★★★"><span class="nav-text">20. TCP 拥塞控制采用的四种算法 ★★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-TCP-粘包问题-★★★"><span class="nav-text">21. TCP 粘包问题 ★★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-TCP-报文包含哪些信息-★★"><span class="nav-text">22. TCP 报文包含哪些信息 ★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-SYN-FLOOD-是什么-★★★"><span class="nav-text">23. SYN FLOOD 是什么 ★★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-为什么服务端易收到-SYN-攻击-★★★"><span class="nav-text">24. 为什么服务端易收到 SYN 攻击 ★★★</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-高并发服务器客户端主动关闭连接和服务端主动关闭连接的区别（针对-TCP-服务）-★"><span class="nav-text">25. 高并发服务器客户端主动关闭连接和服务端主动关闭连接的区别（针对 TCP 服务） ★</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="隋钟元"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">隋钟元</p>
  <div class="site-description" itemprop="description">技术创造价值</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">343</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">474</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:24suixinsuoyu@gmail.com" title="E-Mail → mailto:24suixinsuoyu@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/24suixinsuoyu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;24suixinsuoyu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/24sxsy" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;24sxsy" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/guolin_blog" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;guolin_blog" rel="noopener" target="_blank">郭霖</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/lmj623565791/" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;lmj623565791&#x2F;" rel="noopener" target="_blank">鸿洋</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.520monkey.com/" title="http:&#x2F;&#x2F;www.520monkey.com&#x2F;" rel="noopener" target="_blank">姜维</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://daimajia.com/" title="https:&#x2F;&#x2F;daimajia.com&#x2F;" rel="noopener" target="_blank">代码家</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://kmxz.net/" title="https:&#x2F;&#x2F;kmxz.net&#x2F;" rel="noopener" target="_blank">孔祥舟</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://yangwenbo.com/" title="http:&#x2F;&#x2F;yangwenbo.com&#x2F;" rel="noopener" target="_blank">杨文博</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">隋钟元</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">1.6m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">24:02</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>

