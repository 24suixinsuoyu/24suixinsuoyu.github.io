<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"24suixinsuoyu.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一. OkHttpClient">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 三方库源码解析系列（三）：OkHttp 原理及源码解析">
<meta property="og:url" content="http://24suixinsuoyu.com/2021/02/13/Android-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%9AOkHttp-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="隋钟元’s Blog">
<meta property="og:description" content="一. OkHttpClient">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gov17uu5h6j30wq0u0jt1.jpg">
<meta property="article:published_time" content="2021-02-13T02:47:17.000Z">
<meta property="article:modified_time" content="2021-03-24T07:46:22.234Z">
<meta property="article:author" content="隋钟元">
<meta property="article:tag" content="Android 三方库源码解析系列">
<meta property="article:tag" content="OkHttp 原理及源码解析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gov17uu5h6j30wq0u0jt1.jpg">

<link rel="canonical" href="http://24suixinsuoyu.com/2021/02/13/Android-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%9AOkHttp-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>Android 三方库源码解析系列（三）：OkHttp 原理及源码解析 | 隋钟元’s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">隋钟元’s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-university"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th-list"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-english">

    <a href="/english/" rel="section"><i class="fa fa-fw fa-graduation-cap"></i>英语</a>

  </li>
        <li class="menu-item menu-item-life">

    <a href="/life/" rel="section"><i class="fa fa-fw fa-balance-scale"></i>生活</a>

  </li>
        <li class="menu-item menu-item-resume">

    <a href="/resume/" rel="section"><i class="fa fa-fw fa-user-circle-o"></i>简历</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/commonweal/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/24suixinsuoyu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://24suixinsuoyu.com/2021/02/13/Android-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%9AOkHttp-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="隋钟元">
      <meta itemprop="description" content="技术创造价值">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="隋钟元’s Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android 三方库源码解析系列（三）：OkHttp 原理及源码解析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-13 10:47:17" itemprop="dateCreated datePublished" datetime="2021-02-13T10:47:17+08:00">2021-02-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-24 15:46:22" itemprop="dateModified" datetime="2021-03-24T15:46:22+08:00">2021-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E3%80%8AAndroid-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%E3%80%8B/" itemprop="url" rel="index"><span itemprop="name">《Android 三方库源码解析系列》</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="一-OkHttpClient"><a href="#一-OkHttpClient" class="headerlink" title="一. OkHttpClient"></a>一. OkHttpClient</h3><a id="more"></a>

<ul>
<li><p>Demo</p>
  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const <span class="keyword">val</span> URL = <span class="string">"https://publicobject.com/helloworld.txt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 请求</span></span><br><span class="line"><span class="keyword">fun</span> main<span class="literal">()</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> okHttClient = OkHttpClient.<span class="constructor">Builder()</span></span><br><span class="line">        .connect<span class="constructor">Timeout(Duration.<span class="params">ofSeconds</span>(10)</span>)</span><br><span class="line">        .read<span class="constructor">Timeout(Duration.<span class="params">ofSeconds</span>(10)</span>)</span><br><span class="line">        .write<span class="constructor">Timeout(Duration.<span class="params">ofSeconds</span>(10)</span>)</span><br><span class="line">        .retry<span class="constructor">OnConnectionFailure(<span class="params">true</span>)</span></span><br><span class="line">        .build<span class="literal">()</span></span><br><span class="line">    <span class="keyword">val</span> request = Request.<span class="constructor">Builder()</span>.url(URL).build<span class="literal">()</span></span><br><span class="line">    <span class="keyword">val</span> call = okHttClient.<span class="keyword">new</span><span class="constructor">Call(<span class="params">request</span>)</span></span><br><span class="line">    <span class="keyword">val</span> response = call.execute<span class="literal">()</span></span><br><span class="line">    println(response.body?.<span class="built_in">string</span><span class="literal">()</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 <strong>Builder 模式</strong>得到 OkHttpClient，<strong>OkHttpClient 包含了对网络请求的全局配置信息</strong>，包括链接超时时间、读写超时时间、链接失败重试等各种配置</li>
<li>通过 <strong>Builder 模式</strong>得到 Request，<strong>Request 包含了本次网络请求的所有请求参数</strong>，包括 url、method、headers、body 等</li>
<li>通过 <code>newCall()</code> 方法得到 Call，<strong>Call 就用于发起请求</strong>，可用于执行<strong>同步请求（execute）、异步请求（enqueue）、取消请求（cancel）</strong>等各种操作</li>
<li>调用 <code>execute()</code> 方法发起同步请求并返回一个 Response 对象，<strong>Response 就包含了此次网络请求的所有返回信息</strong>，如果请求失败的话此方法会抛出异常</li>
<li>拿到 Response 对象的 <strong>body</strong> 并以字符串流的方式进行读取并打印</li>
</ul>
</li>
<li><p><strong>OkHttpClient 使用了 Builder 模式来完成初始化，其提供了很多的配置参数</strong>，每个选项都有默认值</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="comment">//调度器</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> dispatcher: Dispatcher = Dispatcher()</span><br><span class="line">    <span class="comment">//连接池</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> connectionPool: ConnectionPool = ConnectionPool()</span><br><span class="line">    <span class="comment">//拦截器列表</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> interceptors: MutableList&lt;Interceptor&gt; = mutableListOf()</span><br><span class="line">    <span class="comment">//网络拦截器列表</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> networkInterceptors: MutableList&lt;Interceptor&gt; = mutableListOf()</span><br><span class="line">    <span class="comment">//事件监听</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> eventListenerFactory: EventListener.Factory = EventListener.NONE.asFactory()</span><br><span class="line">    <span class="comment">//连接失败的时候是否重试</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> retryOnConnectionFailure = <span class="literal">true</span> </span><br><span class="line">    <span class="comment">//源服务器身份验证</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> authenticator: Authenticator = Authenticator.NONE</span><br><span class="line">    <span class="comment">//是否允许重定向</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> followRedirects = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//是否允许ssl重定向</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> followSslRedirects = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//Cookie</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> cookieJar: CookieJar = CookieJar.NO_COOKIES</span><br><span class="line">    <span class="comment">//缓存</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> cache: Cache? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//DNS</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> dns: Dns = Dns.SYSTEM</span><br><span class="line">    <span class="comment">//代理</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> proxy: Proxy? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//代理选择器</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> proxySelector: ProxySelector? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//代理身份验证</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> proxyAuthenticator: Authenticator = Authenticator.NONE</span><br><span class="line">    <span class="comment">//Socket工厂</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> socketFactory: SocketFactory = SocketFactory.getDefault()</span><br><span class="line">    <span class="comment">//安全套接层</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> sslSocketFactoryOrNull: SSLSocketFactory? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> x509TrustManagerOrNull: X509TrustManager? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> connectionSpecs: List&lt;ConnectionSpec&gt; = DEFAULT_CONNECTION_SPECS</span><br><span class="line">    <span class="comment">//HTTP 协议</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> protocols: List&lt;Protocol&gt; = DEFAULT_PROTOCOLS</span><br><span class="line">    <span class="comment">//主机名字确认</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> hostnameVerifier: HostnameVerifier = OkHostnameVerifier</span><br><span class="line">    <span class="comment">//证书链</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> certificatePinner: CertificatePinner = CertificatePinner.DEFAULT</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> certificateChainCleaner: CertificateChainCleaner? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> callTimeout = <span class="number">0</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> connectTimeout = <span class="number">10_000</span></span><br><span class="line">    <span class="comment">//读超时</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> readTimeout = <span class="number">10_000</span></span><br><span class="line">    <span class="comment">//写超时</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> writeTimeout = <span class="number">10_000</span></span><br><span class="line">    <span class="comment">//ping 之间的时间间隔</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> pingInterval = <span class="number">0</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> minWebSocketMessageToCompress = RealWebSocket.DEFAULT_MINIMUM_DEFLATE_SIZE</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> routeDatabase: RouteDatabase? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="二-Request"><a href="#二-Request" class="headerlink" title="二. Request"></a>二. Request</h3><ul>
<li><p><strong>Request 包含了网络请求时的所有请求参数</strong>，一共包含以下五个</p>
<ol>
<li><p><strong>url</strong>：本次的网络请求地址以及可能包含的 query 键值对</p>
</li>
<li><p><strong>method</strong>：请求方式，可选参数有 GET、HEAD、POST、DELETE、PUT、PATCH</p>
</li>
<li><p><strong>headers</strong>：请求头，可用来存 token、时间戳等</p>
</li>
<li><p><strong>body</strong>：请求体</p>
</li>
<li><p><strong>tags</strong>：可用来唯一标识本次请求</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">var</span> url: HttpUrl? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">var</span> method: String</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">var</span> headers: Headers.Builder</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">var</span> body: RequestBody? = <span class="literal">null</span></span><br><span class="line"><span class="comment">/** A mutable map of tags, or an immutable empty map if we don't have any. */</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">var</span> tags: MutableMap&lt;Class&lt;*&gt;, Any&gt; = mutableMapOf()</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h3 id="三-Call"><a href="#三-Call" class="headerlink" title="三. Call"></a>三. Call</h3><ul>
<li><p>当调用 <strong><code>okHttpClient.newCall(request)</code></strong> 时就会得到一个 Call 对象</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Prepares the [request] to be executed at some point in the future. */</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Call = RealCall(<span class="keyword">this</span>, request, forWebSocket = <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Call 是一个接口</strong>，我们可以将其看做是网络请求的启动器，可用于发起<strong>同步请求</strong>或<strong>异步请求</strong>，<strong>但重复发起多次请求的话会抛出异常</strong></p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Call</span> : <span class="type">Cloneable &#123;</span></span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">//返回本次网络请求的 Request 对象</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">()</span></span>: Request</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//发起同步请求，可能会抛出异常</span></span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//发起异步请求，通过 Callback 来回调最终结果 </span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="type">Callback</span>)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//取消网络请求</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否已经发起过请求</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">isExecuted</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否已经取消请求</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">isCanceled</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//超时计算</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">timeout</span><span class="params">()</span></span>: Timeout</span><br><span class="line"></span><br><span class="line">  <span class="comment">//同个 Call 不允许重复发起请求，想要再次发起请求可以通过此方法得到一个新的 Call 对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">clone</span><span class="params">()</span></span>: Call</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Factory &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Call</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>newCall()</code> 方法返回的实际类型是 RealCall，它是 Call 接口的唯一实现类</strong></p>
</li>
<li><p>当我们调用 <strong><code>execute()</code></strong> 方法发起同步请求时，其主要逻辑是</p>
<ol>
<li><p>判读是否重复请求</p>
</li>
<li><p>事件记录</p>
</li>
<li><p>将自身加入到 dispatcher 中，并在请求结束时从 dispatcher 中移除自身</p>
</li>
<li><p>通过 <strong><code>getResponseWithInterceptorChain()</code></strong> 方法得到 Response 对象</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealCall</span></span>(</span><br><span class="line">  <span class="keyword">val</span> client: OkHttpClient,</span><br><span class="line">  <span class="comment">/** The application's original request unadulterated by redirects or auth headers. */</span></span><br><span class="line">  <span class="keyword">val</span> originalRequest: Request,</span><br><span class="line">  <span class="keyword">val</span> forWebSocket: <span class="built_in">Boolean</span></span><br><span class="line">) : Call &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123; <span class="string">"Already Executed"</span> &#125;</span><br><span class="line">    timeout.enter()</span><br><span class="line">    callStart()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h3 id="四-Dispatcher"><a href="#四-Dispatcher" class="headerlink" title="四. Dispatcher"></a>四. Dispatcher</h3><ul>
<li><p><strong>Dispatcher 是一个调度器，用于对全局的网络请求进行缓存调度</strong>，其包含以下几个成员变量</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxRequests = <span class="number">64</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">var</span> maxRequestsPerHost = <span class="number">5</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">/** Ready async calls in the order they'll be run. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> readyAsyncCalls = <span class="type">ArrayDeque</span>&lt;<span class="type">AsyncCall</span>&gt;()</span><br><span class="line">	</span><br><span class="line"><span class="comment">/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> runningAsyncCalls = <span class="type">ArrayDeque</span>&lt;<span class="type">AsyncCall</span>&gt;()</span><br><span class="line">	</span><br><span class="line"><span class="comment">/** Running synchronous calls. Includes canceled calls that haven't finished yet. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> runningSyncCalls = <span class="type">ArrayDeque</span>&lt;<span class="type">RealCall</span>&gt;()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>maxRequests</strong>：同一时间允许并发执行网络请求的最大线程数</li>
<li><strong>maxRequestsPerHost</strong>：同一 host 下的最大同时请求数</li>
<li><strong>readyAsyncCalls</strong>：保存当前等待执行的异步任务</li>
<li><strong>runningAsyncCalls</strong>：保存当前正在执行的异步任务</li>
<li><strong>runningSyncCalls</strong>：保存当前正在执行的同步任务</li>
</ul>
</li>
<li><p>客户端不应该无限制地同时发起多个网络请求，因为除了网络资源所限外，系统资源也是有限的，每个请求都需要由一个线程来执行，而系统支持并发执行的线程数量是有限的，所以 OkHttp 内部就使用 <strong>maxRequests</strong> 来控制同时执行异步请求的最大线程数。此外，OkHttp 为了提高效率，允许多个指向同一 host 的网络请求共享同一个 Socket，而最大共享数量即 <strong>maxRequestsPerHost</strong></p>
</li>
<li><p>为了统计以上两个运行参数，就需要使用 readyAsyncCalls、runningAsyncCalls 和 runningSyncCalls 来保存当前正在执行或者准备执行的网络请求。<strong>runningSyncCalls</strong> 用于保存当前正在执行的同步任务，其存储的是 <strong>RealCall</strong>；<strong>readyAsyncCalls</strong> 和 <strong>runningAsyncCalls</strong> 用于保存异步任务，其存储的是 <strong>AsyncCall</strong></p>
</li>
</ul>
<h4 id="1-同步请求"><a href="#1-同步请求" class="headerlink" title="1. 同步请求"></a>1. 同步请求</h4><ul>
<li><p>RealCall 的 <strong><code>execute()</code></strong> 方法在开始请求前，会先将自身传给 dispatcher，在请求结束后又会从 dispatcher 中移除</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealCall</span></span>(</span><br><span class="line">  <span class="keyword">val</span> client: OkHttpClient,</span><br><span class="line">  <span class="comment">/** The application's original request unadulterated by redirects or auth headers. */</span></span><br><span class="line">  <span class="keyword">val</span> originalRequest: Request,</span><br><span class="line">  <span class="keyword">val</span> forWebSocket: <span class="built_in">Boolean</span></span><br><span class="line">) : Call &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123; <span class="string">"Already Executed"</span> &#125;</span><br><span class="line">    timeout.enter()</span><br><span class="line">    callStart()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//添加到 dispatcher</span></span><br><span class="line">      client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//从 dispatcher 中移除</span></span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Dispatcher 内部也只是相应的将 RealCall 添加到 runningSyncCalls 中或者是将其从 runningSyncCalls 中移除，保存到 runningSyncCalls 的目的是为了<strong>方便统计当前所有正在运行的请求总数</strong>以及<strong>能够取消所有请求</strong></p>
</li>
<li><p><strong>由于同步请求会直接运行在调用者所在线程上，所以同步请求并不会受 maxRequests 的限制</strong></p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">/** Used by [Call.execute] to signal it is in-flight. */</span></span><br><span class="line">  	  <span class="meta">@Synchronized</span> </span><br><span class="line">      <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">executed</span><span class="params">(call: <span class="type">RealCall</span>)</span></span> &#123;</span><br><span class="line">    	runningSyncCalls.add(call)</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">/** Used by [Call.execute] to signal completion. */</span></span><br><span class="line">  	  <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">finished</span><span class="params">(call: <span class="type">RealCall</span>)</span></span> &#123;</span><br><span class="line">    	finished(runningSyncCalls, call)</span><br><span class="line">  	  &#125;</span><br><span class="line"></span><br><span class="line">  	  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">finished</span><span class="params">(calls: <span class="type">Deque</span>&lt;<span class="type">T</span>&gt;, call: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    	<span class="keyword">val</span> idleCallback: Runnable?</span><br><span class="line">    	synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      		<span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>)</span><br><span class="line">      		idleCallback = <span class="keyword">this</span>.idleCallback</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">//判断是否有需要处理的网络请求</span></span><br><span class="line">    	<span class="keyword">val</span> isRunning = promoteAndExecute()</span><br><span class="line">    	<span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">      		idleCallback.run()</span><br><span class="line">    	&#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-异步请求"><a href="#2-异步请求" class="headerlink" title="2. 异步请求"></a>2. 异步请求</h4><ul>
<li><p>RealCall 的 <strong><code>enqueue()</code></strong> 方法会将外部传入的 Callback 包装为一个 <strong>AsyncCall</strong> 对象后传给 dispatcher</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealCall</span></span>(</span><br><span class="line">  <span class="keyword">val</span> client: OkHttpClient,</span><br><span class="line">  <span class="comment">/** The application's original request unadulterated by redirects or auth headers. */</span></span><br><span class="line">  <span class="keyword">val</span> originalRequest: Request,</span><br><span class="line">  <span class="keyword">val</span> forWebSocket: <span class="built_in">Boolean</span></span><br><span class="line">) : Call &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="type">Callback</span>)</span></span> &#123;</span><br><span class="line">    check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123; <span class="string">"Already Executed"</span> &#125;</span><br><span class="line">    callStart()</span><br><span class="line">    client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于 <strong><code>enqueue()</code></strong> 对应的是异步请求，所以 OkHttp 内部就需要自己构造一个线程来执行请求，在请求结束后再通过 Callback 来将结果值回调给外部，异步请求逻辑对应的载体就是 <strong>AsyncCall</strong> 这个类</p>
</li>
<li><p><strong>AsyncCall 是 RealCall 的非静态内部类</strong>，所以 AsyncCall 可以访问到 RealCall 的所有变量和方法。此外，<strong>AsyncCall 继承了 Runnable 接口</strong>，其 <code>executeOn()</code> 方法就用于传入一个<strong>线程池对象</strong>来执行 <code>run()</code> 方法。<strong><code>run()</code> 方法内还是调用了 <code>getResponseWithInterceptorChain()</code> 方法来获取 response</strong>，并通过 <strong>Callback</strong> 来将执行结果（不管成功还是失败）回调出去，在请求结束后也会将自身从 dispatcher 中移除</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> responseCallback: Callback</span><br><span class="line">) : Runnable &#123;</span><br><span class="line">  <span class="meta">@Volatile</span> <span class="keyword">var</span> callsPerHost = AtomicInteger(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">	</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">reuseCallsPerHostFrom</span><span class="params">(other: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.callsPerHost = other.callsPerHost</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="type">ExecutorService</span>)</span></span> &#123;</span><br><span class="line">    client.dispatcher.assertThreadDoesntHoldLock()</span><br><span class="line">    <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executorService.execute(<span class="keyword">this</span>)</span><br><span class="line">      success = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: RejectedExecutionException) &#123;</span><br><span class="line">      <span class="keyword">val</span> ioException = InterruptedIOException(<span class="string">"executor rejected"</span>)</span><br><span class="line">      ioException.initCause(e)</span><br><span class="line">      noMoreExchanges(ioException)</span><br><span class="line">      responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, ioException)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        client.dispatcher.finished(<span class="keyword">this</span>) <span class="comment">// This call is no longer running!</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    threadName(<span class="string">"OkHttp <span class="subst">$&#123;redactedUrl()&#125;</span>"</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> signalledCallback = <span class="literal">false</span></span><br><span class="line">      timeout.enter()</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> response = getResponseWithInterceptorChain()</span><br><span class="line">        signalledCallback = <span class="literal">true</span></span><br><span class="line">        responseCallback.onResponse(<span class="keyword">this</span><span class="symbol">@RealCall</span>, response)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">          <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">          Platform.<span class="keyword">get</span>().log(<span class="string">"Callback failure for <span class="subst">$&#123;toLoggableString()&#125;</span>"</span>, Platform.INFO, e)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (t: Throwable) &#123;</span><br><span class="line">        cancel()</span><br><span class="line">        <span class="keyword">if</span> (!signalledCallback) &#123;</span><br><span class="line">          <span class="keyword">val</span> canceledException = IOException(<span class="string">"canceled due to <span class="variable">$t</span>"</span>)</span><br><span class="line">          canceledException.addSuppressed(t)</span><br><span class="line">          responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, canceledException)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> t</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Dispatcher 在拿到 AsyncCall 对象后，会先将其存到 <strong>readyAsyncCalls</strong> 中，然后通过 <code>findExistingCallWithHost()</code> 方法来查找当前是否有指向同一 Host 的异步请求，有的话则交换 callsPerHost 变量，该变量就用于标记当前指向同一 Host 的请求数量，最后调用 <code>promoteAndExecute()</code> 方法来判断当前是否允许发起请求</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      readyAsyncCalls.add(call)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span></span><br><span class="line">      <span class="comment">// the same host.</span></span><br><span class="line">      <span class="keyword">if</span> (!call.call.forWebSocket) &#123;</span><br><span class="line">        <span class="comment">//查找当前是否有指向同一 Host 的异步请求</span></span><br><span class="line">        <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host)</span><br><span class="line">        <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    promoteAndExecute()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findExistingCallWithHost</span><span class="params">(host: <span class="type">String</span>)</span></span>: AsyncCall? &#123;</span><br><span class="line">    <span class="keyword">for</span> (existingCall <span class="keyword">in</span> runningAsyncCalls) &#123;</span><br><span class="line">      <span class="keyword">if</span> (existingCall.host == host) <span class="keyword">return</span> existingCall</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (existingCall <span class="keyword">in</span> readyAsyncCalls) &#123;</span><br><span class="line">      <span class="keyword">if</span> (existingCall.host == host) <span class="keyword">return</span> existingCall</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于当前正在执行的网络请求总数可能已经达到限制，或者是指向同一 Host 的请求也达到限制了，所以 <code>promoteAndExecute()</code> 方法就用于从待执行列表 <strong>readyAsyncCalls</strong> 中获取当前符合运行条件的所有请求，将请求存到 <strong>runningAsyncCalls</strong> 中，并调用<strong>线程池</strong>来执行</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">    <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line">      <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line">	    <span class="comment">//如果当前正在执行的异步请求总数已经超出限制，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// Max capacity.</span></span><br><span class="line">        <span class="comment">//如果指向同个 Host 的请求总数已经超出限制，则取下一个请求</span></span><br><span class="line">        <span class="keyword">if</span> (asyncCall.callsPerHost.<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">        i.remove()</span><br><span class="line">        <span class="comment">//将 callsPerHost 递增加一，表示指向该 Host 的链接数加一了</span></span><br><span class="line">        asyncCall.callsPerHost.incrementAndGet()</span><br><span class="line">        <span class="comment">//将 asyncCall 存到可执行列表中</span></span><br><span class="line">        executableCalls.add(asyncCall)</span><br><span class="line">        <span class="comment">//将 asyncCall 存到正在执行列表中</span></span><br><span class="line">        runningAsyncCalls.add(asyncCall)</span><br><span class="line">      &#125;</span><br><span class="line">      isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行所有符合条件的请求</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">      <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">      asyncCall.executeOn(executorService)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isRunning</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-ArrayDeque"><a href="#3-ArrayDeque" class="headerlink" title="3. ArrayDeque"></a>3. ArrayDeque</h4><ul>
<li>三种请求的存储容器是 ArrayDeque。<strong>ArrayDeque 属于非线程安全的双端队列</strong>，所以涉及到多线程操作时都需要外部主动线程同步</li>
<li><strong>OkHttp 选择 ArrayDeque 作为任务容器</strong>可能的原因<ul>
<li>ArrayDeque 内部使用<strong>数组</strong>结构来存储数据，元素具有明确的先后顺序，这符合我们对网络请求先到先执行的基本预期</li>
<li>在选择符合运行条件的异步请求时，需要对 readyAsyncCalls 进行<strong>遍历</strong>，数组在遍历效率上会比较高</li>
<li>在遍历到符合条件的请求后，需要将请求从 readyAsyncCalls 中移除并转移到 runningAsyncCalls 中，而 ArrayDeque 作为双端队列，在<strong>内存</strong>空间利用率上比较高</li>
<li>Dispatcher 面对的就是<strong>多线程</strong>环境，本身就需要进行线程同步，选择 ArrayDeque 这个非线程安全的容器可以省去多余的线程同步消耗</li>
</ul>
</li>
</ul>
<h4 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4. 线程池"></a>4. 线程池</h4><ul>
<li><p>OkHttp 的<strong>异步请求</strong>是交由其内部的<strong>线程池</strong>来完成的</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> executorServiceOrNull: ExecutorService? = <span class="literal">null</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">@get:Synchronized</span></span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">"executorService"</span>) <span class="keyword">val</span> executorService: ExecutorService</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (executorServiceOrNull == <span class="literal">null</span>) &#123;</span><br><span class="line">      executorServiceOrNull = ThreadPoolExecutor(<span class="number">0</span>, <span class="built_in">Int</span>.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">          SynchronousQueue(), threadFactory(<span class="string">"<span class="variable">$okHttpName</span> Dispatcher"</span>, <span class="literal">false</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorServiceOrNull!!</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>核心线程数为 0，线程超时时间是 60 秒</strong>。说明在没有待执行的任务的时候，如果线程闲置了 60 秒，那么线程就会被回收，这可以避免空闲线程白白浪费系统资源，适合于移动设备资源紧缺的情景</li>
<li>允许的最大线程数为 <code>Int.MAX_VALUE</code>，可以看做是完全没有限制的，且任务队列是 <strong>SynchronousQueue</strong>。<strong>SynchronousQueue 的特点是当有任务入队时，必须等待该任务被消费否则入队操作就会一直被阻塞</strong>，而由于线程池允许的最大线程数量是无限的，所以每个入队的任务都能马上交由线程处理（交付给空闲线程或者新建一个线程来处理），这就保证了任务的处理及时性，符合我们对网络请求应该尽快发起并完成的期望</li>
</ul>
</li>
<li><p>虽然线程池本身对于最大线程数几乎没有限制，但是由于提交任务的操作还受 maxRequests 的控制，所以<strong>实际上该线程池最多同时运行 maxRequests 个线程</strong></p>
</li>
</ul>
<h4 id="5-推动请求执行"><a href="#5-推动请求执行" class="headerlink" title="5. 推动请求执行"></a>5. 推动请求执行</h4><ul>
<li><p>OkHttp 内部的线程池是不可能无限制地新建线程来执行请求的，那么当请求总数已达到 maxRequests 后，后续的请求只能是先处于等待状态，<strong>这些等待状态的请求被启动实际涉及到 Dispatcher 调度</strong></p>
</li>
<li><p>同步请求和异步请求结束后都会调用到 Dispatcher 的两个 <code>finished()</code> 方法，在这两个方法里又会触发到 <code>promoteAndExecute()</code> 方法去遍历任务列表来执行，此时就推动了待处理列表的任务执行操作。所以说，<strong>Dispatcher 中的请求都可以看做是在自发性地启动，每个请求结束都会自动触发下一个请求执行（如果有的话），省去了多余的定时检查这类操作</strong></p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/** Used by [AsyncCall.run] to signal completion. */</span></span><br><span class="line"> <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">finished</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">   call.callsPerHost.decrementAndGet()</span><br><span class="line">   finished(runningAsyncCalls, call)</span><br><span class="line"> &#125;</span><br><span class="line">	</span><br><span class="line"> <span class="comment">/** Used by [Call.execute] to signal completion. */</span></span><br><span class="line"> <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">finished</span><span class="params">(call: <span class="type">RealCall</span>)</span></span> &#123;</span><br><span class="line">   finished(runningSyncCalls, call)</span><br><span class="line"> &#125;</span><br><span class="line">	</span><br><span class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">finished</span><span class="params">(calls: <span class="type">Deque</span>&lt;<span class="type">T</span>&gt;, call: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> idleCallback: Runnable?</span><br><span class="line">   synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>)</span><br><span class="line">     idleCallback = <span class="keyword">this</span>.idleCallback</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//判断当前是否有可以启动的待执行任务，有的话则启动</span></span><br><span class="line">   <span class="keyword">val</span> isRunning = promoteAndExecute()</span><br><span class="line">	</span><br><span class="line">   <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">     idleCallback.run()</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h4><ul>
<li>如果是<strong>同步请求</strong>，那么网络请求过程就会直接在<strong>调用者所在线程</strong>上完成，不受 Dispatcher 的控制</li>
<li>如果是<strong>异步请求</strong>，该请求会先存到待执行列表 readyAsyncCalls 中，该请求是否可以立即发起受 <strong>maxRequests</strong> 和 <strong>maxRequestsPerHost</strong> 两个条件的限制。如果符合条件，那么就会从 readyAsyncCalls 取出并存到 runningAsyncCalls 中，然后交由 OkHttp 内部的<strong>线程池</strong>来执行</li>
<li>不管外部是同步请求还是异步请求，内部都是通过调用 <strong><code>getResponseWithInterceptorChain()</code></strong> 方法来拿到 Response 的</li>
<li>Dispatcher 内部的线程池本身允许同时运行 <code>Int.MAX_VALUE</code> 个线程，但是实际上的线程数量还是受 <strong>maxRequests</strong> 的控制</li>
</ul>
<h3 id="五-RealInterceptorChain"><a href="#五-RealInterceptorChain" class="headerlink" title="五. RealInterceptorChain"></a>五. RealInterceptorChain</h3><ul>
<li><p><strong><code>getResponseWithInterceptorChain()</code> 方法，其主要逻辑就是通过拦截器来完成整个网络请求过程</strong>。在该方法中，除了会获取外部主动设置的拦截器外，也会默认添加以下几个拦截器</p>
<ul>
<li><strong>RetryAndFollowUpInterceptor</strong>：负责失败重试以及重定向</li>
<li><strong>BridgeInterceptor</strong>：负责对用户构造的 Request 进行转换，添加必要的 header 和 cookie，在得到 response 后如果有需要的会进行 gzip 解压</li>
<li><strong>CacheInterceptor</strong>：用于处理缓存</li>
<li><strong>ConnectInterceptor</strong>：负责和服务器建立连接</li>
<li><strong>CallServerInterceptor</strong>：负责向服务器发送请求和从服务器接收数据</li>
</ul>
</li>
<li><p>最后，request 和 interceptors 会用来生成一个 <strong>RealInterceptorChain</strong> 对象，由其来最终返回 response</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">  <span class="comment">//添加开发者设置的拦截器</span></span><br><span class="line">  interceptors += client.interceptors</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//添加默认的拦截器</span></span><br><span class="line">  interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">  interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">  interceptors += CacheInterceptor(client.cache)</span><br><span class="line">  interceptors += ConnectInterceptor</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    <span class="comment">//如果不是 WebSocket 的话，那就再添加开发者设置的 NetworkInterceptors</span></span><br><span class="line">    interceptors += client.networkInterceptors</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//CallServerInterceptor 是实际上发起网络请求的地方</span></span><br><span class="line">  interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">val</span> chain = RealInterceptorChain(</span><br><span class="line">      call = <span class="keyword">this</span>,</span><br><span class="line">      interceptors = interceptors,</span><br><span class="line">      index = <span class="number">0</span>,</span><br><span class="line">      exchange = <span class="literal">null</span>,</span><br><span class="line">      request = originalRequest,</span><br><span class="line">      connectTimeoutMillis = client.connectTimeoutMillis,</span><br><span class="line">      readTimeoutMillis = client.readTimeoutMillis,</span><br><span class="line">      writeTimeoutMillis = client.writeTimeoutMillis</span><br><span class="line">  )</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line">    <span class="keyword">if</span> (isCanceled()) &#123;</span><br><span class="line">      response.closeQuietly()</span><br><span class="line">      <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">    calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">throw</span> noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">      noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Interceptor 是 OkHttp 里很重要的一环，OkHttp 也是靠此为开发者提供了很高的自由度。<strong>Interceptor 接口本身只包含一个 <code>intercept()</code> 方法</strong>，在此方法内可拿到原始的 Request 对象以及最终的 Response</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Interceptor &#123;</span></span><br><span class="line">   <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Chain</span>)</span></span>: Response   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>例如，我们可以<strong>自定义</strong>一个 LogInterceptor 来打印网络请求的请求参数以及最终的返回值</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span> : <span class="type">Interceptor &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">        <span class="keyword">val</span> request = chain.request()</span><br><span class="line">        println(request)</span><br><span class="line">        <span class="keyword">val</span> response = chain.proceed(request)</span><br><span class="line">        println(response)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Interceptor 的实现初衷是为了给开发者提供一个可以控制网络请求的<strong>发起过程</strong>及<strong>收尾工作</strong>的入口，例如<strong>添加 header、日志记录、请求拦截、ResponseBody修改</strong>等，每个 Interceptor 只负责自己关心的操作，那么势必就会有添加多个 Interceptor 的需求</p>
</li>
<li><p>只有让每个 Interceptor 都依次处理完 request 之后，OkHttp 才能根据最终的 request 对象去联网请求得到 response，所以<strong>每个 Interceptor 需要依次拿到 request 进行自定义处理</strong>。请求到 response 后，Interceptor 可能还需要对 response 进行处理，那么就还需要将 response 再依次传递给每个 Interceptor</p>
</li>
<li><p><strong>OkHttp 实现 RealInterceptorChain 的思路本质上就是通过将多个拦截器以责任链的方式来一层层调用，上一个拦截器处理完后将就将结果传给下一个拦截器，直到最后一个拦截器（即 CallServerInterceptor ）处理完后将 Response 再一层层往上传递</strong></p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealInterceptorChain</span></span>(</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">val</span> call: RealCall,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> interceptors: List&lt;Interceptor&gt;,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> index: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">val</span> exchange: Exchange?,</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">val</span> request: Request,</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">val</span> connectTimeoutMillis: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">val</span> readTimeoutMillis: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">val</span> writeTimeoutMillis: <span class="built_in">Int</span></span><br><span class="line">) : Interceptor.Chain &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    index: <span class="type">Int</span> = this.index,</span></span></span><br><span class="line"><span class="function"><span class="params">    exchange: <span class="type">Exchange</span>? = this.exchange,</span></span></span><br><span class="line"><span class="function"><span class="params">    request: <span class="type">Request</span> = this.request,</span></span></span><br><span class="line"><span class="function"><span class="params">    connectTimeoutMillis: <span class="type">Int</span> = this.connectTimeoutMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">    readTimeoutMillis: <span class="type">Int</span> = this.readTimeoutMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">    writeTimeoutMillis: <span class="type">Int</span> = this.writeTimeoutMillis</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span> = RealInterceptorChain(call, interceptors, index, exchange, request, connectTimeoutMillis,</span><br><span class="line">      readTimeoutMillis, writeTimeoutMillis)</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Response &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">val</span> next = copy(index = index + <span class="number">1</span>, request = request)</span><br><span class="line">    <span class="keyword">val</span> interceptor = interceptors[index]</span><br><span class="line">    <span class="meta">@Suppress(<span class="meta-string">"USELESS_ELVIS"</span>)</span></span><br><span class="line">    <span class="keyword">val</span> response = interceptor.intercept(next) ?: <span class="keyword">throw</span> NullPointerException(</span><br><span class="line">        <span class="string">"interceptor <span class="variable">$interceptor</span> returned null"</span>)</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="六-Interceptor"><a href="#六-Interceptor" class="headerlink" title="六. Interceptor"></a>六. Interceptor</h3><ul>
<li><p>我们在构建 OkHttpClient 的时候，<strong>添加拦截器</strong>的方法分为两类：<strong><code>addInterceptor()</code></strong> 和 <strong><code>addNetworkInterceptor()</code></strong></p>
  <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val okHttClient = OkHttpClient.Builder()</span><br><span class="line">    .<span class="function"><span class="title">addInterceptor</span> &#123; chain -&gt;</span></span><br><span class="line">        chain.proceed(chain.request())</span><br><span class="line">    &#125;</span><br><span class="line">    .<span class="function"><span class="title">addNetworkInterceptor</span> &#123; chain -&gt;</span></span><br><span class="line">        chain.proceed(chain.request())</span><br><span class="line">    &#125;</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Interceptor 是应用拦截器；NetworkInterceptor 是网络拦截器</strong></li>
</ul>
</li>
<li><p>OkHttp 在执行拦截器的时候，是按照如下顺序的，这个顺序就已经决定了<strong>不同拦截器的调用时机</strong>差异</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val <span class="built_in">int</span>erceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">   <span class="built_in">int</span>erceptors += client.<span class="built_in">int</span>erceptors</span><br><span class="line">   <span class="built_in">int</span>erceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">   <span class="built_in">int</span>erceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">   <span class="built_in">int</span>erceptors += CacheInterceptor(client.cache)</span><br><span class="line">   <span class="built_in">int</span>erceptors += ConnectInterceptor</span><br><span class="line">   <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">     <span class="built_in">int</span>erceptors += client.networkInterceptors</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">int</span>erceptors += CallServerInterceptor(forWebSocket)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>由于应用拦截器处于列表头部，所以在整个责任链路中应用拦截器会首先被执行</strong>，即使之后在 RetryAndFollowUpInterceptor 中发生了<strong>请求失败重试</strong>或者<strong>网络重定向</strong>等情况，<strong>应用拦截器也只会被触发一次，但网络拦截器会被调用多次</strong></p>
</li>
<li><p>网络拦截器位于 CacheInterceptor 之后，那么当 CacheInterceptor  <strong>命中缓存</strong>的时候就不会去执行网络请求了，此时网络拦截器就不会被调用，因此<strong>网络拦截器是存在短路的可能</strong>。此外，网络拦截器位于 ConnectInterceptor 之后，在调用网络拦截器之前就已经准备好网络链接了，说明网络拦截器本身就关联着实际的网络请求逻辑</p>
</li>
<li><p>从单次请求流程上来看，<strong>应用拦截器被调用并不意味着真正有发起了网络请求，而网络拦截器被调用就说明的确发起了一次网络请求</strong>。因此如果我们希望通过拦截器来记录网络请求详情的话，就需要考虑两者的调用时机差异：<strong>应用拦截器无法感知到 OkHttp 自动添加的一些 header，但是网络拦截器可以</strong>；<strong>应用拦截器除非主动中断请求，否则每次请求一定都会被执行，但网络拦截器可能存在被短路的可能</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gov17uu5h6j30wq0u0jt1.jpg" alt="应用拦截器 vs 网络拦截器"></p>
</li>
</ul>
</li>
<li><p>Demo</p>
<ul>
<li><p>需求：<a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/Progress.java" target="_blank" rel="noopener">square 官方提供的例子</a>，实现在下载一张 10 MB 图片的时候通过拦截器对下载进度进行监听，并同时把图片下载到系统的桌面</p>
</li>
<li><p>思路：对原始的 ResponseBody 进行多一层<strong>代理</strong>，计算已经从网络中读取到的字节数和资源的 contentLength 之间的百分比，从而得到下载进度。此外，因为该拦截器是和确切的网络请求相关，所以应该要设为<strong>网络拦截器</strong>才比较合理</p>
</li>
<li><p>代码</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ProgressListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(bytesRead: <span class="type">Long</span>, contentLength: <span class="type">Long</span>, done: <span class="type">Boolean</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">        .url(<span class="string">"https://images.pexels.com/photos/5177790/pexels-photo-5177790.jpeg"</span>)</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">val</span> progressListener: ProgressListener = <span class="keyword">object</span> : ProgressListener &#123;</span><br><span class="line">        <span class="keyword">var</span> firstUpdate = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(bytesRead: <span class="type">Long</span>, contentLength: <span class="type">Long</span>, done: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                println(<span class="string">"completed"</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (firstUpdate) &#123;</span><br><span class="line">                    firstUpdate = <span class="literal">false</span></span><br><span class="line">                    <span class="keyword">if</span> (contentLength == -<span class="number">1L</span>) &#123;</span><br><span class="line">                        println(<span class="string">"content-length: unknown"</span>)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.<span class="keyword">out</span>.format(<span class="string">"content-length: %d\n"</span>, contentLength)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                println(bytesRead)</span><br><span class="line">                <span class="keyword">if</span> (contentLength != -<span class="number">1L</span>) &#123;</span><br><span class="line">                    System.<span class="keyword">out</span>.format(<span class="string">"%d%% done\n"</span>, <span class="number">100</span> * bytesRead / contentLength)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> client = OkHttpClient.Builder()</span><br><span class="line">        .addNetworkInterceptor &#123; chain: Interceptor.Chain -&gt;</span><br><span class="line">            <span class="keyword">val</span> originalResponse = chain.proceed(chain.request())</span><br><span class="line">            originalResponse.newBuilder()</span><br><span class="line">                .body(ProgressResponseBody(originalResponse.body!!, progressListener))</span><br><span class="line">                .build()</span><br><span class="line">        &#125;</span><br><span class="line">        .build()</span><br><span class="line">    client.newCall(request).execute().use &#123; response -&gt;</span><br><span class="line">        <span class="keyword">if</span> (!response.isSuccessful) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IOException(<span class="string">"Unexpected code <span class="variable">$response</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> desktopDir = FileSystemView.getFileSystemView().homeDirectory</span><br><span class="line">        <span class="keyword">val</span> imageFile = File(desktopDir, <span class="string">"<span class="subst">$&#123;System.currentTimeMillis()&#125;</span>.jpeg"</span>)</span><br><span class="line">        imageFile.createNewFile()</span><br><span class="line">        <span class="comment">//读取 InputStream 写入到图片文件中</span></span><br><span class="line">        response.body!!.byteStream().copyTo(imageFile.outputStream())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgressResponseBody</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> responseBody: ResponseBody,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> progressListener: ProgressListener</span><br><span class="line">) : ResponseBody() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> bufferedSource: BufferedSource? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contentType</span><span class="params">()</span></span>: MediaType? &#123;</span><br><span class="line">        <span class="keyword">return</span> responseBody.contentType()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contentLength</span><span class="params">()</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> responseBody.contentLength()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">source</span><span class="params">()</span></span>: BufferedSource &#123;</span><br><span class="line">        <span class="keyword">if</span> (bufferedSource == <span class="literal">null</span>) &#123;</span><br><span class="line">            bufferedSource = source(responseBody.source()).buffer()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bufferedSource!!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">source</span><span class="params">(source: <span class="type">Source</span>)</span></span>: Source &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">object</span> : ForwardingSource(source) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> totalBytesRead = <span class="number">0L</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">(sink: <span class="type">Buffer</span>, byteCount: <span class="type">Long</span>)</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> bytesRead = <span class="keyword">super</span>.read(sink, byteCount)</span><br><span class="line">                <span class="comment">// read() returns the number of bytes read, or -1 if this source is exhausted.</span></span><br><span class="line">                totalBytesRead += <span class="keyword">if</span> (bytesRead != -<span class="number">1L</span>) bytesRead <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                progressListener.update(totalBytesRead, responseBody.contentLength(), bytesRead == -<span class="number">1L</span>)</span><br><span class="line">                <span class="keyword">return</span> bytesRead</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行程序，进度输出</p>
  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">content-length:</span> <span class="number">11448857</span></span><br><span class="line"><span class="number">467</span></span><br><span class="line"><span class="number">0</span><span class="string">%</span> <span class="string">done</span></span><br><span class="line"><span class="number">1836</span></span><br><span class="line"><span class="number">0</span><span class="string">%</span> <span class="string">done</span></span><br><span class="line"><span class="number">3205</span></span><br><span class="line"></span><br><span class="line"><span class="string">···</span></span><br><span class="line"></span><br><span class="line"><span class="number">99</span><span class="string">%</span> <span class="string">done</span></span><br><span class="line"><span class="number">11442570</span></span><br><span class="line"><span class="number">99</span><span class="string">%</span> <span class="string">done</span></span><br><span class="line"><span class="number">11448857</span></span><br><span class="line"><span class="number">100</span><span class="string">%</span> <span class="string">done</span></span><br><span class="line"><span class="string">completed</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>

    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;margin-top:80px">-------------------- 本文结束<i class="fa fa-paw"></i>感谢您的阅读 --------------------</div>
    
</div>
      
    </div>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>隋钟元
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://24suixinsuoyu.com/2021/02/13/Android-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%9AOkHttp-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Android 三方库源码解析系列（三）：OkHttp 原理及源码解析">http://24suixinsuoyu.com/2021/02/13/Android-三方库源码解析系列：OkHttp-原理及源码解析/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Android-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/" rel="tag"><i class="fa fa-tag"></i> Android 三方库源码解析系列</a>
              <a href="/tags/OkHttp-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="tag"><i class="fa fa-tag"></i> OkHttp 原理及源码解析</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/12/Android-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%9AARouter-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="prev" title="Android 三方库源码解析系列（二）：ARouter 原理及源码解析">
      <i class="fa fa-chevron-left"></i> Android 三方库源码解析系列（二）：ARouter 原理及源码解析
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/02/13/Android-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%9ARetrofit-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="next" title="Android 三方库源码解析系列（四）：Retrofit 原理及源码解析">
      Android 三方库源码解析系列（四）：Retrofit 原理及源码解析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一-OkHttpClient"><span class="nav-text">一. OkHttpClient</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-Request"><span class="nav-text">二. Request</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三-Call"><span class="nav-text">三. Call</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四-Dispatcher"><span class="nav-text">四. Dispatcher</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-同步请求"><span class="nav-text">1. 同步请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-异步请求"><span class="nav-text">2. 异步请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-ArrayDeque"><span class="nav-text">3. ArrayDeque</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-线程池"><span class="nav-text">4. 线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-推动请求执行"><span class="nav-text">5. 推动请求执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-总结"><span class="nav-text">6. 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五-RealInterceptorChain"><span class="nav-text">五. RealInterceptorChain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六-Interceptor"><span class="nav-text">六. Interceptor</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="隋钟元"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">隋钟元</p>
  <div class="site-description" itemprop="description">技术创造价值</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">340</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">465</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:24suixinsuoyu@gmail.com" title="E-Mail → mailto:24suixinsuoyu@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/24suixinsuoyu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;24suixinsuoyu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/24sxsy" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;24sxsy" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/guolin_blog" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;guolin_blog" rel="noopener" target="_blank">郭霖</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/lmj623565791/" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;lmj623565791&#x2F;" rel="noopener" target="_blank">鸿洋</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.520monkey.com/" title="http:&#x2F;&#x2F;www.520monkey.com&#x2F;" rel="noopener" target="_blank">姜维</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://daimajia.com/" title="https:&#x2F;&#x2F;daimajia.com&#x2F;" rel="noopener" target="_blank">代码家</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://kmxz.net/" title="https:&#x2F;&#x2F;kmxz.net&#x2F;" rel="noopener" target="_blank">孔祥舟</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://yangwenbo.com/" title="http:&#x2F;&#x2F;yangwenbo.com&#x2F;" rel="noopener" target="_blank">杨文博</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">隋钟元</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">1.4m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">21:18</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>

