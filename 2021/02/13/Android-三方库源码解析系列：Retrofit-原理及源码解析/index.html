<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"24suixinsuoyu.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一. 前言">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 三方库源码解析系列（四）：Retrofit 原理及源码解析">
<meta property="og:url" content="http://24suixinsuoyu.com/2021/02/13/Android-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%9ARetrofit-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="隋钟元’s Blog">
<meta property="og:description" content="一. 前言">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-02-13T03:47:38.000Z">
<meta property="article:modified_time" content="2021-03-24T09:56:38.165Z">
<meta property="article:author" content="隋钟元">
<meta property="article:tag" content="Android 三方库源码解析系列">
<meta property="article:tag" content="Retrofit 原理及源码解析">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://24suixinsuoyu.com/2021/02/13/Android-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%9ARetrofit-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>Android 三方库源码解析系列（四）：Retrofit 原理及源码解析 | 隋钟元’s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">隋钟元’s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-university"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th-list"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-english">

    <a href="/english/" rel="section"><i class="fa fa-fw fa-graduation-cap"></i>英语</a>

  </li>
        <li class="menu-item menu-item-life">

    <a href="/life/" rel="section"><i class="fa fa-fw fa-balance-scale"></i>生活</a>

  </li>
        <li class="menu-item menu-item-resume">

    <a href="/resume/" rel="section"><i class="fa fa-fw fa-user-circle-o"></i>简历</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/commonweal/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/24suixinsuoyu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://24suixinsuoyu.com/2021/02/13/Android-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%9ARetrofit-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="隋钟元">
      <meta itemprop="description" content="技术创造价值">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="隋钟元’s Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android 三方库源码解析系列（四）：Retrofit 原理及源码解析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-13 11:47:38" itemprop="dateCreated datePublished" datetime="2021-02-13T11:47:38+08:00">2021-02-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-24 17:56:38" itemprop="dateModified" datetime="2021-03-24T17:56:38+08:00">2021-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E3%80%8AAndroid-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%E3%80%8B/" itemprop="url" rel="index"><span itemprop="name">《Android 三方库源码解析系列》</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>43k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>40 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><a id="more"></a>

<ul>
<li><strong>Retrofit</strong>: A type-safe HTTP client for Android and Java.</li>
</ul>
<h3 id="二-Demo"><a href="#二-Demo" class="headerlink" title="二. Demo"></a>二. Demo</h3><ul>
<li><p>Demo</p>
<ul>
<li><p>引入 Retrofit</p>
  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">dependencies</span> &#123;</span><br><span class="line">    <span class="attribute">implementation</span> <span class="string">'com.squareup.retrofit2:retrofit:2.9.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发起一个网络请求</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"getUserData"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserData</span><span class="params">()</span></span>: Call&lt;ResponseBody&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">"https://mockapi.eolinker.com/9IiwI82f58c23411240ed608ceca204b2f185014507cbe3/"</span>)</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">val</span> service = retrofit.create(ApiService::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">    <span class="keyword">val</span> call: Call&lt;ResponseBody&gt; = service.getUserData()</span><br><span class="line">    call.enqueue(<span class="keyword">object</span> : Callback&lt;ResponseBody&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">ResponseBody</span>&gt;, response: <span class="type">Response</span>&lt;<span class="type">ResponseBody</span>&gt;)</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> userBean = response.body()?.string()</span><br><span class="line">            println(<span class="string">"userBean: <span class="variable">$userBean</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">ResponseBody</span>&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="string">"onFailure: <span class="variable">$t</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
  <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">userBean:</span> &#123;<span class="string">"userName"</span>:<span class="string">"JBl"</span>,<span class="string">"userAge"</span>:<span class="number">7816977017260632</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Retrofit 是建立在 OkHttp 之上的一个网络请求封装库，内部依靠 <strong>OkHttp</strong> 来完成实际的网络请求。Retrofit 在使用上很简洁，API 是通过 <strong>interface</strong> 来声明的，只需要通过 interface 来声明API 路径、请求方式、请求参数、返回值类型等各个配置项，然后调用方法就可以发起网络请求</p>
</li>
<li><p>从上述例子可以看到，<code>getUserData()</code> 方法所代表的 API 的请求结果是一个 Json 格式的字符串，其返回值类型被定义为 <code>Call&lt;ResponseBody&gt;</code>，此处的 <code>ResponseBody</code> 即 <code>okhttp3.ResponseBody</code>，是 OkHttp 提供的对网络请求结果的<strong>包装类</strong>，Call 即<code>retrofit2.Call</code>，是 Retrofit 对 <code>okhttp3.Call</code> 做的一层包装，OkHttp 在实际发起请求的时候使用的回调是 <code>okhttp3.Call</code>，回调内部就会来中转调用 <code>retrofit2.Call</code>，以便将请求结果转交给外部</p>
</li>
</ul>
<ol>
<li><p><strong>converter-gson</strong></p>
<ul>
<li><p>上述例子虽然简单，但还不够方便，因为既然 API 的返回值我们已知就是 Json 格式的了，那么我们自然就希望 <code>getUserData()</code> 方法的返回值直接就是一个 Bean 对象，而不是拿到一个 String 对象后还需要自己再去进行反序列化，这可以通过 <strong>converter-gson</strong> 这个库来达到这个效果</p>
  <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="keyword">implementation</span> <span class="string">'com.squareup.retrofit2:retrofit:2.9.0'</span></span><br><span class="line">    <span class="keyword">implementation</span> <span class="string">'com.squareup.retrofit2:converter-gson:2.5.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改代码，然后就可以直接在 Callback 中拿到 UserBean 对象了</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"getUserData"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserData</span><span class="params">()</span></span>: Call&lt;UserBean&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBean</span></span>(<span class="keyword">val</span> userName: String, <span class="keyword">val</span> userAge: <span class="built_in">Long</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">"https://mockapi.eolinker.com/9IiwI82f58c23411240ed608ceca204b2f185014507cbe3/"</span>)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">val</span> service = retrofit.create(ApiService::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">    <span class="keyword">val</span> call: Call&lt;UserBean&gt; = service.getUserData()</span><br><span class="line">    call.enqueue(<span class="keyword">object</span> : Callback&lt;UserBean&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">UserBean</span>&gt;, response: <span class="type">Response</span>&lt;<span class="type">UserBean</span>&gt;)</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> userBean = response.body()</span><br><span class="line">            println(<span class="string">"userBean: <span class="variable">$userBean</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">UserBean</span>&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="string">"onFailure: <span class="variable">$t</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>adapter-rxjava2</strong></p>
<ul>
<li><p>再然后，如果我们也看 <code>Call&lt;UserBean&gt;</code> 不爽，想要通过 RxJava 的方式来进行网络请求也是可以的，此时就需要再使用到 <strong>adapter-rxjava2</strong> 这个库了</p>
  <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="keyword">implementation</span> <span class="string">'com.squareup.retrofit2:retrofit:2.9.0'</span></span><br><span class="line">    <span class="keyword">implementation</span> <span class="string">'com.squareup.retrofit2:converter-gson:2.5.0'</span></span><br><span class="line">    <span class="keyword">implementation</span> <span class="string">'com.squareup.retrofit2:adapter-rxjava2:2.9.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改代码，此时就完全不用使用到 <code>Call.enqueue()</code> 来显式发起网络请求了，当进行 <code>subscribe()</code> 的时候就会触发网络请求</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"getUserData"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserData</span><span class="params">()</span></span>: Observable&lt;UserBean&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBean</span></span>(<span class="keyword">val</span> userName: String, <span class="keyword">val</span> userAge: <span class="built_in">Long</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">"https://mockapi.eolinker.com/9IiwI82f58c23411240ed608ceca204b2f185014507cbe3/"</span>)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">val</span> service = retrofit.create(ApiService::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">    <span class="keyword">val</span> call: Observable&lt;UserBean&gt; = service.getUserData()</span><br><span class="line">    call.subscribe(<span class="keyword">object</span> : Consumer&lt;UserBean&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">accept</span><span class="params">(userBean: <span class="type">UserBean</span>?)</span></span> &#123;</span><br><span class="line">            println(<span class="string">"userBean: <span class="variable">$userBean</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, <span class="keyword">object</span> : Consumer&lt;Throwable&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">accept</span><span class="params">(t: <span class="type">Throwable</span>?)</span></span> &#123;</span><br><span class="line">            println(<span class="string">"onFailure: <span class="variable">$t</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>三个问题</strong></p>
<ul>
<li><strong>优点</strong>：Retrofit 在抽象程度上是很高的。不管是需要 Call 类还是 Observable 类型的<strong>包装类</strong>，只需要添加不同的 <strong>CallAdapterFactory</strong> 即可，就算想返回 LiveData 类型都是可以实现的。也不管是需要 ResponseBody <strong>类型</strong>还是具体的 Bean 对象类型，也只需要添加不同的 <strong>ConverterFactory</strong> 即可，就算 API 的返回值是 XML 格式也可以进行映射解析</li>
<li><strong>问题</strong><ol>
<li><strong>问题一：Retrofit 是如何将 interface 内部的方法转化为一个个实际的 GET、POST、DELETE 等各式各样的网络请求？例如，Retrofit 是如何将 <code>getUserData()</code> 转换为一个 OkHttp 的 GET 请求？</strong></li>
<li><strong>问题二： Retrofit 是如何将 API 的返回值映射为具体的 Bean 对象？例如，ResponseBody 是如何映射为 UserBean？</strong></li>
<li><strong>问题三：Retrofit 是如何抽象不同的 API 返回值包装类？例如，Call 是如何替换为 Observable ？</strong></li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="三-Retrofit-create"><a href="#三-Retrofit-create" class="headerlink" title="三. Retrofit.create()"></a>三. Retrofit.create()</h3><ul>
<li><p><code>Retrofit.create()</code> 源码</p>
  <figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T create(<span class="keyword">final</span> <span class="class"><span class="keyword">Class</span>&lt;<span class="title">T</span>&gt; <span class="title">service</span>) &#123;</span></span><br><span class="line">    validateServiceInterface(service);</span><br><span class="line">    <span class="keyword">return</span> (T)</span><br><span class="line">        Proxy.newProxyInstance(</span><br><span class="line">            service.getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> <span class="class"><span class="keyword">Class</span>&lt;?&gt;[] &#123;<span class="title">service</span>&#125;,</span></span><br><span class="line">            <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">              <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">              <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">              @Override</span><br><span class="line">              <span class="keyword">public</span> @Nullable Object invoke(Object proxy, <span class="function"><span class="keyword">Method</span> <span class="title">method</span>, @<span class="title">Nullable</span> <span class="title">Object</span>[] <span class="title">args</span>)</span></span><br><span class="line">                  throws Throwable &#123;</span><br><span class="line">                // <span class="keyword">If</span> the <span class="function"><span class="keyword">method</span> <span class="title">is</span> <span class="title">a</span> <span class="title">method</span> <span class="title">from</span> <span class="title">Object</span> <span class="title">then</span> <span class="title">defer</span> <span class="title">to</span> <span class="title">normal</span> <span class="title">invocation</span>.</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="function"><span class="keyword">method</span>.<span class="title">getDeclaringClass</span>(</span>) == Object<span class="class">.<span class="keyword">class</span>) &#123;</span></span><br><span class="line">                //如果外部调用的是 Object 中声明的方法的话则直接调用</span><br><span class="line">                //例如 toString()、hashCode() 等方法</span><br><span class="line">                  <span class="keyword">return</span> <span class="function"><span class="keyword">method</span>.<span class="title">invoke</span>(</span>this, args);</span><br><span class="line">                &#125;</span><br><span class="line">                args = args != <span class="literal">null</span> ? args : emptyArgs;</span><br><span class="line">                //根据 <span class="function"><span class="keyword">method</span> 是否默认方法来决定如何调用</span></span><br><span class="line">                <span class="keyword">return</span> platform.isDefaultMethod(<span class="function"><span class="keyword">method</span>)</span></span><br><span class="line">                    ? platform.invokeDefaultMethod(<span class="function"><span class="keyword">method</span>, <span class="title">service</span>, <span class="title">proxy</span>, <span class="title">args</span>)</span></span><br><span class="line">                    : loadServiceMethod(<span class="function"><span class="keyword">method</span>).<span class="title">invoke</span>(</span>args);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的重点就是 <strong>Proxy.newProxyInstance</strong> 所实现的<strong>动态代理模式</strong>了。通过动态代理，Retrofit 会将我们对 ApiService 的调用操作转发给 <strong>InvocationHandler</strong> 来完成</li>
<li>Retrofit 在后续会通过<strong>反射</strong>拿到我们在声明 <code>getUserData()</code> 时标注的各个配置项，例如API 路径、请求方式、请求参数、返回值类型等各个信息，然后将这些配置项<strong>拼接</strong>为 OkHttp 的一个原始网络请求。当我们调用了 <code>call.enqueue()</code> 方法时，这个操作就会触发 InvocationHandler 去发起 OkHttp 网络请求了</li>
</ul>
</li>
<li><p>Retrofit 会根据 method 是否是默认方法来决定如何调用，这里主要看 <strong><code>loadServiceMethod(method)</code></strong> 方法，该方法的主要逻辑是</p>
<ol>
<li><p>将每个代表接口方法的 method 对象转换为 <strong>ServiceMethod</strong> 对象，该对象中就包含了 API 的具体信息</p>
</li>
<li><p>因为 API 可能先后会被调用多次，所以将构造出来的 ServiceMethod 对象缓存到 <strong>serviceMethodCache</strong> 中以实现复用 </p>
 <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;<span class="function"><span class="keyword">Method</span>, <span class="title">ServiceMethod</span>&lt;?&gt;&gt; <span class="title">serviceMethodCache</span> = <span class="title">new</span> <span class="title">ConcurrentHashMap</span>&lt;&gt;<span class="params">()</span>;</span>  </span><br><span class="line">		</span><br><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(<span class="function"><span class="keyword">Method</span> <span class="title">method</span>) <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span></span></span><br><span class="line"><span class="function"><span class="comment">  if (result != null) return result;</span></span></span><br><span class="line"><span class="function"><span class="comment">		</span></span></span><br><span class="line"><span class="function"><span class="comment">  synchronized (serviceMethodCache) &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    result = serviceMethodCache.get(method);</span></span></span><br><span class="line"><span class="function"><span class="comment">    if (result == null) &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">      //重点</span></span></span><br><span class="line"><span class="function"><span class="comment">      result = ServiceMethod.parseAnnotations(this, method);</span></span></span><br><span class="line"><span class="function"><span class="comment">      serviceMethodCache.put(method, result);</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">  <span class="title">return</span> <span class="title">result</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h3 id="四-ServiceMethod"><a href="#四-ServiceMethod" class="headerlink" title="四. ServiceMethod"></a>四. ServiceMethod</h3><ul>
<li><p>从上面可知，<code>loadServiceMethod(method)</code> 方法返回的是一个 ServiceMethod 对象，从名字上来看也可以猜出，每个 ServiceMethod 对象就对应一个 API 接口方法，其内部就包含了对 API 的解析结果。<code>loadServiceMethod(method).invoke(args)</code> 这个操作就对应<strong>调用 API 方法并传递参数</strong>这个过程，即对应 <code>val call: Call&lt;ResponseBody&gt; = service.getUserData()</code> 这个过程</p>
</li>
<li><p><strong>ServiceMethod 是一个抽象类</strong>，仅包含一个抽象的 <code>invoke(Object[] args)</code> 方法。ServiceMethod 使用到了<strong>工厂模式</strong>，由于 API 的最终请求方式可能是多样化的，既可能是通过线程池来执行，也可能是通过 Kotlin 协程来执行，使用工厂模式的意义就在于可以将这种差异都隐藏在不同的 ServiceMethod 实现类中，而外部统一都是通过 <code>parseAnnotations()</code> 方法来获取 ServiceMethod 的实现类</p>
</li>
<li><p><code>parseAnnotations()</code> 方法返回的 ServiceMethod 实际上是 <strong>HttpServiceMethod</strong>，所以重点就要来看 <code>HttpServiceMethod.parseAnnotations()</code> 方法返回的 HttpServiceMethod 具体是如何实现的，并是如何拼接出一个完整的 OkHttp 请求调用链</p>
  <figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMethod</span>&lt;<span class="title">T</span>&gt; &#123;</span></span><br><span class="line">  static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, <span class="function"><span class="keyword">Method</span> <span class="title">method</span>) &#123;</span></span><br><span class="line">    //requestFactory 包含了对 API 的注解信息进行解析后的结果</span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, <span class="function"><span class="keyword">method</span>);</span></span><br><span class="line"></span><br><span class="line">    Type returnType = <span class="function"><span class="keyword">method</span>.<span class="title">getGenericReturnType</span>(</span>);</span><br><span class="line">    //如果返回值包含未确定的泛型类型或者是包含通配符的话，那么就抛出异常</span><br><span class="line">    //因为 Retrofit 无法构造出一个不具有确定类型的对象作为返回值</span><br><span class="line">    <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(</span><br><span class="line">          <span class="function"><span class="keyword">method</span>,</span></span><br><span class="line">          <span class="string">"Method return type must not include a type variable or wildcard: %s"</span>,</span><br><span class="line">          returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    //返回值类型不能是 void</span><br><span class="line">    <span class="keyword">if</span> (returnType == void<span class="class">.<span class="keyword">class</span>) &#123;</span></span><br><span class="line">      <span class="keyword">throw</span> methodError(<span class="function"><span class="keyword">method</span>, "<span class="title">Service</span> <span class="title">methods</span> <span class="title">cannot</span> <span class="title">return</span> <span class="title">void</span>.");</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    //重点</span><br><span class="line">    <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, <span class="function"><span class="keyword">method</span>, <span class="title">requestFactory</span>);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> @Nullable T invoke(Object[] args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="五-HttpServiceMethod"><a href="#五-HttpServiceMethod" class="headerlink" title="五. HttpServiceMethod"></a>五. HttpServiceMethod</h3><ul>
<li><p>通过查找引用，可以知道 ServiceMethod 这个抽象类的直接子类只有一个，即 HttpServiceMethod。<strong>HttpServiceMethod 也是一个抽象类</strong>，其包含两个泛型声明：<strong>ResponseT 表示的是 API 方法返回值的外层包装类型，ReturnT 表示的是我们实际需要的数据类型</strong>。例如，对于 <code>fun getUserData(): Call&lt;UserBean&gt;</code> 方法，ResponseT 对应的是 Call，ReturnT 对应的是 UserBean</p>
</li>
<li><p>此外，HttpServiceMethod 也实现了父类的 <strong><code>invoke()</code></strong> 方法，并将操作转交给了另一个抽象方法 <strong><code>adapt()</code></strong> 来完成，所以说，API 方法对应的网络请求具体的发起操作主要看 <code>adapt()</code> 方法即可</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServiceMethod&lt;ResponseT</span>, <span class="title">ReturnT&gt;</span> <span class="keyword">extends</span> <span class="title">ServiceMethod&lt;ReturnT&gt;</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="type">ReturnT</span> invoke(<span class="type">Object</span>[] args) &#123;</span><br><span class="line">    <span class="type">Call</span>&lt;<span class="type">ResponseT</span>&gt; call = <span class="keyword">new</span> <span class="type">OkHttpCall</span>&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">    <span class="keyword">return</span> adapt(call, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="meta">@Nullable</span> <span class="type">ReturnT</span> adapt(<span class="type">Call</span>&lt;<span class="type">ResponseT</span>&gt; call, <span class="type">Object</span>[] args);</span><br><span class="line">    </span><br><span class="line">  ···</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再来看 <code>HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)</code> 方法是如何构建出一个 HttpServiceMethod 对象的，并且该对象的 <code>adapt()</code> 方法是如何实现的</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServiceMethod&lt;ResponseT</span>, <span class="title">ReturnT&gt;</span> <span class="keyword">extends</span> <span class="title">ServiceMethod&lt;ReturnT&gt;</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Inspects the annotations on an interface method to construct a reusable service method that</span></span><br><span class="line"><span class="comment">   * speaks HTTP. This requires potentially-expensive reflection so it is best to build each service</span></span><br><span class="line"><span class="comment">   * method only once and reuse it.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  static &lt;<span class="type">ResponseT</span>, <span class="type">ReturnT</span>&gt; <span class="type">HttpServiceMethod</span>&lt;<span class="type">ResponseT</span>, <span class="type">ReturnT</span>&gt; parseAnnotations(</span><br><span class="line">      <span class="type">Retrofit</span> retrofit, <span class="type">Method</span> method, <span class="type">RequestFactory</span> requestFactory) &#123;</span><br><span class="line">    <span class="comment">//是否是 Suspend 函数，即是否以 Kotlin 协程的方式来进行请求</span></span><br><span class="line">    boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;</span><br><span class="line">    boolean continuationWantsResponse = <span class="literal">false</span>;</span><br><span class="line">    boolean continuationBodyNullable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Annotation</span>[] annotations = method.getAnnotations();</span><br><span class="line">    <span class="type">Type</span> adapterType;</span><br><span class="line">    <span class="keyword">if</span> (isKotlinSuspendFunction) &#123;</span><br><span class="line">        <span class="comment">//省略 Kotlin 协程的一些处理逻辑</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      adapterType = method.getGenericReturnType();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//重点1</span></span><br><span class="line">    <span class="type">CallAdapter</span>&lt;<span class="type">ResponseT</span>, <span class="type">ReturnT</span>&gt; callAdapter =</span><br><span class="line">        createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//拿到包装类内部的具体类型，例如，Observable&lt;UserBean&gt; 内部的 UserBean</span></span><br><span class="line">    <span class="comment">//responseType 不能是 okhttp3.Response 或者是不包含具体泛型类型的 Response</span></span><br><span class="line">    <span class="type">Type</span> responseType = callAdapter.responseType();</span><br><span class="line">    <span class="keyword">if</span> (responseType == okhttp3.<span class="type">Response</span><span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(</span><br><span class="line">          method,</span><br><span class="line">          <span class="string">"'"</span></span><br><span class="line">              + getRawType(responseType).getName()</span><br><span class="line">              + <span class="string">"' is not a valid response body type. Did you mean ResponseBody?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (responseType == <span class="type">Response</span><span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(method, <span class="string">"Response must include generic type (e.g., Response&lt;String&gt;)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO support Unit for Kotlin?</span></span><br><span class="line">    <span class="keyword">if</span> (requestFactory.httpMethod.equals(<span class="string">"HEAD"</span>) &amp;&amp; !<span class="type">Void</span><span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="params">responseType</span>)) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(method, <span class="string">"HEAD method must use Void as response type."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//重点2</span></span><br><span class="line">    <span class="type">Converter</span>&lt;<span class="type">ResponseBody</span>, <span class="type">ResponseT</span>&gt; responseConverter =</span><br><span class="line">        createResponseConverter(retrofit, method, responseType);</span><br><span class="line"></span><br><span class="line">    okhttp3.<span class="type">Call</span>.<span class="type">Factory</span> callFactory = retrofit.callFactory;</span><br><span class="line">    <span class="keyword">if</span> (!isKotlinSuspendFunction) &#123;</span><br><span class="line">      <span class="comment">//重点3</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">CallAdapted</span>&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略 Kotlin 协程的一些处理逻辑</span></span><br><span class="line">	···</span><br><span class="line">        </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ···</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Retrofit 目前已经支持以 Kotlin 协程的方式来进行调用了，但本例子和协程无关，所以此处先忽略协程相关的处理逻辑，后面会再讲解，<strong><code>parseAnnotations()</code></strong> 方法的主要逻辑是：</p>
<ol>
<li>先通过 <code>createCallAdapter(retrofit, method, adapterType, annotations)</code> 方法拿到 CallAdapter 对象，CallAdapter 就用于实现 API 方法的不同返回值包装类处理逻辑。例如，<code>getUserData()</code> 方法的返回值包装类类型如果是 Call ，那么返回的 CallAdapter 对象就对应 DefaultCallAdapterFactory 包含的 Adapter；如果是 Observable，那么返回的就是 RxJava2CallAdapterFactory 包含的 Adapter</li>
<li>再通过 <code>createResponseConverter(retrofit, method, responseType)</code> 方法拿到 Converter 对象，Converter 就用于实现 API 方法的不同返回值处理逻辑。例如，<code>getUserData()</code> 方法的目标返回值类型如果是 ResponseBody ，那么 Converter 对象就对应 BuiltInConverters；如果是 UserBean，那么就对应 GsonConverterFactory</li>
<li>根据前两个步骤拿到的值，构造出一个 CallAdapted 对象并返回</li>
</ol>
</li>
<li><p>CallAdapted 正是 HttpServiceMethod 的子类，在 InvocationHandler 中通过 <code>loadServiceMethod(method).invoke(args)</code> 发起的调用链，会先创建出一个 OkHttpCall 对象，并最后调用到 <code>callAdapter.adapt(call)</code> 方法</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServiceMethod&lt;ResponseT</span>, <span class="title">ReturnT&gt;</span> <span class="keyword">extends</span> <span class="title">ServiceMethod&lt;ReturnT&gt;</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  	<span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="type">ReturnT</span> invoke(<span class="type">Object</span>[] args) &#123;</span><br><span class="line">    	<span class="type">Call</span>&lt;<span class="type">ResponseT</span>&gt; call = <span class="keyword">new</span> <span class="type">OkHttpCall</span>&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">    	<span class="keyword">return</span> adapt(call, args);</span><br><span class="line">  	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallAdapted&lt;ResponseT</span>, <span class="title">ReturnT&gt;</span> <span class="keyword">extends</span> <span class="title">HttpServiceMethod&lt;ResponseT</span>, <span class="title">ReturnT&gt;</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">CallAdapter</span>&lt;<span class="type">ResponseT</span>, <span class="type">ReturnT</span>&gt; callAdapter;</span><br><span class="line"></span><br><span class="line">    <span class="type">CallAdapted</span>(</span><br><span class="line">        <span class="type">RequestFactory</span> requestFactory,</span><br><span class="line">        okhttp3.<span class="type">Call</span>.<span class="type">Factory</span> callFactory,</span><br><span class="line">        <span class="type">Converter</span>&lt;<span class="type">ResponseBody</span>, <span class="type">ResponseT</span>&gt; responseConverter,</span><br><span class="line">        <span class="type">CallAdapter</span>&lt;<span class="type">ResponseT</span>, <span class="type">ReturnT</span>&gt; callAdapter) &#123;</span><br><span class="line">      <span class="keyword">super</span>(requestFactory, callFactory, responseConverter);</span><br><span class="line">      <span class="keyword">this</span>.callAdapter = callAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">ReturnT</span> adapt(<span class="type">Call</span>&lt;<span class="type">ResponseT</span>&gt; call, <span class="type">Object</span>[] args) &#123;</span><br><span class="line">      <span class="keyword">return</span> callAdapter.adapt(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="六-OkHttpCall"><a href="#六-OkHttpCall" class="headerlink" title="六. OkHttpCall"></a>六. OkHttpCall</h3><ul>
<li><p><strong>OkHttpCall 是实际发起 OkHttp 请求的地方</strong>。当我们调用 <code>fun getUserData(): Call&lt;ResponseBody&gt;</code> 方法时，返回的 Call 对象实际上是 OkHttpCall 类型，而当我们调用 <code>call.enqueue(Callback)</code> 方法时，<code>enqueue()</code> 方法中会发起一个 OkHttp 请求，传入的 Callback 对象就会由 <code>okhttp3.Callback</code> 本身收到回调时再进行中转调用</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RequestFactory requestFactory;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object[] args;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;ResponseBody, T&gt; responseConverter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call rawCall;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="comment">// Either a RuntimeException, non-fatal Error, or IOException.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> Throwable creationFailure;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> executed;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123; </span><br><span class="line">    ···</span><br><span class="line">    okhttp3.Call call;</span><br><span class="line">    ··· </span><br><span class="line">    call.enqueue( <span class="keyword">new</span> okhttp3.Callback() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>&#123;</span><br><span class="line">            Response&lt;T&gt; response;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              response = parseResponse(rawResponse);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">              throwIfFatal(e);</span><br><span class="line">              callFailure(e);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              callback.onResponse(OkHttpCall.<span class="keyword">this</span>, response);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">              throwIfFatal(t);</span><br><span class="line">              t.printStackTrace(); <span class="comment">// TODO this is not great</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> </span>&#123;</span><br><span class="line">            callFailure(e);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callFailure</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              callback.onFailure(OkHttpCall.<span class="keyword">this</span>, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">              throwIfFatal(t);</span><br><span class="line">              t.printStackTrace(); <span class="comment">// TODO this is not great</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="七-总结"><a href="#七-总结" class="headerlink" title="七. 总结"></a>七. 总结</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"getUserData"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserData</span><span class="params">()</span></span>: Call&lt;ResponseBody&gt;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">"https://mockapi.eolinker.com/9IiwI82f58c23411240ed608ceca204b2f185014507cbe3/"</span>)</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">val</span> service = retrofit.create(ApiService::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">    <span class="keyword">val</span> call: Call&lt;ResponseBody&gt; = service.getUserData()</span><br><span class="line">    call.enqueue(<span class="keyword">object</span> : Callback&lt;ResponseBody&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">ResponseBody</span>&gt;, response: <span class="type">Response</span>&lt;<span class="type">ResponseBody</span>&gt;)</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> userBean = response.body()?.string()</span><br><span class="line">            println(<span class="string">"userBean: <span class="variable">$userBean</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">ResponseBody</span>&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="string">"onFailure: <span class="variable">$t</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先，我们通过 <code>retrofit.create(ApiService::class.java)</code> 得到一个 ApiService 的<strong>动态实现类</strong>，这是通过 <strong>Java 原生提供的Proxy.newProxyInstance</strong> 代表的<strong>动态代理</strong>功能来实现的。在拿到 ApiService 的实现类后，我们就可以直接调用 ApiService 中声明的所有方法了</p>
</li>
<li><p>当我们调用了 <code>service.getUserData()</code> 方法时，Retrofit 会将每一个 API 方法都抽象封装为一个 ServiceMethod 对象并缓存起来，我们的操作会转交给 <strong>ServiceMethod</strong> 来完成，由 ServiceMethod 来负责返回我们的目标类型，对应的是 <code>ServiceMethod.invoke(Object[] args)</code> 方法，args 代表的是我们调用 API 方法时需要传递的参数，对应本例子就是一个空数组</p>
  <figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMethod</span>&lt;<span class="title">T</span>&gt; &#123;</span></span><br><span class="line">  static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, <span class="function"><span class="keyword">Method</span> <span class="title">method</span>) &#123;</span></span><br><span class="line">    //requestFactory 包含了对 API 的注解信息进行解析后的结果</span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, <span class="function"><span class="keyword">method</span>);</span></span><br><span class="line"></span><br><span class="line">    Type returnType = <span class="function"><span class="keyword">method</span>.<span class="title">getGenericReturnType</span>(</span>);</span><br><span class="line">    //如果返回值包含未确定的泛型类型或者是包含通配符的话，那么就抛出异常</span><br><span class="line">    //因为 Retrofit 无法构造出一个不具有确定类型的对象作为返回值</span><br><span class="line">    <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(</span><br><span class="line">          <span class="function"><span class="keyword">method</span>,</span></span><br><span class="line">          <span class="string">"Method return type must not include a type variable or wildcard: %s"</span>,</span><br><span class="line">          returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    //返回值类型不能是 void</span><br><span class="line">    <span class="keyword">if</span> (returnType == void<span class="class">.<span class="keyword">class</span>) &#123;</span></span><br><span class="line">      <span class="keyword">throw</span> methodError(<span class="function"><span class="keyword">method</span>, "<span class="title">Service</span> <span class="title">methods</span> <span class="title">cannot</span> <span class="title">return</span> <span class="title">void</span>.");</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    //重点</span><br><span class="line">    <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, <span class="function"><span class="keyword">method</span>, <span class="title">requestFactory</span>);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> @Nullable T invoke(Object[] args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实际上，ServiceMethod 只具有一个唯一的直接子类，即 <strong>HttpServiceMethod</strong>，而 HttpServiceMethod 会在 <code>invoke()</code> 方法中构建出一个 OkHttpCall 对象，然后调用其抽象方法 <code>adapt()</code></p>
</li>
<li><p>此外，对于不同的请求方式，<code>ServiceMethod.parseAnnotations()</code> 方法最终会返回不同的 HttpServiceMethod 子类。对应本例子，最终返回的会是 CallAdapted 对象</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServiceMethod&lt;ResponseT</span>, <span class="title">ReturnT&gt;</span> <span class="keyword">extends</span> <span class="title">ServiceMethod&lt;ReturnT&gt;</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="type">ReturnT</span> invoke(<span class="type">Object</span>[] args) &#123;</span><br><span class="line">    <span class="type">Call</span>&lt;<span class="type">ResponseT</span>&gt; call = <span class="keyword">new</span> <span class="type">OkHttpCall</span>&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">    <span class="keyword">return</span> adapt(call, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="meta">@Nullable</span> <span class="type">ReturnT</span> adapt(<span class="type">Call</span>&lt;<span class="type">ResponseT</span>&gt; call, <span class="type">Object</span>[] args);</span><br><span class="line">    </span><br><span class="line">  ···</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallAdapted&lt;ResponseT</span>, <span class="title">ReturnT&gt;</span> <span class="keyword">extends</span> <span class="title">HttpServiceMethod&lt;ResponseT</span>, <span class="title">ReturnT&gt;</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">CallAdapter</span>&lt;<span class="type">ResponseT</span>, <span class="type">ReturnT</span>&gt; callAdapter;</span><br><span class="line"></span><br><span class="line">    <span class="type">CallAdapted</span>(</span><br><span class="line">        <span class="type">RequestFactory</span> requestFactory,</span><br><span class="line">        okhttp3.<span class="type">Call</span>.<span class="type">Factory</span> callFactory,</span><br><span class="line">        <span class="type">Converter</span>&lt;<span class="type">ResponseBody</span>, <span class="type">ResponseT</span>&gt; responseConverter,</span><br><span class="line">        <span class="type">CallAdapter</span>&lt;<span class="type">ResponseT</span>, <span class="type">ReturnT</span>&gt; callAdapter) &#123;</span><br><span class="line">      <span class="keyword">super</span>(requestFactory, callFactory, responseConverter);</span><br><span class="line">      <span class="keyword">this</span>.callAdapter = callAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">ReturnT</span> adapt(<span class="type">Call</span>&lt;<span class="type">ResponseT</span>&gt; call, <span class="type">Object</span>[] args) &#123;</span><br><span class="line">      <span class="keyword">return</span> callAdapter.adapt(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>所以，当我们调用 <code>val call: Call&lt;ResponseBody&gt; = service.getUserData()</code> 时，返回的 <code>Call&lt;ResponseBody&gt;</code> 实际上是 <code>OkHttpCall&lt;ResponseBody&gt;</code></p>
</li>
<li><p>当我们调用 <code>call.enqueue()</code> 方法时，OkHttpCall 的 <code>enqueue()</code> 方法内部就会发起一个 OkHttp 请求，并为这个请求设置一个回调对象 <code>okhttp3.Callback</code>，然后在这个回调中再来回调我们传递进去的 <code>retrofit2.Callback</code>。这样，外部也就可以收到网络请求成功或者失败的事件回调了</p>
  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">final <span class="keyword">class</span> OkHttpCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void enqueue(final Callback&lt;T&gt; callback) &#123; </span><br><span class="line">    ···</span><br><span class="line">    okhttp3.Call call;</span><br><span class="line">    ··· </span><br><span class="line">    call.enqueue( <span class="keyword">new</span> okhttp3.<span class="constructor">Callback()</span> &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void on<span class="constructor">Response(<span class="params">okhttp3</span>.Call <span class="params">call</span>, <span class="params">okhttp3</span>.Response <span class="params">rawResponse</span>)</span> &#123;</span><br><span class="line">            Response&lt;T&gt; response;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              response = parse<span class="constructor">Response(<span class="params">rawResponse</span>)</span>;</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">              throw<span class="constructor">IfFatal(<span class="params">e</span>)</span>;</span><br><span class="line">              call<span class="constructor">Failure(<span class="params">e</span>)</span>;</span><br><span class="line">              return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              callback.on<span class="constructor">Response(OkHttpCall.<span class="params">this</span>, <span class="params">response</span>)</span>;</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">              throw<span class="constructor">IfFatal(<span class="params">t</span>)</span>;</span><br><span class="line">              t.print<span class="constructor">StackTrace()</span>; <span class="comment">// TODO this is not great</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          public void on<span class="constructor">Failure(<span class="params">okhttp3</span>.Call <span class="params">call</span>, IOException <span class="params">e</span>)</span> &#123;</span><br><span class="line">            call<span class="constructor">Failure(<span class="params">e</span>)</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">private</span> void call<span class="constructor">Failure(Throwable <span class="params">e</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              callback.on<span class="constructor">Failure(OkHttpCall.<span class="params">this</span>, <span class="params">e</span>)</span>;</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">              throw<span class="constructor">IfFatal(<span class="params">t</span>)</span>;</span><br><span class="line">              t.print<span class="constructor">StackTrace()</span>; <span class="comment">// TODO this is not great</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="八-API-方法是如何解析的"><a href="#八-API-方法是如何解析的" class="headerlink" title="八. API 方法是如何解析的"></a>八. API 方法是如何解析的</h3><ul>
<li><p><strong>问题一：Retrofit 是如何将 interface 内部的方法转化为一个个实际的 GET、POST、DELETE 等各式各样的网络请求的？例如，Retrofit 是如何将 getUserData() 转换为一个 OkHttp 的 GET 请求的？</strong></p>
</li>
<li><p>这个过程在 ServiceMethod 的 <code>parseAnnotations()</code> 方法中就已经完成的了，对应的是 <strong><code>RequestFactory.parseAnnotations(retrofit, method)</code></strong> 方法</p>
  <figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMethod</span>&lt;<span class="title">T</span>&gt; &#123;</span></span><br><span class="line">  static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, <span class="function"><span class="keyword">Method</span> <span class="title">method</span>) &#123;</span></span><br><span class="line">    //重点</span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, <span class="function"><span class="keyword">method</span>);</span></span><br><span class="line"></span><br><span class="line">    Type returnType = <span class="function"><span class="keyword">method</span>.<span class="title">getGenericReturnType</span>(</span>);</span><br><span class="line">    <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(</span><br><span class="line">          <span class="function"><span class="keyword">method</span>,</span></span><br><span class="line">          <span class="string">"Method return type must not include a type variable or wildcard: %s"</span>,</span><br><span class="line">          returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (returnType == void<span class="class">.<span class="keyword">class</span>) &#123;</span></span><br><span class="line">      <span class="keyword">throw</span> methodError(<span class="function"><span class="keyword">method</span>, "<span class="title">Service</span> <span class="title">methods</span> <span class="title">cannot</span> <span class="title">return</span> <span class="title">void</span>.");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, <span class="function"><span class="keyword">method</span>, <span class="title">requestFactory</span>);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> @Nullable T invoke(Object[] args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>前文说了，Retrofit 是建立在 OkHttp 之上的一个网络请求封装库，内部依靠 OkHttp 来完成实际的网络请求。而 OkHttp 的一般请求方式如下所示</p>
  <figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> run(<span class="built_in">String</span> url) throws IOException &#123;</span><br><span class="line">  <span class="built_in">Request</span> <span class="built_in">request</span> = <span class="keyword">new</span> <span class="built_in">Request</span>.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  try (<span class="built_in">Response</span> <span class="built_in">response</span> = client.newCall(<span class="built_in">request</span>).<span class="keyword">execute</span>()) &#123;</span><br><span class="line">    return <span class="built_in">response</span>.body().<span class="built_in">string</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OkHttp 需要构建一个 Request 对象来配置请求方式和请求参数，并以此来发起网络请求。所以，Retrofit 也需要一个构建 Request 对象的过程，这个过程就隐藏在 RequestFactory 中</p>
</li>
<li><p><strong>RequestFactory 采用了 Builder 模式</strong>，这里无需过多理会其构建过程，我们只要知道 RequestFactory 中包含了对 API 方法的各项解析结果即可。其 <code>create(Object[] args)</code> 方法就会根据各项解析结果，最终返回一个 <code>okhttp3.Request</code> 对象</p>
  <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> RequestFactory <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  static RequestFactory parseAnnotations(Retrofit retrofit, Method method) &#123;</span></span><br><span class="line"><span class="comment">    return new Builder(retrofit, method).build();</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="function"><span class="keyword">Method</span> <span class="title">method</span>;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HttpUrl baseUrl;</span><br><span class="line">  <span class="keyword">final</span> String httpMethod;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> @<span class="keyword">Nullable</span> String relativeUrl;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> @<span class="keyword">Nullable</span> Headers headers;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> @<span class="keyword">Nullable</span> MediaType contentType;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> boolean hasBody;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> boolean isFormEncoded;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> boolean isMultipart;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ParameterHandler&lt;?&gt;[] parameterHandlers;</span><br><span class="line">  <span class="keyword">final</span> boolean isKotlinSuspendFunction;</span><br><span class="line"></span><br><span class="line">  okhttp3.Request <span class="keyword">create</span>(Object[] args) throws IOException <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    @SuppressWarnings("unchecked") // It is an error to invoke a method with the wrong arg types.</span></span><br><span class="line"><span class="comment">    ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int argumentCount = args.length;</span></span><br><span class="line"><span class="comment">    if (argumentCount != handlers.length) &#123;</span></span><br><span class="line"><span class="comment">      throw new IllegalArgumentException(</span></span><br><span class="line"><span class="comment">          "Argument count ("</span></span><br><span class="line"><span class="comment">              + argumentCount</span></span><br><span class="line"><span class="comment">              + ") doesn't match expected count ("</span></span><br><span class="line"><span class="comment">              + handlers.length</span></span><br><span class="line"><span class="comment">              + ")");</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"></span><br><span class="line">    RequestBuilder requestBuilder =</span><br><span class="line">        <span class="keyword">new</span> RequestBuilder(</span><br><span class="line">            httpMethod,</span><br><span class="line">            baseUrl,</span><br><span class="line">            relativeUrl,</span><br><span class="line">            headers,</span><br><span class="line">            contentType,</span><br><span class="line">            hasBody,</span><br><span class="line">            isFormEncoded,</span><br><span class="line">            isMultipart);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isKotlinSuspendFunction) <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">      // The Continuation is the last parameter and the handlers array contains null at that index.</span></span><br><span class="line"><span class="comment">      argumentCount--;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; argumentList = <span class="keyword">new</span> ArrayList&lt;&gt;(argumentCount);</span><br><span class="line">    <span class="keyword">for</span> (int p = <span class="number">0</span>; p &lt; argumentCount; p++) <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">      argumentList.add(args[p]);</span></span><br><span class="line"><span class="comment">      handlers[p].apply(requestBuilder, args[p]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"></span><br><span class="line">    return requestBuilder.get().tag(Invocation.class, <span class="keyword">new</span> Invocation(<span class="function"><span class="keyword">method</span>, <span class="title">argumentList</span>)).<span class="title">build</span><span class="params">()</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OkHttpCall 是实际上发起网络请求的地方，所以最终 RequestFactory 的 <code>create()</code> 方法会由 OkHttpCall 的 <code>createRawCall()</code> 方法来调用</p>
  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> OkHttpCall&lt;T&gt; <span class="keyword">implements</span> <span class="keyword">Call</span>&lt;T&gt; &#123;</span><br><span class="line">     </span><br><span class="line">  	<span class="keyword">private</span> okhttp3.<span class="keyword">Call</span> createRawCall() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    	okhttp3.<span class="keyword">Call</span> <span class="keyword">call</span> = callFactory.newCall(requestFactory.create(args));</span><br><span class="line">    	<span class="keyword">if</span> (<span class="keyword">call</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">      		<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Call.Factory returned null."</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">call</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="九-ResponseBody-是如何映射为-UserBean-的"><a href="#九-ResponseBody-是如何映射为-UserBean-的" class="headerlink" title="九. ResponseBody 是如何映射为 UserBean 的"></a>九. ResponseBody 是如何映射为 UserBean 的</h3><ul>
<li><p><strong>问题二：Retrofit 是如何将 API 的返回值映射为具体的 Bean 对象的？例如，ResponseBody 是如何映射为 UserBean 的？</strong></p>
</li>
<li><p>OkHttp 默认的接口返回值对象就是 ResponseBody，所以在使用 Retrofit  时如果不引入 <strong>converter-gson</strong>，我们只能将接口请求结果都定义为 ResponseBody，而不能是具体的 Bean 对象，因为 Retrofit 无法自动地完成 ResponseBody 到 UserBean 之间的转换操作，需要我们将这种<strong>转换规则</strong>告知 Retrofit</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"getUserData"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserData1</span><span class="params">()</span></span>: Call&lt;ResponseBody&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"getUserData"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserData2</span><span class="params">()</span></span>: Call&lt;UserBean&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这种转换规则被 Retrofit 定义为 <strong>Converter</strong> 接口，对应它的 <code>responseBodyConverter()</code> 方法</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">T <span class="title">convert</span><span class="params">(F value)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//将 ResponseBody 转换为目标类型 type</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(</span><br><span class="line">        Type type, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了能直接获取到 UserBean 对象，我们需要在构建 Retrofit 对象的时候添加 <strong>GsonConverterFactory</strong></p>
  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> retrofit = Retrofit.<span class="constructor">Builder()</span></span><br><span class="line">    .base<span class="constructor">Url(<span class="string">"https://mockapi.eolinker.com/9IiwI82f58c23411240ed608ceca204b2f185014507cbe3/"</span>)</span></span><br><span class="line">    .add<span class="constructor">ConverterFactory(GsonConverterFactory.<span class="params">create</span>()</span>)</span><br><span class="line">    .build<span class="literal">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>GsonConverterFactory 会根据目标类型 type，通过 Gson 来进行<strong>反序列化</strong>出 UserBean 对象</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonConverterFactory</span> <span class="keyword">extends</span> <span class="title">Converter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  public <span class="type">Converter</span>&lt;<span class="type">ResponseBody</span>, ?&gt; responseBodyConverter(<span class="type">Type</span> <span class="class"><span class="keyword">type</span>, <span class="title">Annotation</span>[] <span class="title">annotations</span>,</span></span><br><span class="line"><span class="class">      <span class="title">Retrofit</span> <span class="title">retrofit</span>) </span>&#123;</span><br><span class="line">    <span class="type">TypeAdapter</span>&lt;?&gt; adapter = gson.getAdapter(<span class="type">TypeToken</span>.get(<span class="class"><span class="keyword">type</span>))</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">GsonResponseBodyConverter</span>&lt;&gt;(gson, adapter);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  ···</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonResponseBodyConverter&lt;T&gt;</span> <span class="title">implements</span> <span class="title">Converter&lt;ResponseBody</span>, <span class="title">T&gt;</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Gson</span> gson;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">TypeAdapter</span>&lt;<span class="type">T</span>&gt; adapter;</span><br><span class="line"></span><br><span class="line">  <span class="type">GsonResponseBodyConverter</span>(<span class="type">Gson</span> gson, <span class="type">TypeAdapter</span>&lt;<span class="type">T</span>&gt; adapter) &#123;</span><br><span class="line">    <span class="keyword">this</span>.gson = gson;</span><br><span class="line">    <span class="keyword">this</span>.adapter = adapter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> public <span class="type">T</span> convert(<span class="type">ResponseBody</span> value) <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</span><br><span class="line">    <span class="type">JsonReader</span> jsonReader = gson.newJsonReader(value.charStream());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">T</span> result = adapter.read(jsonReader);</span><br><span class="line">      <span class="keyword">if</span> (jsonReader.peek() != <span class="type">JsonToken</span>.<span class="type">END_DOCUMENT</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">JsonIOException</span>(<span class="string">"JSON document was not fully consumed."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      value.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>问题又来了，<strong>Retrofit 是如何知道什么类型才可以交由 GsonConverterFactory 来进行处理的？至少 ResponseBody 就不应该交由 GsonConverterFactory 来处理，Retrofit 如何进行选择？</strong></p>
</li>
<li><p>首先，当我们在构建 Retrofit 对象时传入了 GsonConverterFactory，最终 Retrofit 会对所有 Converter.Factory 进行排序，<strong><code>converterFactories()</code> 中 BuiltInConverters 会被默认排在第一位</strong>，BuiltInConverters 是 Retrofit 自带的对 ResponseBody 进行默认解析的 Converter.Factory 实现类</p>
  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Retrofit</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> &#123;</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      ···</span><br><span class="line">              </span><br><span class="line">      <span class="comment">// Make a defensive copy of the converters.</span></span><br><span class="line">      List&lt;Converter.Factory&gt; converterFactories =</span><br><span class="line">          <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">              <span class="number">1</span> + <span class="keyword">this</span>.converterFactories.<span class="built_in">size</span>() + platform.defaultConverterFactoriesSize());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">      <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">      converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">      converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line">      converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>而 BuiltInConverters 的 <code>responseBodyConverter()</code> 方法在目标类型并非 ResponseBody、Void、Unit 等三种类型的情况下会返回 null</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BuiltInConverters</span> <span class="keyword">extends</span> <span class="title">Converter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  public <span class="meta">@Nullable</span> <span class="type">Converter</span>&lt;<span class="type">ResponseBody</span>, ?&gt; responseBodyConverter(</span><br><span class="line">      <span class="type">Type</span> <span class="class"><span class="keyword">type</span>, <span class="title">Annotation</span>[] <span class="title">annotations</span>, <span class="title">Retrofit</span> <span class="title">retrofit</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="class"><span class="keyword">type</span> <span class="title">==</span> <span class="title">ResponseBody</span>.<span class="title">class</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">Utils</span>.isAnnotationPresent(annotations, <span class="type">Streaming</span><span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">          <span class="title">?</span> <span class="title">StreamingResponseBodyConverter</span>.<span class="title">INSTANCE</span></span></span><br><span class="line"><span class="class">          </span>: <span class="type">BufferingResponseBodyConverter</span>.<span class="type">INSTANCE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="class"><span class="keyword">type</span> <span class="title">==</span> <span class="title">Void</span>.<span class="title">class</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">VoidResponseBodyConverter</span>.<span class="type">INSTANCE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checkForKotlinUnit) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="class"><span class="keyword">type</span> <span class="title">==</span> <span class="title">Unit</span>.<span class="title">class</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="type">UnitResponseBodyConverter</span>.<span class="type">INSTANCE</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (<span class="type">NoClassDefFoundError</span> ignored) &#123;</span><br><span class="line">        checkForKotlinUnit = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>而 Retrofit 类的 <code>nextResponseBodyConverter()</code> 方法就是为每一个 API 方法选择 Converter 进行返回值数据类型转换的方法。该方法会先遍历到 BuiltInConverters，发现其返回了 null，就会最终选择到 <strong>GsonResponseBodyConverter</strong>，从而完成数据解析。如果最终没有找到一个合适的处理器的话，就会抛出 <code>IllegalArgumentException</code></p>
  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(</span><br><span class="line">      @Nullable Converter.Factory skipPast, <span class="keyword">Type</span> <span class="keyword">type</span>, Annotation[] annotations) &#123;</span><br><span class="line">    Objects.requireNonNull(<span class="keyword">type</span>, "type == null");</span><br><span class="line">    Objects.requireNonNull(annotations, "annotations == null");</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start = converterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="keyword">start</span>, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">      Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">          converterFactories.<span class="keyword">get</span>(i).responseBodyConverter(<span class="keyword">type</span>, annotations, this);</span><br><span class="line">      <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        //noinspection unchecked</span><br><span class="line">        <span class="keyword">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	···</span><br><span class="line">    throw <span class="built_in">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="十-Call-是如何替换为-Observable-的"><a href="#十-Call-是如何替换为-Observable-的" class="headerlink" title="十. Call 是如何替换为 Observable 的"></a>十. Call 是如何替换为 Observable 的</h3><ul>
<li><p><strong>问题三：Retrofit 是如何抽象不同的 API 返回值包装类的？例如，Call 是如何替换为 Observable 的？</strong></p>
</li>
<li><p>Retrofit 在默认情况下也只支持将 <code>retrofit2.Call</code> 作为 API 接口的返回数据类型包装类，为了支持返回 Observable 类型，我们需要在构建 Retrofit 的时候添加 <strong>RxJava2CallAdapterFactory</strong></p>
  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> retrofit = Retrofit.<span class="constructor">Builder()</span></span><br><span class="line">    .base<span class="constructor">Url(<span class="string">"https://mockapi.eolinker.com/9IiwI82f58c23411240ed608ceca204b2f185014507cbe3/"</span>)</span></span><br><span class="line">    .add<span class="constructor">ConverterFactory(GsonConverterFactory.<span class="params">create</span>()</span>)</span><br><span class="line">    .add<span class="constructor">CallAdapterFactory(RxJava2CallAdapterFactory.<span class="params">create</span>()</span>)</span><br><span class="line">    .build<span class="literal">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Retrofit 将 <code>retrofit2.Call</code> 转换为 Observable 的这种规则抽象为了 <strong>CallAdapter</strong> 接口</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallAdapter</span>&lt;<span class="title">R</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回具体的内部类型，即 UserBean</span></span><br><span class="line">  <span class="function">Type <span class="title">responseType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//用于将 Call 转换为 Observable</span></span><br><span class="line">  <span class="function">T <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于提供将 Call&lt;UserBean&gt; 转换为 Observable&lt;UserBean&gt; 的 CallAdapter 对象</span></span><br><span class="line">    <span class="comment">//此处的 returnType 即 Observable&lt;UserBean&gt;</span></span><br><span class="line">    <span class="comment">//如果此 CallAdapter 无法完成这种数据类型的转换，那么就返回 null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">        Type returnType, Annotation[] annotations, Retrofit retrofit);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于 RxJava2CallAdapterFactory 的 <code>get()</code> 方法而言，如果返回值类型并非 Completable、Flowable、Single、Maybe 等类型的话就会返回 null，否则就返回 <strong>RxJava2CallAdapter</strong> 对象</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RxJava2CallAdapterFactory</span> <span class="title">extends</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; <span class="keyword">get</span>(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    </span><br><span class="line">        Class&lt;?&gt; rawType = getRawType(returnType);</span><br><span class="line">    	<span class="keyword">if</span> (rawType == Completable<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      		<span class="comment">// Completable is not parameterized (which is what the rest of this method deals with) so it</span></span><br><span class="line">      		<span class="comment">// can only be created with a single configuration.</span></span><br><span class="line">      		<span class="keyword">return</span> new RxJava2CallAdapter(</span><br><span class="line">          	<span class="built_in">Void</span><span class="class">.<span class="keyword">class</span>, <span class="type">scheduler</span>, <span class="type">isAsync</span>, <span class="type">false</span>, <span class="type">true</span>, <span class="type">false</span>, <span class="type">false</span>, <span class="type">false</span>, <span class="type">true);</span></span></span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	boolean isFlowable = rawType == Flowable<span class="class">.<span class="keyword">class</span>;</span></span><br><span class="line">    	boolean isSingle = rawType == Single<span class="class">.<span class="keyword">class</span>;</span></span><br><span class="line">    	boolean isMaybe = rawType == Maybe<span class="class">.<span class="keyword">class</span>;</span></span><br><span class="line">    	<span class="keyword">if</span> (rawType != Observable<span class="class">.<span class="keyword">class</span> &amp;&amp; !<span class="title">isFlowable</span> &amp;&amp; !<span class="title">isSingle</span> &amp;&amp; !<span class="title">isMaybe</span>) </span>&#123;</span><br><span class="line">      		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// ...</span></span><br><span class="line">    	<span class="keyword">return</span> new RxJava2CallAdapter(responseType, scheduler, isAsync, isResult, isBody, isFlowable, isSingle, isMaybe, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于本例子而言，最终 RxJava2CallAdapter 又会返回 CallExecuteObservable，CallExecuteObservable 又会在外部进行 <code>subscribe()</code> 的时候调用 <code>call.execute()</code> 方法来发起网络请求，所以在上面的例子中我们并不需要显式地发起网络请求，而是在进行 <code>subscribe(</code>) 的时候就自动触发请求了，Observer 只需要等待网络请求结果自动回调出来即可</p>
  <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RxJava2CallAdapter</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">CallAdapter</span>&lt;<span class="title">R</span>, <span class="title">Object</span>&gt; </span>&#123;      </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function">Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> responseType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function">Object <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class="line">    Observable&lt;Response&lt;R&gt;&gt; responseObservable =</span><br><span class="line">        isAsync ? <span class="keyword">new</span> CallEnqueueObservable&lt;&gt;(call) : <span class="keyword">new</span> CallExecuteObservable&lt;&gt;(call);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> RxJavaPlugins.<span class="title">onAssembly</span><span class="params">(observable)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">final <span class="keyword">class</span> CallExecuteObservable&lt;T&gt; extends Observable&lt;Response&lt;T&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> final Call&lt;T&gt; originalCall;</span><br><span class="line"></span><br><span class="line">  <span class="constructor">CallExecuteObservable(Call&lt;T&gt; <span class="params">originalCall</span>)</span> &#123;</span><br><span class="line">    this.originalCall = originalCall;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void subscribe<span class="constructor">Actual(Observer&lt;? <span class="params">super</span> Response&lt;T&gt;&gt; <span class="params">observer</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Since Call is a one-shot type, clone it for each new observer.</span></span><br><span class="line">    Call&lt;T&gt; call = originalCall.clone<span class="literal">()</span>;</span><br><span class="line">    CallDisposable disposable = <span class="keyword">new</span> <span class="constructor">CallDisposable(<span class="params">call</span>)</span>;</span><br><span class="line">    observer.on<span class="constructor">Subscribe(<span class="params">disposable</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (disposable.is<span class="constructor">Disposed()</span>) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean terminated = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//发起网络请求</span></span><br><span class="line">      Response&lt;T&gt; response = call.execute<span class="literal">()</span>;</span><br><span class="line">      <span class="keyword">if</span> (!disposable.is<span class="constructor">Disposed()</span>) &#123;</span><br><span class="line">        <span class="comment">//将请求结果传给外部</span></span><br><span class="line">        observer.on<span class="constructor">Next(<span class="params">response</span>)</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!disposable.is<span class="constructor">Disposed()</span>) &#123;</span><br><span class="line">        terminated = <span class="literal">true</span>;</span><br><span class="line">        observer.on<span class="constructor">Complete()</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">Exceptions</span>.</span></span>throw<span class="constructor">IfFatal(<span class="params">t</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span> (terminated) &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">RxJavaPlugins</span>.</span></span>on<span class="constructor">Error(<span class="params">t</span>)</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!disposable.is<span class="constructor">Disposed()</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          observer.on<span class="constructor">Error(<span class="params">t</span>)</span>;</span><br><span class="line">        &#125; catch (Throwable inner) &#123;</span><br><span class="line">          <span class="module-access"><span class="module"><span class="identifier">Exceptions</span>.</span></span>throw<span class="constructor">IfFatal(<span class="params">inner</span>)</span>;</span><br><span class="line">          <span class="module-access"><span class="module"><span class="identifier">RxJavaPlugins</span>.</span></span>on<span class="constructor">Error(<span class="params">new</span> CompositeException(<span class="params">t</span>, <span class="params">inner</span>)</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>问题又来了，<strong>Retrofit 是如何知道什么类型才可以交由 RxJava2CallAdapterFactory 来进行处理的？</strong></p>
</li>
<li><p>首先，当我们在构建 Retrofit 对象时传入了 RxJava2CallAdapterFactory，最终 Retrofit 会按照添加顺序对所有 CallAdapter.Factory 进行保存，且默认会在队尾添加一个 <strong>DefaultCallAdapterFactory</strong>，用于对包装类型为 <code>retrofit2.Call</code> 的情况进行解析</p>
</li>
<li><p>而 Retrofit 类的 <code>nextCallAdapter()</code> 方法就是为每一个 API 方法选择 CallAdapter 进行返回值数据类型转换的方法。该方法会先遍历到 RxJava2CallAdapter ，发现其返回了非 null 值，之后就交由其进行处理</p>
  <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public CallAdapter&lt;?, ?&gt; nextCallAdapter(</span><br><span class="line">     <span class="meta">@Nullable</span> CallAdapter.Factory skipPast, <span class="built_in">Type</span> returnType, Annotation[] annotations) &#123;</span><br><span class="line">   Objects.requireNonNull(returnType, <span class="string">"returnType == null"</span>);</span><br><span class="line">   Objects.requireNonNull(annotations, <span class="string">"annotations == null"</span>);</span><br><span class="line">	</span><br><span class="line">   <span class="built_in">int</span> start = callAdapterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="built_in">int</span> i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">     CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.<span class="keyword">get</span>(i).<span class="keyword">get</span>(returnType, annotations, <span class="keyword">this</span>);</span><br><span class="line">     <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> adapter;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="十一-数据转换流程总结"><a href="#十一-数据转换流程总结" class="headerlink" title="十一. 数据转换流程总结"></a>十一. 数据转换流程总结</h3><ul>
<li><p>在默认情况下，我们从回调 Callback 中取到的最原始的返回值类型是 <strong>Response<ResponseBody></strong></p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"getUserData"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserData</span><span class="params">()</span></span>: Call&lt;ResponseBody&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">"https://mockapi.eolinker.com/9IiwI82f58c23411240ed608ceca204b2f185014507cbe3/"</span>)</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">val</span> service = retrofit.create(ApiService::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">    <span class="keyword">val</span> call: Call&lt;ResponseBody&gt; = service.getUserData()</span><br><span class="line">    call.enqueue(<span class="keyword">object</span> : Callback&lt;ResponseBody&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">ResponseBody</span>&gt;, response: <span class="type">Response</span>&lt;<span class="type">ResponseBody</span>&gt;)</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> userBean = response.body()?.string()</span><br><span class="line">            println(<span class="string">"userBean: <span class="variable">$userBean</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">ResponseBody</span>&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="string">"onFailure: <span class="variable">$t</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>而在引入了 <strong>converter-gson</strong> 和 <strong>adapter-rxjava2</strong> 之后，我们可以直接拿到目标类型 UserBean</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBean</span></span>(<span class="keyword">val</span> userName: String, <span class="keyword">val</span> userAge: <span class="built_in">Long</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"getUserData"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserData</span><span class="params">()</span></span>: Observable&lt;UserBean&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">"https://mockapi.eolinker.com/9IiwI82f58c23411240ed608ceca204b2f185014507cbe3/"</span>)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .addCallAdapterFactory(RxJava2CallAdapterFactory.createAsync())</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">val</span> service = retrofit.create(ApiService::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">    <span class="keyword">val</span> call: Observable&lt;UserBean&gt; = service.getUserData()</span><br><span class="line">    call.subscribe(<span class="keyword">object</span> : Consumer&lt;UserBean&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">accept</span><span class="params">(userBean: <span class="type">UserBean</span>?)</span></span> &#123;</span><br><span class="line">            println(<span class="string">"userBean: <span class="variable">$userBean</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, <span class="keyword">object</span> : Consumer&lt;Throwable&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">accept</span><span class="params">(t: <span class="type">Throwable</span>?)</span></span> &#123;</span><br><span class="line">            println(<span class="string">"onFailure: <span class="variable">$t</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Retrofit 要达到这种转换效果，就要先后进行两个步骤：</p>
<ol>
<li>将 ResponseBody转换为 UserBean，从而可以得到 API 返回值 <code>Response&lt;UserBean&gt;</code></li>
<li>将 Call 转换为 Observable，Observable 直接从 <code>Response&lt;UserBean&gt;</code> 中把 UserBean 取出来作为返回值来返回，从而直接得到目标类型 UserBean</li>
</ol>
</li>
<li><p>第一个步骤即第九节所讲的内容，ResponseBody 转为 UserBean 的转换规则是通过 <strong>Converter</strong> 接口来定义的</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">Converter</span>&lt;<span class="symbol">F</span>, <span class="symbol">T</span>&gt; &#123;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//用于将 F 类型转换为 T 类型</span></span><br><span class="line">  @Nullable</span><br><span class="line">  T convert(F value) throws IOException;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个过程的转换就发生在 <strong>OkHttpCall</strong> 中，<code>enqueue()</code> 方法在拿到 OkHttp 返回的 <code>okhttp3.Response</code> 对象后，就通过调用 <code>parseResponse()</code> 方法来完成转化为 <code>Response&lt;T&gt;</code> 的逻辑，当中就调用了 Converter 接口的 <code>convert()</code> 方法，从而得到返回值 <code>Response&lt;UserBean&gt;</code></p>
  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">final <span class="keyword">class</span> OkHttpCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class="line"> </span><br><span class="line">  @Override</span><br><span class="line">  public void enqueue(final Callback&lt;T&gt; callback) &#123;</span><br><span class="line">    call.enqueue(</span><br><span class="line">        <span class="keyword">new</span> okhttp3.<span class="constructor">Callback()</span> &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void on<span class="constructor">Response(<span class="params">okhttp3</span>.Call <span class="params">call</span>, <span class="params">okhttp3</span>.Response <span class="params">rawResponse</span>)</span> &#123;</span><br><span class="line">            Response&lt;T&gt; response;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//重点</span></span><br><span class="line">              response = parse<span class="constructor">Response(<span class="params">rawResponse</span>)</span>;</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">              throw<span class="constructor">IfFatal(<span class="params">e</span>)</span>;</span><br><span class="line">              call<span class="constructor">Failure(<span class="params">e</span>)</span>;</span><br><span class="line">              return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              callback.on<span class="constructor">Response(OkHttpCall.<span class="params">this</span>, <span class="params">response</span>)</span>;</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">              throw<span class="constructor">IfFatal(<span class="params">t</span>)</span>;</span><br><span class="line">              t.print<span class="constructor">StackTrace()</span>; <span class="comment">// TODO this is not great</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line"> <span class="keyword">private</span> final Converter&lt;ResponseBody, T&gt; responseConverter;</span><br><span class="line">    </span><br><span class="line"> Response&lt;T&gt; parse<span class="constructor">Response(<span class="params">okhttp3</span>.Response <span class="params">rawResponse</span>)</span> throws IOException &#123;</span><br><span class="line">    ···</span><br><span class="line">    ExceptionCatchingResponseBody catchingBody = <span class="keyword">new</span> <span class="constructor">ExceptionCatchingResponseBody(<span class="params">rawBody</span>)</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//catchingBody 就是 ResponseBody 类型，将其转换为 T 类型</span></span><br><span class="line">      T body = responseConverter.convert(catchingBody);</span><br><span class="line">      <span class="comment">//然后再将其包装为 Response&lt;T&gt; 类型</span></span><br><span class="line">      return <span class="module-access"><span class="module"><span class="identifier">Response</span>.</span></span>success(body, rawResponse);</span><br><span class="line">    &#125; catch (RuntimeException e) &#123;</span><br><span class="line">      <span class="comment">// If the underlying source threw an exception, propagate that rather than indicating it was</span></span><br><span class="line">      <span class="comment">// a runtime exception.</span></span><br><span class="line">      catchingBody.throw<span class="constructor">IfCaught()</span>;</span><br><span class="line">      throw e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二个步骤即第十节所讲的内容， Call 转换为 Observable 的转换规则是通过 <strong>CallAdapter</strong> 接口来定义的</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">CallAdapter</span>&lt;<span class="symbol">R</span>, <span class="symbol">T</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">  Type responseType();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//此方法就用于将 Call&lt;R&gt; 转为你希望的目标类型 T，例如：Observable&lt;UserBean&gt;</span></span><br><span class="line">  T adapt(Call&lt;R&gt; call);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 CallEnqueueObservable 这个类中，通过自定义回调接口 CallCallback 来发起网络请求，从而拿到在第一个步骤解析完成后的数据，即 <code>Response&lt;UserBean&gt;</code> 对象</p>
  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> CallEnqueueObservable&lt;T&gt; <span class="keyword">extends</span> Observable&lt;Response&lt;T&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">Call</span>&lt;T&gt; originalCall;</span><br><span class="line"></span><br><span class="line">  CallEnqueueObservable(<span class="keyword">Call</span>&lt;T&gt; originalCall) &#123;</span><br><span class="line">    <span class="keyword">this</span>.originalCall = originalCall;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> subscribeActual(Observer&lt;? <span class="keyword">super</span> Response&lt;T&gt;&gt; observer) &#123;</span><br><span class="line">    <span class="comment">// Since Call is a one-shot type, clone it for each new observer.</span></span><br><span class="line">    <span class="keyword">Call</span>&lt;T&gt; <span class="keyword">call</span> = originalCall.clone();</span><br><span class="line">    CallCallback&lt;T&gt; callback = <span class="keyword">new</span> CallCallback&lt;&gt;(<span class="keyword">call</span>, observer);</span><br><span class="line">    observer.onSubscribe(callback);</span><br><span class="line">    <span class="keyword">if</span> (!callback.isDisposed()) &#123;</span><br><span class="line">      <span class="comment">//自定义回调，发起请求</span></span><br><span class="line">      <span class="keyword">call</span>.enqueue(callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> CallCallback&lt;T&gt; <span class="keyword">implements</span> Disposable, Callback&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">Call</span>&lt;?&gt; <span class="keyword">call</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> Response&lt;T&gt;&gt; observer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> disposed;</span><br><span class="line">    <span class="keyword">boolean</span> terminated = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    CallCallback(<span class="keyword">Call</span>&lt;?&gt; <span class="keyword">call</span>, Observer&lt;? <span class="keyword">super</span> Response&lt;T&gt;&gt; observer) &#123;</span><br><span class="line">      <span class="keyword">this</span>.<span class="keyword">call</span> = <span class="keyword">call</span>;</span><br><span class="line">      <span class="keyword">this</span>.observer = observer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> onResponse(<span class="keyword">Call</span>&lt;T&gt; <span class="keyword">call</span>, Response&lt;T&gt; response) &#123;</span><br><span class="line">        ···</span><br><span class="line">        <span class="comment">//直接将Response&lt;T&gt;传递出去，即 Response&lt;UserBean&gt; 对象</span></span><br><span class="line">     	observer.onNext(response);</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CallCallback 类同时持有着一个 observer 对象，该 observer 对象实际上又属于 BodyObservable 类。BodyObservable 在拿到了 <code>Response&lt;UserBean&gt;</code> 对象后，如果判断到此次网络请求属于成功状态的话，那么就直接取出 body （即 UserBean）传递出去。因此我们才可以直接拿到目标类型，而不包含任何包装类</p>
  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">final <span class="keyword">class</span> BodyObservable&lt;T&gt; extends Observable&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> final Observable&lt;Response&lt;T&gt;&gt; upstream;</span><br><span class="line"></span><br><span class="line">  <span class="constructor">BodyObservable(Observable&lt;Response&lt;T&gt;&gt; <span class="params">upstream</span>)</span> &#123;</span><br><span class="line">    this.upstream = upstream;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void subscribe<span class="constructor">Actual(Observer&lt;? <span class="params">super</span> T&gt; <span class="params">observer</span>)</span> &#123;</span><br><span class="line">    upstream.subscribe(<span class="keyword">new</span> BodyObserver&lt;T&gt;(observer));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> static <span class="keyword">class</span> BodyObserver&lt;R&gt; implements Observer&lt;Response&lt;R&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> final Observer&lt;? super R&gt; observer;</span><br><span class="line">    <span class="keyword">private</span> boolean terminated;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">BodyObserver(Observer&lt;? <span class="params">super</span> R&gt; <span class="params">observer</span>)</span> &#123;</span><br><span class="line">      this.observer = observer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void on<span class="constructor">Subscribe(Disposable <span class="params">disposable</span>)</span> &#123;</span><br><span class="line">      observer.on<span class="constructor">Subscribe(<span class="params">disposable</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void on<span class="constructor">Next(Response&lt;R&gt; <span class="params">response</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.is<span class="constructor">Successful()</span>) &#123;</span><br><span class="line">        <span class="comment">//如果本次网络请求成功，那么就直接取出 body 传递出去</span></span><br><span class="line">        observer.on<span class="constructor">Next(<span class="params">response</span>.<span class="params">body</span>()</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        terminated = <span class="literal">true</span>;</span><br><span class="line">        Throwable t = <span class="keyword">new</span> <span class="constructor">HttpException(<span class="params">response</span>)</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          observer.on<span class="constructor">Error(<span class="params">t</span>)</span>;</span><br><span class="line">        &#125; catch (Throwable inner) &#123;</span><br><span class="line">          <span class="module-access"><span class="module"><span class="identifier">Exceptions</span>.</span></span>throw<span class="constructor">IfFatal(<span class="params">inner</span>)</span>;</span><br><span class="line">          <span class="module-access"><span class="module"><span class="identifier">RxJavaPlugins</span>.</span></span>on<span class="constructor">Error(<span class="params">new</span> CompositeException(<span class="params">t</span>, <span class="params">inner</span>)</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="十二-Retrofit-对-Android-平台的特殊支持"><a href="#十二-Retrofit-对-Android-平台的特殊支持" class="headerlink" title="十二. Retrofit 对 Android 平台的特殊支持"></a>十二. Retrofit 对 Android 平台的特殊支持</h3><ul>
<li><p><strong>Retrofit 的内部实现并不需要依赖于 Android 平台，而是可以用于任意的 Java 客户端，Retrofit 只是对 Android 平台进行了特殊实现而已</strong></p>
</li>
<li><p>在构建 Retrofit 对象的时候，我们可以选择传递一个 <strong>Platform</strong> 对象用于标记调用方所处的平台</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Platform platform;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> HttpUrl baseUrl;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line">    Builder(Platform platform) &#123;</span><br><span class="line">      <span class="keyword">this</span>.platform = platform;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(Platform.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Platform 类有两个作用</strong>：</p>
<ol>
<li><p><strong>判断是否支持 Java 8</strong>。这在判断是否支持调用 interface 的默认方法，以及判断是否支持 Optional 和 CompletableFuture 时需要用到。因为 Android 应用如果想要支持 Java 8 的话，是需要在 Gradle 文件中进行主动配置的，且 Java 8 在 Android 平台上目前也支持得并不彻底，所以需要判断是否支持 Java 8 来决定是否启用特定功能</p>
</li>
<li><p><strong>实现 main 线程回调的 Executor</strong>。众所周知，Android 平台是不允许在 main 线程上执行耗时任务的，且 UI 操作都需要切换到 main 线程来完成。所以，对于 Android 平台来说，Retrofit 在回调网络请求结果时，都会通过 main 线程执行的 Executor 来进行线程切换</p>
 <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Platform PLATFORM = findPlatform();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function">Platform <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PLATFORM;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="function">Platform <span class="title">findPlatform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据 JVM 名字来判断使用方是否是 Android 平台</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Dalvik"</span>.equals(System.getProperty(<span class="string">"java.vm.name"</span>))</span><br><span class="line">        ? <span class="keyword">new</span> Android() <span class="comment">//</span></span><br><span class="line">        : <span class="keyword">new</span> Platform(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//是否支持 Java 8</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> hasJava8Types;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Constructor&lt;Lookup&gt; lookupConstructor;</span><br><span class="line"></span><br><span class="line">  Platform(<span class="keyword">boolean</span> hasJava8Types) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hasJava8Types = hasJava8Types;</span><br><span class="line"></span><br><span class="line">    Constructor&lt;Lookup&gt; lookupConstructor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasJava8Types) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Because the service interface might not be public, we need to use a MethodHandle lookup</span></span><br><span class="line">        <span class="comment">// that ignores the visibility of the declaringClass.</span></span><br><span class="line">        lookupConstructor = Lookup<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">Class</span>.<span class="title">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        lookupConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NoClassDefFoundError ignored) &#123;</span><br><span class="line">        <span class="comment">// Android API 24 or 25 where Lookup doesn't exist. Calling default methods on non-public</span></span><br><span class="line">        <span class="comment">// interfaces will fail, but there's nothing we can do about it.</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (NoSuchMethodException ignored) &#123;</span><br><span class="line">        <span class="comment">// Assume JDK 14+ which contains a fix that allows a regular lookup to succeed.</span></span><br><span class="line">        <span class="comment">// See https://bugs.openjdk.java.net/browse/JDK-8209005.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.lookupConstructor = lookupConstructor;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//获取默认的 Executor 实现，用于 Android 平台</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;? <span class="keyword">extends</span> CallAdapter.Factory&gt; defaultCallAdapterFactories(</span><br><span class="line">      <span class="meta">@Nullable</span> Executor callbackExecutor) &#123;</span><br><span class="line">    DefaultCallAdapterFactory executorFactory = <span class="keyword">new</span> DefaultCallAdapterFactory(callbackExecutor);</span><br><span class="line">    <span class="keyword">return</span> hasJava8Types</span><br><span class="line">        ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory)</span><br><span class="line">        : singletonList(executorFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">defaultCallAdapterFactoriesSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasJava8Types ? <span class="number">2</span> : 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;? <span class="keyword">extends</span> Converter.Factory&gt; defaultConverterFactories() &#123;</span><br><span class="line">    <span class="keyword">return</span> hasJava8Types ? singletonList(OptionalConverterFactory.INSTANCE) : emptyList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">defaultConverterFactoriesSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasJava8Types ? <span class="number">1</span> : 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@IgnoreJRERequirement</span> <span class="comment">// Only called on API 24+.</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isDefaultMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasJava8Types &amp;&amp; method.isDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@IgnoreJRERequirement</span> <span class="comment">// Only called on API 26+.</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  Object invokeDefaultMethod(Method method, Class&lt;?&gt; declaringClass, Object object, Object... args)</span><br><span class="line">      <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    Lookup lookup =</span><br><span class="line">        lookupConstructor != <span class="keyword">null</span></span><br><span class="line">            ? lookupConstructor.newInstance(declaringClass, <span class="number">-1</span> <span class="comment">/* trusted */</span>)</span><br><span class="line">            : MethodHandles.lookup();</span><br><span class="line">    <span class="keyword">return</span> lookup.unreflectSpecial(method, declaringClass).bindTo(object).invokeWithArguments(args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><strong>Platform 类只具有一个唯一子类，即 Android 类</strong>。其主要逻辑就是重写了父类的 <code>defaultCallbackExecutor()</code> 方法，通过 <strong>Handler</strong> 来实现在 main 线程执行特定的 Runnable，以此来实现网络请求结果都在 main 线程进行回调</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">    <span class="type">Android</span>() &#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="type">Build</span>.<span class="type">VERSION</span>.<span class="type">SDK_INT</span> &gt;= <span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">Executor</span> defaultCallbackExecutor() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">MainThreadExecutor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">Object</span> invokeDefaultMethod(</span><br><span class="line">        <span class="type">Method</span> method, <span class="type">Class</span>&lt;?&gt; declaringClass, <span class="type">Object</span> <span class="class"><span class="keyword">object</span>, <span class="title">Object</span>... <span class="title">args</span>) <span class="title">throws</span> <span class="title">Throwable</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="type">Build</span>.<span class="type">VERSION</span>.<span class="type">SDK_INT</span> &lt; <span class="number">26</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnsupportedOperationException</span>(</span><br><span class="line">            <span class="string">"Calling default methods on API 24 and 25 is not supported"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.invokeDefaultMethod(method, declaringClass, <span class="class"><span class="keyword">object</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="title">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Handler</span> handler = <span class="keyword">new</span> <span class="type">Handler</span>(<span class="type">Looper</span>.getMainLooper());</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      public void execute(<span class="type">Runnable</span> r) &#123;</span><br><span class="line">        handler.post(r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Retrofit 有个默认的 <code>CallAdapter.Factory</code> 接口实现类，用于对 API 返回值包装类型是 Call 的情形进行处理。DefaultCallAdapterFactory 会拿到 Platform 返回的 Executor 对象，如果 Executor 对象不为 null 且 API 方法没有标注 SkipCallbackExecutor 注解的话，就使用该  Executor 对象作为一个代理来中转所有的回调操作，以此实现线程切换。这里使用到了<strong>装饰器模式</strong></p>
  <figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> DefaultCallAdapterFactory extends CallAdapter.Factory &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">@Nullable</span> Executor callbackExecutor;</span><br><span class="line"></span><br><span class="line">  DefaultCallAdapterFactory(<span class="keyword">@Nullable</span> Executor callbackExecutor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">@Nullable</span> CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">      Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">      </span><br><span class="line">    ···</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Executor executor =</span><br><span class="line">        <span class="comment">//判断 annotations 是否包含 SkipCallbackExecutor 注解</span></span><br><span class="line">        <span class="comment">//有的话说明希望直接在原来的线程进行方法调用，不需要进行线程切换</span></span><br><span class="line">        Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.<span class="keyword">class</span>)</span><br><span class="line">            ? <span class="literal">null</span></span><br><span class="line">            : callbackExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      <span class="keyword">@Override</span></span><br><span class="line">      <span class="keyword">public</span> Type responseType() &#123;</span><br><span class="line">        <span class="keyword">return</span> responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">@Override</span></span><br><span class="line">      <span class="keyword">public</span> Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123;</span><br><span class="line">        <span class="comment">//executor 不为 null 的话就将其作为一个中间代理</span></span><br><span class="line">        <span class="comment">//交由 ExecutorCallbackCall 来完成实际的回调操作</span></span><br><span class="line">        <span class="keyword">return</span> executor == <span class="literal">null</span> ? call : <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(executor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">final</span> Call&lt;T&gt; <span class="built_in">delegate</span>;</span><br><span class="line"></span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; <span class="built_in">delegate</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">      <span class="keyword">this</span>.<span class="built_in">delegate</span> = <span class="built_in">delegate</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> enqueue(<span class="keyword">final</span> Callback&lt;T&gt; callback) &#123;</span><br><span class="line">      Objects.requireNonNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">delegate</span>.enqueue(</span><br><span class="line">          <span class="keyword">new</span> Callback&lt;T&gt;() &#123;</span><br><span class="line">            <span class="keyword">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> onResponse(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response) &#123;</span><br><span class="line">              callbackExecutor.execute(</span><br><span class="line">                  () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">delegate</span>.isCanceled()) &#123;</span><br><span class="line">                      <span class="comment">// Emulate OkHttp's behavior of throwing/delivering an IOException on</span></span><br><span class="line">                      <span class="comment">// cancellation.</span></span><br><span class="line">                      callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> onFailure(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t) &#123;</span><br><span class="line">              callbackExecutor.execute(() -&gt; callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, t));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line">        </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;margin-top:80px">-------------------- 本文结束<i class="fa fa-paw"></i>感谢您的阅读 --------------------</div>
    
</div>
      
    </div>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>隋钟元
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://24suixinsuoyu.com/2021/02/13/Android-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%9ARetrofit-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Android 三方库源码解析系列（四）：Retrofit 原理及源码解析">http://24suixinsuoyu.com/2021/02/13/Android-三方库源码解析系列：Retrofit-原理及源码解析/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Android-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/" rel="tag"><i class="fa fa-tag"></i> Android 三方库源码解析系列</a>
              <a href="/tags/Retrofit-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="tag"><i class="fa fa-tag"></i> Retrofit 原理及源码解析</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/13/Android-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%9AOkHttp-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="prev" title="Android 三方库源码解析系列（三）：OkHttp 原理及源码解析">
      <i class="fa fa-chevron-left"></i> Android 三方库源码解析系列（三）：OkHttp 原理及源码解析
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/02/14/Android-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9ARxJava-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="next" title="Android 三方库源码解析系列（五）：RxJava 原理及源码解析">
      Android 三方库源码解析系列（五）：RxJava 原理及源码解析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一-前言"><span class="nav-text">一. 前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-Demo"><span class="nav-text">二. Demo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三-Retrofit-create"><span class="nav-text">三. Retrofit.create()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四-ServiceMethod"><span class="nav-text">四. ServiceMethod</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五-HttpServiceMethod"><span class="nav-text">五. HttpServiceMethod</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六-OkHttpCall"><span class="nav-text">六. OkHttpCall</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七-总结"><span class="nav-text">七. 总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八-API-方法是如何解析的"><span class="nav-text">八. API 方法是如何解析的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#九-ResponseBody-是如何映射为-UserBean-的"><span class="nav-text">九. ResponseBody 是如何映射为 UserBean 的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十-Call-是如何替换为-Observable-的"><span class="nav-text">十. Call 是如何替换为 Observable 的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十一-数据转换流程总结"><span class="nav-text">十一. 数据转换流程总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十二-Retrofit-对-Android-平台的特殊支持"><span class="nav-text">十二. Retrofit 对 Android 平台的特殊支持</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="隋钟元"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">隋钟元</p>
  <div class="site-description" itemprop="description">技术创造价值</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">340</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">465</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:24suixinsuoyu@gmail.com" title="E-Mail → mailto:24suixinsuoyu@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/24suixinsuoyu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;24suixinsuoyu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/24sxsy" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;24sxsy" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/guolin_blog" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;guolin_blog" rel="noopener" target="_blank">郭霖</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/lmj623565791/" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;lmj623565791&#x2F;" rel="noopener" target="_blank">鸿洋</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.520monkey.com/" title="http:&#x2F;&#x2F;www.520monkey.com&#x2F;" rel="noopener" target="_blank">姜维</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://daimajia.com/" title="https:&#x2F;&#x2F;daimajia.com&#x2F;" rel="noopener" target="_blank">代码家</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://kmxz.net/" title="https:&#x2F;&#x2F;kmxz.net&#x2F;" rel="noopener" target="_blank">孔祥舟</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://yangwenbo.com/" title="http:&#x2F;&#x2F;yangwenbo.com&#x2F;" rel="noopener" target="_blank">杨文博</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">隋钟元</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">1.4m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">21:09</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>

