<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"24suixinsuoyu.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一. 支持的内存泄漏类型">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 三方库源码解析系列（六）：LeakCanary 原理及源码解析">
<meta property="og:url" content="http://24suixinsuoyu.com/2021/02/14/Android-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%9ALeakCanary-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="隋钟元’s Blog">
<meta property="og:description" content="一. 支持的内存泄漏类型">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-02-14T05:48:03.000Z">
<meta property="article:modified_time" content="2021-03-24T12:16:19.152Z">
<meta property="article:author" content="隋钟元">
<meta property="article:tag" content="Android 三方库源码解析系列">
<meta property="article:tag" content="LeakCanary 原理及源码解析">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://24suixinsuoyu.com/2021/02/14/Android-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%9ALeakCanary-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>Android 三方库源码解析系列（六）：LeakCanary 原理及源码解析 | 隋钟元’s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">隋钟元’s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-university"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th-list"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-english">

    <a href="/english/" rel="section"><i class="fa fa-fw fa-graduation-cap"></i>英语</a>

  </li>
        <li class="menu-item menu-item-life">

    <a href="/life/" rel="section"><i class="fa fa-fw fa-balance-scale"></i>生活</a>

  </li>
        <li class="menu-item menu-item-resume">

    <a href="/resume/" rel="section"><i class="fa fa-fw fa-user-circle-o"></i>简历</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/commonweal/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/24suixinsuoyu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://24suixinsuoyu.com/2021/02/14/Android-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%9ALeakCanary-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="隋钟元">
      <meta itemprop="description" content="技术创造价值">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="隋钟元’s Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android 三方库源码解析系列（六）：LeakCanary 原理及源码解析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-14 13:48:03" itemprop="dateCreated datePublished" datetime="2021-02-14T13:48:03+08:00">2021-02-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-24 20:16:19" itemprop="dateModified" datetime="2021-03-24T20:16:19+08:00">2021-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E3%80%8AAndroid-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%E3%80%8B/" itemprop="url" rel="index"><span itemprop="name">《Android 三方库源码解析系列》</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="一-支持的内存泄漏类型"><a href="#一-支持的内存泄漏类型" class="headerlink" title="一. 支持的内存泄漏类型"></a>一. 支持的内存泄漏类型</h3><a id="more"></a>

<ul>
<li><p>LeakCanary 能检测到应用内发生的内存泄露，官网写到具体支持的 4 种类型的内存泄露，LeakCanary automatically detects leaks of the following objects:</p>
<ul>
<li>destroyed <strong>Activity</strong> instances</li>
<li>destroyed <strong>Fragment</strong> instances</li>
<li>destroyed fragment <strong>View</strong> instances</li>
<li>cleared <strong>ViewModel</strong> instances</li>
</ul>
</li>
<li><p>我们也可以从 LeakCanary 的 <code>AppWatcher.Config</code> 这个类找到答案。Config 类用于配置是否开启内存检测，从其配置项就可以看出来 Leakcanary 支持：<strong>Activity</strong>、<strong>Fragment</strong>、<strong>FragmentView</strong>、<strong>ViewModel</strong> 等四种类型</p>
  <figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">data <span class="keyword">class</span> Config(</span><br><span class="line">    /**</span><br><span class="line">     * Whether AppWatcher should automatically watch destroyed activity instances.</span><br><span class="line">     *</span><br><span class="line">     * Defaults <span class="keyword">to</span> <span class="literal">true</span>.</span><br><span class="line">     */</span><br><span class="line">    val watchActivities: <span class="built_in">Boolean</span> = <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Whether AppWatcher should automatically watch destroyed fragment instances.</span><br><span class="line">     *</span><br><span class="line">     * Defaults <span class="keyword">to</span> <span class="literal">true</span>.</span><br><span class="line">     */</span><br><span class="line">    val watchFragments: <span class="built_in">Boolean</span> = <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Whether AppWatcher should automatically watch destroyed fragment view instances.</span><br><span class="line">     *</span><br><span class="line">     * Defaults <span class="keyword">to</span> <span class="literal">true</span>.</span><br><span class="line">     */</span><br><span class="line">    val watchFragmentViews: <span class="built_in">Boolean</span> = <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Whether AppWatcher should automatically watch cleared [androidx.lifecycle.ViewModel]</span><br><span class="line">     * instances.</span><br><span class="line">     *</span><br><span class="line">     * Defaults <span class="keyword">to</span> <span class="literal">true</span>.</span><br><span class="line">     */</span><br><span class="line">    val watchViewModels: <span class="built_in">Boolean</span> = <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * How <span class="built_in">long</span> <span class="keyword">to</span> wait before reporting a watched <span class="built_in">object</span> <span class="keyword">as</span> retained.</span><br><span class="line">     *</span><br><span class="line">     * <span class="keyword">Default</span> <span class="keyword">to</span> <span class="number">5</span> seconds.</span><br><span class="line">     */</span><br><span class="line">    val watchDurationMillis: <span class="built_in">Long</span> = TimeUnit.SECONDS.toMillis(<span class="number">5</span>),</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Deprecated, this didn<span class="comment">'t need to be a part of the API.</span></span><br><span class="line">     * Used <span class="keyword">to</span> indicate whether AppWatcher should watch objects (<span class="keyword">by</span> keeping weak references <span class="keyword">to</span></span><br><span class="line">     * them). Currently a no-op.</span><br><span class="line">     *</span><br><span class="line">     * <span class="keyword">If</span> you <span class="keyword">do</span> need <span class="keyword">to</span> <span class="keyword">stop</span> watching objects, simply don<span class="comment">'t pass them to [objectWatcher].</span></span><br><span class="line">     */</span><br><span class="line">    @Deprecated(<span class="string">"This didn't need to be a part of LeakCanary's API. No-Op."</span>)</span><br><span class="line">    val enabled: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="二-初始化"><a href="#二-初始化" class="headerlink" title="二. 初始化"></a>二. 初始化</h3><ul>
<li><p>我们在项目中引入 LeakCanary 只需要添加如下依赖即可，无须任何的初始化行为等附加操作，当应用启动时 LeakCanary 就会自动启动并开始监测了</p>
  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">  <span class="comment">// debugImplementation because LeakCanary should only run in debug builds.</span></span><br><span class="line">  debugImplementation <span class="string">'com.squareup.leakcanary:leakcanary-android:2.4'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一般来说，像这类第三方库都是需要由外部传入一个 ApplicationContext 对象进行初始化并启动的，LeakCanary 的 1.x 版本也是如此.但在 2.x 版本中，<strong>LeakCanary 将初始过程交由 AppWatcherInstaller 这个 ContentProvider 来自动完成</strong></p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">AppWatcherInstaller</span> : <span class="type">ContentProvider</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * [MainProcess] automatically sets up the LeakCanary code that runs in the main app process.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">MainProcess</span> : <span class="type">AppWatcherInstaller</span></span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When using the `leakcanary-android-process` artifact instead of `leakcanary-android`,</span></span><br><span class="line"><span class="comment">     * [LeakCanaryProcess] automatically sets up the LeakCanary code</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakCanaryProcess</span> : <span class="type">AppWatcherInstaller</span></span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> application = context!!.applicationContext <span class="keyword">as</span> Application</span><br><span class="line">        AppWatcher.manualInstall(application)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>由于 ContentProvider 会在 Application 被创建之前就由系统调用其 <code>onCreate()</code> 方法来完成初始化，所以 LeakCanary 通过 AppWatcherInstaller 就可以拿到 Context 来完成初始化并随应用一起启动，通过这种方式就简化了使用者的引入成本</strong>。而且由于我们的引用方式是 <strong>debugImplementation</strong>，所以正式版本会自动移除对 LeakCanary 的所有引用，进一步简化了引入成本</p>
</li>
<li><p>AppWatcherInstaller 最终会将 Application 对象传给 <strong>InternalAppWatcher</strong> 的 <code>install(Application)</code> 方法</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: this object must load fine in a JUnit environment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> InternalAppWatcher &#123;</span><br><span class="line"></span><br><span class="line">  ···</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">val</span> objectWatcher = ObjectWatcher(</span><br><span class="line">      clock = clock,</span><br><span class="line">      checkRetainedExecutor = checkRetainedExecutor,</span><br><span class="line">      isEnabled = &#123; <span class="literal">true</span> &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">(application: <span class="type">Application</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//检测是否在 main 线程</span></span><br><span class="line">    checkMainThread()</span><br><span class="line">    <span class="comment">//避免重复初始化</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>::application.isInitialized) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    InternalAppWatcher.application = application</span><br><span class="line">    <span class="keyword">if</span> (isDebuggableBuild) &#123;</span><br><span class="line">      SharkLog.logger = DefaultCanaryLog()</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//拿到默认配置，默认四种类型都进行检测</span></span><br><span class="line">    <span class="keyword">val</span> configProvider = &#123; AppWatcher.config &#125;</span><br><span class="line">    <span class="comment">//检测 Activity</span></span><br><span class="line">    ActivityDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class="line">    <span class="comment">//检测 Fragment、FragmentView、ViewModel</span></span><br><span class="line">    FragmentDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class="line">    onAppWatcherInstalled(application)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ···</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>LeakCanary 具体进行内存泄露检测的逻辑可以分为三类</strong>：</p>
<ul>
<li><strong>ObjectWatcher</strong>：检测 <strong>Object</strong> 的内存泄露情况</li>
<li><strong>ActivityDestroyWatcher</strong>：检测 <strong>Activity</strong> 的内存泄露情况</li>
<li><strong>FragmentDestroyWatcher</strong>：检测 <strong>Fragment</strong>、<strong>FragmentView</strong>、<strong>ViewModel</strong> 的内存泄露情况</li>
</ul>
</li>
<li><p>当中，ActivityDestroyWatcher 和 FragmentDestroyWatcher 都需要依靠 <strong>ObjectWatcher</strong> 来完成，因为 Activity、Fragment、FragmentView、ViewModel  本质上都属于不同类型的 Object</p>
</li>
</ul>
<h3 id="三-ObjectWatcher-检测任意对象"><a href="#三-ObjectWatcher-检测任意对象" class="headerlink" title="三. ObjectWatcher: 检测任意对象"></a>三. ObjectWatcher: 检测任意对象</h3><ul>
<li><p><strong>LeakCanary 基于引用队列 ReferenceQueue 实现检测内存泄漏</strong></p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> referenceQueue = ReferenceQueue&lt;Pair&lt;String, <span class="built_in">Int</span>&gt;?&gt;()</span><br><span class="line">    <span class="keyword">var</span> pair: Pair&lt;String, <span class="built_in">Int</span>&gt;? = Pair(<span class="string">"name"</span>, <span class="number">24</span>)</span><br><span class="line">    <span class="keyword">val</span> weakReference = WeakReference(pair, referenceQueue)</span><br><span class="line"></span><br><span class="line">    println(referenceQueue.poll()) <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">    pair = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    System.gc()</span><br><span class="line">    <span class="comment">//GC 后休眠一段时间，等待 pair 被回收</span></span><br><span class="line">    Thread.sleep(<span class="number">4000</span>)</span><br><span class="line"></span><br><span class="line">    println(referenceQueue.poll()) <span class="comment">//java.lang.ref.WeakReference@d716361</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看到，在 GC 过后 <code>referenceQueue.poll()</code> 的返回值变成了非 null，这是由于 WeakReference 和 ReferenceQueue 的一个组合特性导致的：<strong>在声明一个 WeakReference 对象时如果同时传入了 ReferenceQueue 作为构造参数的话，那么当 WeakReference 持有的对象被 GC 回收时，JVM 就会把这个弱引用存入与之关联的引用队列之中</strong>。依靠这个特性，我们就可以实现内存泄露的检测了</p>
</li>
<li><p>例如，当用户按返回键退出 Activity 时，正常情况下该 Activity 对象应该在不久后就被系统回收，我们可以监听 Activity 的 <code>onDestroy()</code> 回调，在回调时把 Activity 对象保存到和 ReferenceQueue 关联的 WeakReference 中，在一段时间后（可以主动触发几次 GC）检测 ReferenceQueue 中是否有值，如果一直为 null 的话就说明发生了内存泄露。LeakCanary 就是通过这种方法来实现的</p>
</li>
<li><p><strong>ObjectWatcher</strong> 中就封装了上述逻辑，ObjectWatcher 的起始方法是 <strong><code>watch(Any, String)</code></strong>，该方法就用于监听指定对象</p>
  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * References passed to [watch].</span></span><br><span class="line"><span class="comment">    * 用于保存要监听的对象，mapKey 是该对象的唯一标识、mapValue 是该对象的弱引用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> watchedObjects = mutableMapOf&lt;String, KeyedWeakReference&gt;<span class="literal">()</span></span><br><span class="line">	</span><br><span class="line">   <span class="comment">//KeyedWeakReference 关联的引用队列</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> queue = ReferenceQueue&lt;Any&gt;<span class="literal">()</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Watches the provided [watchedObject].</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param description Describes why the object is watched.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   @Synchronized</span><br><span class="line">   <span class="keyword">fun</span> watch(watchedObject: Any, description: String) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!is<span class="constructor">Enabled()</span>) &#123;</span><br><span class="line">           return</span><br><span class="line">       &#125;</span><br><span class="line">       remove<span class="constructor">WeaklyReachableObjects()</span></span><br><span class="line">       <span class="comment">//为 watchedObject 生成一个唯一标识</span></span><br><span class="line">       <span class="keyword">val</span> key = <span class="module-access"><span class="module"><span class="identifier">UUID</span>.</span></span>random<span class="constructor">UUID()</span>.<span class="keyword">to</span><span class="constructor">String()</span></span><br><span class="line">       <span class="keyword">val</span> watchUptimeMillis = clock.uptime<span class="constructor">Millis()</span></span><br><span class="line">       <span class="comment">//创建 watchedObject 关联的弱引用</span></span><br><span class="line">       <span class="keyword">val</span> reference = <span class="constructor">KeyedWeakReference(<span class="params">watchedObject</span>, <span class="params">key</span>, <span class="params">description</span>, <span class="params">watchUptimeMillis</span>, <span class="params">queue</span>)</span></span><br><span class="line">       ···</span><br><span class="line">       watchedObjects<span class="literal">[<span class="identifier">key</span>]</span> = reference</span><br><span class="line">       checkRetainedExecutor.execute &#123;</span><br><span class="line">           move<span class="constructor">ToRetained(<span class="params">key</span>)</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>watch()</code> 方法的主要逻辑</strong></p>
<ol>
<li>为每个 watchedObject 生成一个<strong>唯一标识 key</strong>，通过该 key 构建一个 watchedObject 的弱引用 <strong>KeyedWeakReference</strong>，将该弱引用保存到 <strong>watchedObjects</strong> 中。ObjectWatcher 可以先后监测多个对象，每个对象都会先被存入到 watchedObjects 中</li>
<li>外部通过传入的 <strong>checkRetainedExecutor</strong> 来指定检测内存泄露的触发时机，通过 <strong><code>moveToRetained()</code></strong> 方法来判断是否真的发生了内存泄露</li>
</ol>
</li>
<li><p><strong>KeyedWeakReference 是一个自定义的 WeakReference 子类</strong>，包含一个<strong>唯一 key</strong> 来标识特定对象，也包含一个 <strong>retainedUptimeMillis</strong> 字段用来标记是否发生了内存泄露</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">KeyedWeakReference</span>(</span><br><span class="line">        <span class="symbol">referent: <span class="symbol">Any</span>,</span></span><br><span class="line">        <span class="symbol">val</span> <span class="symbol">key: <span class="symbol">String</span>,</span></span><br><span class="line">        <span class="symbol">val</span> <span class="symbol">description: <span class="symbol">String</span>,</span></span><br><span class="line">        <span class="symbol">val</span> <span class="symbol">watchUptimeMillis: <span class="symbol">Long</span>,</span></span><br><span class="line">        <span class="symbol">referenceQueue: <span class="symbol">ReferenceQueue</span></span>&lt;<span class="symbol">Any</span>&gt;</span><br><span class="line">) : <span class="symbol">WeakReference</span>&lt;<span class="symbol">Any</span>&gt;(</span><br><span class="line">        <span class="symbol">referent, <span class="symbol">referenceQueue</span></span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Time at which the associated object ([referent]) was considered retained, or -1 if it hasn't</span></span><br><span class="line"><span class="comment">     * been yet.</span></span><br><span class="line"><span class="comment">     * 用于标记 referent 是否还未被回收，是的话则值不为 -1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Volatile</span><br><span class="line">    var retainedUptimeMillis = <span class="number">-1</span>L</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        @Volatile</span><br><span class="line">        @JvmStatic</span><br><span class="line">        var heapDumpUptimeMillis = <span class="number">0</span>L</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>moveToRetained()</code> 方法就用于判断指定 key 关联的对象是否已经泄露</strong>，如果没有泄露则移除对该对象的弱引用，有泄露的话则更新其 <strong>retainedUptimeMillis</strong> 值，以此来标记其发生了泄露，并同时通过回调 <strong>onObjectRetainedListeners</strong> 来分析内存泄露链</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">moveToRetained</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    removeWeaklyReachableObjects()</span><br><span class="line">    <span class="keyword">val</span> retainedRef = watchedObjects[key]</span><br><span class="line">    <span class="keyword">if</span> (retainedRef != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//记录当前时间</span></span><br><span class="line">        retainedRef.retainedUptimeMillis = clock.uptimeMillis()</span><br><span class="line">        onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//如果判断到一个对象没有发生内存泄露，那么就移除对该对象的弱引用</span></span><br><span class="line"><span class="comment">//此方法会先后调用多次</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeWeaklyReachableObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span></span><br><span class="line">    <span class="comment">// reachable. This is before finalization or garbage collection has actually happened.</span></span><br><span class="line">    <span class="keyword">var</span> ref: KeyedWeakReference?</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ref = queue.poll() <span class="keyword">as</span> KeyedWeakReference?</span><br><span class="line">        <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 ref 不为 null，说明 ref 关联的对象没有发生内存泄露，那么就移除对该对象的引用</span></span><br><span class="line">            watchedObjects.remove(ref.key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (ref != <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="四-ActivityDestroyWatcher-检测-Activity"><a href="#四-ActivityDestroyWatcher-检测-Activity" class="headerlink" title="四. ActivityDestroyWatcher: 检测 Activity"></a>四. ActivityDestroyWatcher: 检测 Activity</h3><ul>
<li><p>理解了 ObjectWatcher 的流程后来看 ActivityDestroyWatcher 就会比较简单了。<strong>ActivityDestroyWatcher 会向 Application 注册一个 ActivityLifecycleCallbacks 回调，当收到每个 Activity 执行了 onDestroy 的回调后，就会将 Activity 对象转交由 ObjectWatcher 来进行监听</strong></p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityDestroyWatcher</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> objectWatcher: ObjectWatcher, <span class="keyword">private</span> <span class="keyword">val</span> configProvider: () -&gt; Config) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> lifecycleCallbacks = <span class="keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="keyword">by</span> noOpDelegate() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityDestroyed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (configProvider().watchActivities) &#123;</span><br><span class="line">                objectWatcher.watch(activity, <span class="string">"<span class="subst">$&#123;activity::class.java.name&#125;</span> received Activity#onDestroy() callback"</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">(application: <span class="type">Application</span>, objectWatcher: <span class="type">ObjectWatcher</span>, configProvider: () -&gt; <span class="type">Config</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> activityDestroyWatcher = ActivityDestroyWatcher(objectWatcher, configProvider)</span><br><span class="line">            application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="五-FragmentDestroyWatcher-检测-Fragment"><a href="#五-FragmentDestroyWatcher-检测-Fragment" class="headerlink" title="五. FragmentDestroyWatcher: 检测 Fragment"></a>五. FragmentDestroyWatcher: 检测 Fragment</h3><ul>
<li><p>现在 Google 提供的基础依赖包分为了 <strong>Support</strong> 和 <strong>AndroidX</strong> 两种，Support 版本已经不再维护，主流的都是使用 AndroidX 了。而 LeakCanary 为了照顾老项目，就贴心的为这两种版本分别提供了 Fragment 的内存检测功能</p>
</li>
<li><p><strong>FragmentDestroyWatcher</strong> 可以看做是一个分发器，它会根据外部环境的不同来选择不同的检测手段，其主要逻辑是：</p>
<ul>
<li><p><strong>系统版本大于等于 8.0</strong>：使用 AndroidOFragmentDestroyWatcher 来检测 Fragment、FragmentView 的内存泄露</p>
</li>
<li><p><strong>开发者使用的是 Support 包</strong>：使用 AndroidSupportFragmentDestroyWatcher 来检测 Fragment、FragmentView 的内存泄露</p>
</li>
<li><p><strong>开发者使用的是 AndroidX 包</strong>：使用 AndroidXFragmentDestroyWatcher 来检测 Fragment、FragmentView、ViewModel 的内存泄露</p>
</li>
<li><p>通过反射 <strong><code>Class.forName()</code></strong> 来判断开发者使用的是 Support 包还是 AndroidX 包</p>
</li>
<li><p>由于 Fragment 都需要被挂载在 Activity 上，所以向 Application 注册一个 <strong>ActivityLifecycleCallback</strong>，每当有 Activity 被创建时就监听该 Activity 内可能存在的 Fragment</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> FragmentDestroyWatcher &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ANDROIDX_FRAGMENT_CLASS_NAME = <span class="string">"androidx.fragment.app.Fragment"</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME =</span><br><span class="line">    <span class="string">"leakcanary.internal.AndroidXFragmentDestroyWatcher"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Using a string builder to prevent Jetifier from changing this string to Android X Fragment</span></span><br><span class="line">  <span class="meta">@Suppress(<span class="meta-string">"VariableNaming"</span>, <span class="meta-string">"PropertyName"</span>)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> ANDROID_SUPPORT_FRAGMENT_CLASS_NAME =</span><br><span class="line">    StringBuilder(<span class="string">"android."</span>).append(<span class="string">"support.v4.app.Fragment"</span>)</span><br><span class="line">        .toString()</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME =</span><br><span class="line">    <span class="string">"leakcanary.internal.AndroidSupportFragmentDestroyWatcher"</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    application: <span class="type">Application</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    objectWatcher: <span class="type">ObjectWatcher</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    configProvider: () -&gt; <span class="type">AppWatcher</span>.<span class="type">Config</span></span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> fragmentDestroyWatchers = mutableListOf&lt;(Activity) -&gt; <span class="built_in">Unit</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SDK_INT &gt;= O) &#123;</span><br><span class="line">      fragmentDestroyWatchers.add(</span><br><span class="line">          AndroidOFragmentDestroyWatcher(objectWatcher, configProvider)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AndroidX </span></span><br><span class="line">    getWatcherIfAvailable(</span><br><span class="line">        ANDROIDX_FRAGMENT_CLASS_NAME,</span><br><span class="line">        ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,</span><br><span class="line">        objectWatcher,</span><br><span class="line">        configProvider</span><br><span class="line">    )?.let &#123;</span><br><span class="line">      fragmentDestroyWatchers.add(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Support </span></span><br><span class="line">    getWatcherIfAvailable(</span><br><span class="line">        ANDROID_SUPPORT_FRAGMENT_CLASS_NAME,</span><br><span class="line">        ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,</span><br><span class="line">        objectWatcher,</span><br><span class="line">        configProvider</span><br><span class="line">    )?.let &#123;</span><br><span class="line">      fragmentDestroyWatchers.add(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fragmentDestroyWatchers.size == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    application.registerActivityLifecycleCallbacks(<span class="keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="keyword">by</span> noOpDelegate() &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        activity: <span class="type">Activity</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">      )</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (watcher <span class="keyword">in</span> fragmentDestroyWatchers) &#123;</span><br><span class="line">          watcher(activity)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>由于 AndroidXFragmentDestroyWatcher、AndroidSupportFragmentDestroyWatcher、AndroidOFragmentDestroyWatcher 在逻辑上很类似，且就 AndroidXFragmentDestroyWatcher 同时提供了 <strong>ViewModel</strong> 内存泄露的检测功能，所以这里只看 <strong>AndroidXFragmentDestroyWatcher</strong> 就行</p>
</li>
<li><p><strong>AndroidXFragmentDestroyWatcher</strong> 的主要逻辑是：</p>
<ul>
<li><p>在 <code>invoke()</code> 方法里向 Activity 的 FragmentManager 以及 childFragmentManager 注册一个 <strong>FragmentLifecycleCallback</strong>，通过该回调拿到 <code>onFragmentViewDestroyed()</code> 和 <code>onFragmentDestroyed()</code> 的事件通知，收到通知时就通过 <strong>ObjectWatcher</strong> 启动检测</p>
</li>
<li><p>在 <code>onFragmentCreated()</code> 回调里通过 <strong>ViewModelClearedWatcher</strong> 来启动和 Fragment 关联的 ViewModel 的内存泄露检测逻辑</p>
</li>
<li><p>在 <code>invoke()</code> 方法里通过 <strong>ViewModelClearedWatcher</strong> 来启动和 Activity 关联的 ViewModel 的内存泄露检测</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidXFragmentDestroyWatcher</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> objectWatcher: ObjectWatcher,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> configProvider: () -&gt; Config</span><br><span class="line">) : (Activity) -&gt; <span class="built_in">Unit</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> fragmentLifecycleCallbacks = <span class="keyword">object</span> : FragmentManager.FragmentLifecycleCallbacks() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFragmentCreated</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      fm: <span class="type">FragmentManager</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      fragment: <span class="type">Fragment</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">      ViewModelClearedWatcher.install(fragment, objectWatcher, configProvider)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFragmentViewDestroyed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      fm: <span class="type">FragmentManager</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      fragment: <span class="type">Fragment</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">      <span class="keyword">val</span> view = fragment.view</span><br><span class="line">      <span class="keyword">if</span> (view != <span class="literal">null</span> &amp;&amp; configProvider().watchFragmentViews) &#123;</span><br><span class="line">        objectWatcher.watch(</span><br><span class="line">            view, <span class="string">"<span class="subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroyView() callback "</span> +</span><br><span class="line">            <span class="string">"(references to its views should be cleared to prevent leaks)"</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFragmentDestroyed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      fm: <span class="type">FragmentManager</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      fragment: <span class="type">Fragment</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (configProvider().watchFragments) &#123;</span><br><span class="line">        objectWatcher.watch(</span><br><span class="line">            fragment, <span class="string">"<span class="subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroy() callback"</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">is</span> FragmentActivity) &#123;</span><br><span class="line">      <span class="keyword">val</span> supportFragmentManager = activity.supportFragmentManager</span><br><span class="line">      supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, <span class="literal">true</span>)</span><br><span class="line">      ViewModelClearedWatcher.install(activity, objectWatcher, configProvider)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Fragment 和 FragmentView 走向 Destroyed 时，正常情况下它们都是不会被复用的，应该会很快就被 GC 回收，且它们本质上都只是一种对象，所以直接使用 <strong>ObjectWatcher</strong> 进行检测即可</p>
</li>
</ul>
<h3 id="六-ViewModelClearedWatcher-检测-ViewModel"><a href="#六-ViewModelClearedWatcher-检测-ViewModel" class="headerlink" title="六. ViewModelClearedWatcher: 检测 ViewModel"></a>六. ViewModelClearedWatcher: 检测 ViewModel</h3><ul>
<li><p>和 Fragment、FragmentView 相比，ViewModel 就比较特殊了，由于可能存在一个 Activity 和多个 Fragment 同时持有一个 ViewModel 实例的情况，而 leakcanary 无法知道 ViewModel 到底是同时被几个持有者所持有，所以无法通过单独一个 Activity 和 Fragment 的 Destroyed 回调来启动对 ViewModel 的检测。幸好 ViewMode 也提供了 <strong><code>onCleared()</code></strong> 的回调事件，leakcanary 就通过该回调来知道 ViewModel 是什么时候需要被回收</p>
</li>
<li><p><strong>ViewModelClearedWatcher</strong> 的主要逻辑是：</p>
<ul>
<li><p>ViewModelClearedWatcher 继承于 ViewModel，当拿到 ViewModelStoreOwner 实例（Activity 或者 Fragment）后，就创建一个和该实例绑定的 ViewModelClearedWatcher 对象</p>
</li>
<li><p>ViewModelClearedWatcher 通过反射获取到 ViewModelStore 中的 mMap 变量，该变量就存储了所有的 Viewmodel 实例</p>
</li>
<li><p>当 ViewModelClearedWatcher 的 <code>onCleared()</code> 方法被回调了，就说明了所有和 Activity 或者 Fragment 绑定的 ViewModel 实例都不再被需要了，此时就可以开始监测所有的 ViewModel 实例了</p>
  <figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">ViewModelClearedWatcher</span>(</span></span><br><span class="line">        <span class="symbol">storeOwner:</span> ViewModelStoreOwner,</span><br><span class="line">        <span class="keyword">private</span> val <span class="symbol">objectWatcher:</span> ObjectWatcher,</span><br><span class="line">        <span class="keyword">private</span> val <span class="symbol">configProvider:</span> () -&gt; Config</span><br><span class="line">) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> val <span class="symbol">viewModelMap:</span> Map&lt;String, ViewModel&gt;?</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        /<span class="regexp">/ We could call ViewModelStore#keys with a package spy in androidx.lifecycle instead,</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ however that was added in 2.1.0 and we support AndroidX first stable release. viewmodel-2.0.0</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ does not have ViewModelStore#keys. All versions currently have the mMap field.</span></span><br><span class="line"><span class="regexp">        viewModelMap = try &#123;</span></span><br><span class="line"><span class="regexp">            val mMapField = ViewModelStore::class.java.getDeclaredField("mMap")</span></span><br><span class="line"><span class="regexp">            mMapField.isAccessible = true</span></span><br><span class="line"><span class="regexp">            @Suppress("UNCHECKED_CAST")</span></span><br><span class="line"><span class="regexp">            mMapField[storeOwner.viewModelStore] as Map&lt;String, ViewModel&gt;</span></span><br><span class="line"><span class="regexp">        &#125; catch (ignored: Exception) &#123;</span></span><br><span class="line"><span class="regexp">            null</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    override fun onCleared() &#123;</span></span><br><span class="line"><span class="regexp">        if (viewModelMap != null &amp;&amp; configProvider().watchViewModels) &#123;</span></span><br><span class="line"><span class="regexp">            viewModelMap.values.forEach &#123; viewModel -&gt;</span></span><br><span class="line"><span class="regexp">                objectWatcher.watch(</span></span><br><span class="line"><span class="regexp">                        viewModel, "$&#123;viewModel::class.java.name&#125; received ViewModel#onCleared() callback"</span></span><br><span class="line"><span class="regexp">                )</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    companion object &#123;</span></span><br><span class="line"><span class="regexp">        fun install(storeOwner: ViewModelStoreOwner, objectWatcher: ObjectWatcher, configProvider: () -&gt; Config) &#123;</span></span><br><span class="line"><span class="regexp">            val provider = ViewModelProvider(storeOwner, object : Factory &#123;</span></span><br><span class="line"><span class="regexp">              @Suppress("UNCHECKED_CAST")</span></span><br><span class="line"><span class="regexp">              override fun &lt;T : ViewModel?&gt; create(modelClass: Class&lt;T&gt;): T =</span></span><br><span class="line"><span class="regexp">                      ViewModelClearedWatcher(storeOwner, objectWatcher, configProvider) as T</span></span><br><span class="line"><span class="regexp">            &#125;)</span></span><br><span class="line"><span class="regexp">            provider.get(ViewModelClearedWatcher::class.java)</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="七-检测到内存泄漏后的流程"><a href="#七-检测到内存泄漏后的流程" class="headerlink" title="七. 检测到内存泄漏后的流程"></a>七. 检测到内存泄漏后的流程</h3><ul>
<li><p>我们不可能在 Activity 刚被回调了 <code>onDestroy()</code> 方法就马上来判断 ReferenceQueue 中是否有值，因为 JVM 的 GC 时机是不确定的，Activity 对象可能不会那么快就被回收，所以需要延迟一段时间后再来检测。而即使延迟检测了，也可能会存在<strong>应用没有发生内存泄露只是系统还未执行 GC 的情况</strong>，所以就需要去主动触发 GC，经过几轮检测后才可以确定当前应用是否的确发生了内存泄露</p>
</li>
<li><p><strong>ObjectWatcher 对象包含了一个 Executor 参数：checkRetainedExecutor。检测操作的触发时机就取决于向 checkRetainedExecutor 提交的任务在什么时候会被执行</strong></p>
  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ObjectWatcher constructor(<span class="keyword">private</span> <span class="keyword">val</span> clock: Clock, <span class="keyword">private</span> <span class="keyword">val</span> checkRetainedExecutor: Executor,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Calls to [watch] will be ignored when [isEnabled] returns false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> isEnabled: <span class="literal">()</span> -&gt; Boolean = &#123; <span class="literal">true</span> &#125;</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Watches the provided [watchedObject].</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param description Describes why the object is watched.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Synchronized</span><br><span class="line">    <span class="keyword">fun</span> watch(</span><br><span class="line">            watchedObject: Any,</span><br><span class="line">            description: String</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!is<span class="constructor">Enabled()</span>) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        remove<span class="constructor">WeaklyReachableObjects()</span></span><br><span class="line">        <span class="keyword">val</span> key = <span class="module-access"><span class="module"><span class="identifier">UUID</span>.</span></span>random<span class="constructor">UUID()</span></span><br><span class="line">                .<span class="keyword">to</span><span class="constructor">String()</span></span><br><span class="line">        <span class="keyword">val</span> watchUptimeMillis = clock.uptime<span class="constructor">Millis()</span></span><br><span class="line">        <span class="keyword">val</span> reference =</span><br><span class="line">                <span class="constructor">KeyedWeakReference(<span class="params">watchedObject</span>, <span class="params">key</span>, <span class="params">description</span>, <span class="params">watchUptimeMillis</span>, <span class="params">queue</span>)</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">SharkLog</span>.</span></span>d &#123;</span><br><span class="line">            <span class="string">"Watching "</span> +</span><br><span class="line">                    (<span class="keyword">if</span> (watchedObject is Class&lt;*&gt;) watchedObject.<span class="keyword">to</span><span class="constructor">String()</span> <span class="keyword">else</span> <span class="string">"instance of $&#123;watchedObject.javaClass.name&#125;"</span>) +</span><br><span class="line">                    (<span class="keyword">if</span> (description.is<span class="constructor">NotEmpty()</span>) <span class="string">" ($description)"</span> <span class="keyword">else</span> <span class="string">""</span>) +</span><br><span class="line">                    <span class="string">" with key $key"</span></span><br><span class="line">        &#125;</span><br><span class="line">        watchedObjects<span class="literal">[<span class="identifier">key</span>]</span> = reference</span><br><span class="line">        <span class="comment">//重点</span></span><br><span class="line">        checkRetainedExecutor.execute &#123;</span><br><span class="line">            move<span class="constructor">ToRetained(<span class="params">key</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断 key 关联的对象是否已经泄露</span></span><br><span class="line">    <span class="comment">//是的话则将更新其 retainedUptimeMillis 值，以此来标记其发生了泄露</span></span><br><span class="line">    @Synchronized</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">fun</span> move<span class="constructor">ToRetained(<span class="params">key</span>: String)</span> &#123;</span><br><span class="line">        remove<span class="constructor">WeaklyReachableObjects()</span></span><br><span class="line">        <span class="keyword">val</span> retainedRef = watchedObjects<span class="literal">[<span class="identifier">key</span>]</span></span><br><span class="line">        <span class="keyword">if</span> (retainedRef != null) &#123;</span><br><span class="line">            retainedRef.retainedUptimeMillis = clock.uptime<span class="constructor">Millis()</span></span><br><span class="line">            <span class="comment">//重点，向外发出可能有内存泄露的通知</span></span><br><span class="line">            onObjectRetainedListeners.forEach &#123; it.on<span class="constructor">ObjectRetained()</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ObjectWatcher 对象又是在 InternalAppWatcher 里初始化的，checkRetainedExecutor 在收到任务后会通过 <strong>Handler</strong> 来延时五秒执行</p>
  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">internal object InternalAppWatcher &#123;</span><br><span class="line"></span><br><span class="line">  ···	</span><br><span class="line">    </span><br><span class="line">  private val mainHandler by lazy &#123;</span><br><span class="line">    Handler(Looper.getMainLooper())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private val checkRetainedExecutor = Executor &#123;</span><br><span class="line">    mainHandler.postDelayed(it, AppWatcher.config.watchDurationMillis)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  val objectWatcher = ObjectWatcher(</span><br><span class="line">     <span class="built_in"> clock </span>= clock,</span><br><span class="line">      checkRetainedExecutor = checkRetainedExecutor,</span><br><span class="line">      isEnabled = &#123; <span class="literal">true</span> &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  ···</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ObjectWatcher 的 <code>moveToRetained()</code> 方法又会通过 <strong>onObjectRetained</strong> 向外发出通知：当前可能发生了内存泄露。<strong>InternalLeakCanary</strong> 会收到这个通知，然后交由 <strong>HeapDumpTrigger</strong> 来进行检测</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> InternalLeakCanary : (Application) -&gt; <span class="built_in">Unit</span>, OnObjectRetainedListener &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> heapDumpTrigger: HeapDumpTrigger</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onObjectRetained</span><span class="params">()</span></span> = scheduleRetainedObjectCheck()</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">scheduleRetainedObjectCheck</span><span class="params">()</span></span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (<span class="keyword">this</span>::heapDumpTrigger.isInitialized) &#123;</span><br><span class="line">      		heapDumpTrigger.scheduleRetainedObjectCheck()</span><br><span class="line">    	&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">    </span><br><span class="line">    ···</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>当 LeakCanary 判定当前真的存在内存泄露时，就会进行 DumpHeap，找到泄露对象的引用链，而这个操作是比较费时费内存的，可能会直接导致应用页面无响应</strong>，所以 LeakCanary 进行 DumpHeap 前会有许多前置检查操作和前置条件，就是为了尽量减少 DumpHeap 次数以及在 DumpHeap 时尽量减少对开发人员的干扰</p>
</li>
<li><p><strong>heapDumpTrigger</strong> 的 <code>scheduleRetainedObjectCheck()</code> 方法的主要逻辑是：</p>
<ul>
<li><p>获取当前还未回收的对象个数 retainedKeysCount。如果个数大于 0，则先主动触发 GC，尽量尝试回收对象，避免误判，然后执行第二步；如果个数为 0，那么流程就结束了</p>
</li>
<li><p>GC 过后再次更新 retainedKeysCount 值，如果对象都被回收了（即 retainedKeysCount 值为 0），那么流程就结束了，否则就执行第三步</p>
</li>
<li><p>如果 retainedKeysCount 小于阈值 5，且当前“应用处于前台”或者是“应用处于后台但退到后台的时间还未超出五秒”，那么就启动一个定时任务，在二十秒后重新执行第一步，否则执行第四步</p>
</li>
<li><p>如果上一次 DumpHeap 离现在不足一分钟，那么就启动一个定时任务，满一分钟后重新执行第一步，否则执行第五步<br>此时各个条件都满足了，已经可以确定发生了内存泄漏，去执行 DumpHeap</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapDumpTrigger</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> application: Application,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> backgroundHandler: Handler,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> objectWatcher: ObjectWatcher,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> gcTrigger: GcTrigger,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> heapDumper: HeapDumper,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> configProvider: () -&gt; Config</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">scheduleRetainedObjectCheck</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            delayMillis: <span class="type">Long</span> = <span class="number">0</span>L</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> checkCurrentlyScheduledAt = checkScheduledAt</span><br><span class="line">        <span class="keyword">if</span> (checkCurrentlyScheduledAt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果当前已经在进行检测了，则直接返回</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        checkScheduledAt = SystemClock.uptimeMillis() + delayMillis</span><br><span class="line">        backgroundHandler.postDelayed(&#123;</span><br><span class="line">          checkScheduledAt = <span class="number">0</span></span><br><span class="line">          checkRetainedObjects()</span><br><span class="line">        &#125;, delayMillis)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkRetainedObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> iCanHasHeap = HeapDumpControl.iCanHasHeap()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> config = configProvider()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iCanHasHeap <span class="keyword">is</span> Nope) &#123;</span><br><span class="line">            <span class="keyword">if</span> (iCanHasHeap <span class="keyword">is</span> NotifyingNope) &#123;</span><br><span class="line">                <span class="comment">// Before notifying that we can't dump heap, let's check if we still have retained object.</span></span><br><span class="line">                <span class="keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (retainedReferenceCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    gcTrigger.runGc()</span><br><span class="line">                    retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> nopeReason = iCanHasHeap.reason()</span><br><span class="line">                <span class="keyword">val</span> wouldDump = !checkRetainedCount(</span><br><span class="line">                        retainedReferenceCount, config.retainedVisibleThreshold, nopeReason</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (wouldDump) &#123;</span><br><span class="line">                    <span class="keyword">val</span> uppercaseReason = nopeReason[<span class="number">0</span>].toUpperCase() + nopeReason.substring(<span class="number">1</span>)</span><br><span class="line">                    onRetainInstanceListener.onEvent(DumpingDisabled(uppercaseReason))</span><br><span class="line">                    showRetainedCountNotification(</span><br><span class="line">                            objectCount = retainedReferenceCount,</span><br><span class="line">                            contentText = uppercaseReason</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                SharkLog.d &#123;</span><br><span class="line">                    application.getString(</span><br><span class="line">                            R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前还未回收的对象个数</span></span><br><span class="line">        <span class="keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retainedReferenceCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//主动触发 GC，尽量尝试回收对象，避免误判</span></span><br><span class="line">            gcTrigger.runGc()</span><br><span class="line">            retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> now = SystemClock.uptimeMillis()</span><br><span class="line">        <span class="keyword">val</span> elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果上一次 DumpHeap 离现在不足一分钟，那么就启动一个定时任务，满一分钟后再次检查</span></span><br><span class="line">        <span class="keyword">if</span> (elapsedSinceLastDumpMillis &lt; WAIT_BETWEEN_HEAP_DUMPS_MILLIS) &#123;</span><br><span class="line">            onRetainInstanceListener.onEvent(DumpHappenedRecently)</span><br><span class="line">            showRetainedCountNotification(</span><br><span class="line">                    objectCount = retainedReferenceCount,</span><br><span class="line">                    contentText = application.getString(R.string.leak_canary_notification_retained_dump_wait)</span><br><span class="line">            )</span><br><span class="line">            scheduleRetainedObjectCheck(</span><br><span class="line">                    delayMillis = WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dismissRetainedCountNotification()</span><br><span class="line">        <span class="comment">//各个条件都满足了，已经可以确定发生了内存泄漏，去执行 DumpiHeap</span></span><br><span class="line">        dumpHeap(retainedReferenceCount, retry = <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断当前是否符合 DumpHeap 的条件，符合的话返回 false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> retainedKeysCount 当前还未回收的对象个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> retainedVisibleThreshold 触发 DumpHeap 的阈值</span></span><br><span class="line"><span class="comment">     * 只有当 retainedKeysCount 大于等于 retainedVisibleThreshold 时才会触发 DumpHeap，默认值是 5</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nopeReason</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkRetainedCount</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            retainedKeysCount: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            retainedVisibleThreshold: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            nopeReason: <span class="type">String</span>? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="comment">//用于标记本次检测相对上次，未回收的对象个数是否发生了变化</span></span><br><span class="line">        <span class="keyword">val</span> countChanged = lastDisplayedRetainedObjectCount != retainedKeysCount</span><br><span class="line">        lastDisplayedRetainedObjectCount = retainedKeysCount</span><br><span class="line">        <span class="keyword">if</span> (retainedKeysCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (countChanged) &#123;</span><br><span class="line">                <span class="comment">//如果 retainedKeysCount 为 0，且值相对上次检测减少了，则说明有对象被回收了</span></span><br><span class="line">                SharkLog.d &#123; <span class="string">"All retained objects have been garbage collected"</span> &#125;</span><br><span class="line">                onRetainInstanceListener.onEvent(NoMoreObjects)</span><br><span class="line">                showNoMoreRetainedObjectNotification()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//应用是否还在前台</span></span><br><span class="line">        <span class="keyword">val</span> applicationVisible = applicationVisible</span><br><span class="line">        <span class="keyword">val</span> applicationInvisibleLessThanWatchPeriod = applicationInvisibleLessThanWatchPeriod</span><br><span class="line"></span><br><span class="line">        ···</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retainedKeysCount &lt; retainedVisibleThreshold) &#123; <span class="comment">//还未达到阈值</span></span><br><span class="line">            <span class="keyword">if</span> (applicationVisible || applicationInvisibleLessThanWatchPeriod) &#123;</span><br><span class="line">                <span class="keyword">if</span> (countChanged) &#123;</span><br><span class="line">                    onRetainInstanceListener.onEvent(BelowThreshold(retainedKeysCount))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//在通知栏显示当前未回收的对象个数</span></span><br><span class="line">                showRetainedCountNotification(</span><br><span class="line">                        objectCount = retainedKeysCount,</span><br><span class="line">                        contentText = application.getString(</span><br><span class="line">                                R.string.leak_canary_notification_retained_visible, retainedVisibleThreshold</span><br><span class="line">                        )</span><br><span class="line">                )</span><br><span class="line">                <span class="comment">//retainedKeysCount 还未达到阈值，且当前“应用处于前台”或者是“应用处于后台但退到后台的时间还未超出五秒”</span></span><br><span class="line">                <span class="comment">//此时就启动一个定时任务，在二十秒后重新再检测一遍</span></span><br><span class="line">                scheduleRetainedObjectCheck(</span><br><span class="line">                        delayMillis = WAIT_FOR_OBJECT_THRESHOLD_MILLIS</span><br><span class="line">                )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ···</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="八-进阶操作"><a href="#八-进阶操作" class="headerlink" title="八. 进阶操作"></a>八. 进阶操作</h3><ol>
<li><p><strong>检测任意对象</strong>：除了 LeakCanary 默认支持的四种类型外，我们还可以主动检测任意对象。例如，可以检测 <strong>Service</strong></p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyService</span> : <span class="type">Service &#123;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    AppWatcher.objectWatcher.watch(</span><br><span class="line">      watchedObject = <span class="keyword">this</span>,</span><br><span class="line">      description = <span class="string">"MyService received Service#onDestroy() callback"</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>更改配置项</strong>：可以在 <strong>Application</strong> 中更改 LeakCanary 的默认配置项（比如不希望检测 FragmentView）</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugExampleApplication</span> : <span class="type">Application</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate()</span><br><span class="line">    AppWatcher.config = AppWatcher.config.copy(watchFragmentViews = <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于 LeakCanary 的引用方式是 <strong>debugImplementation</strong>，在 releas 环境下是引用不到 LeakCanary 的，所以为了避免在生成 release 包时需要主动来删除这行配置项，需要将 <strong>DebugExampleApplication</strong> 放到 <code>src/debug/java</code> 文件夹中</li>
</ul>
</li>
</ol>
<h3 id="九-总结"><a href="#九-总结" class="headerlink" title="九. 总结"></a>九. 总结</h3><ul>
<li><strong>Activity</strong>、<strong>Fragment</strong>、<strong>FragmentView</strong>、<strong>ViewModel</strong> 等四种类型的内存检测都是需要依靠 <strong>ObjectWatcher</strong> 来完成的，因为这四种类型本质上都是属于不同的对象。而 ObjectWatcher 需要依靠<strong>引用队列 ReferenceQueue</strong> 来实现，因此 LeakCanary 的基本实现基础就是来源于 Java 的原生特性</li>
</ul>

    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;margin-top:80px">-------------------- 本文结束<i class="fa fa-paw"></i>感谢您的阅读 --------------------</div>
    
</div>
      
    </div>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>隋钟元
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://24suixinsuoyu.com/2021/02/14/Android-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%9ALeakCanary-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Android 三方库源码解析系列（六）：LeakCanary 原理及源码解析">http://24suixinsuoyu.com/2021/02/14/Android-三方库源码解析系列：LeakCanary-原理及源码解析/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Android-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/" rel="tag"><i class="fa fa-tag"></i> Android 三方库源码解析系列</a>
              <a href="/tags/LeakCanary-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="tag"><i class="fa fa-tag"></i> LeakCanary 原理及源码解析</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/14/Android-%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9ARxJava-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="prev" title="Android 三方库源码解析系列（五）：RxJava 原理及源码解析">
      <i class="fa fa-chevron-left"></i> Android 三方库源码解析系列（五）：RxJava 原理及源码解析
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BB%93%E8%AF%BE%E6%B5%8B%E8%AF%95/" rel="next" title="数据结构与算法之美（五）：结课测试">
      数据结构与算法之美（五）：结课测试 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一-支持的内存泄漏类型"><span class="nav-text">一. 支持的内存泄漏类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-初始化"><span class="nav-text">二. 初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三-ObjectWatcher-检测任意对象"><span class="nav-text">三. ObjectWatcher: 检测任意对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四-ActivityDestroyWatcher-检测-Activity"><span class="nav-text">四. ActivityDestroyWatcher: 检测 Activity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五-FragmentDestroyWatcher-检测-Fragment"><span class="nav-text">五. FragmentDestroyWatcher: 检测 Fragment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六-ViewModelClearedWatcher-检测-ViewModel"><span class="nav-text">六. ViewModelClearedWatcher: 检测 ViewModel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七-检测到内存泄漏后的流程"><span class="nav-text">七. 检测到内存泄漏后的流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八-进阶操作"><span class="nav-text">八. 进阶操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#九-总结"><span class="nav-text">九. 总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="隋钟元"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">隋钟元</p>
  <div class="site-description" itemprop="description">技术创造价值</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">340</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">465</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:24suixinsuoyu@gmail.com" title="E-Mail → mailto:24suixinsuoyu@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/24suixinsuoyu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;24suixinsuoyu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/24sxsy" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;24sxsy" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/guolin_blog" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;guolin_blog" rel="noopener" target="_blank">郭霖</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/lmj623565791/" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;lmj623565791&#x2F;" rel="noopener" target="_blank">鸿洋</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.520monkey.com/" title="http:&#x2F;&#x2F;www.520monkey.com&#x2F;" rel="noopener" target="_blank">姜维</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://daimajia.com/" title="https:&#x2F;&#x2F;daimajia.com&#x2F;" rel="noopener" target="_blank">代码家</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://kmxz.net/" title="https:&#x2F;&#x2F;kmxz.net&#x2F;" rel="noopener" target="_blank">孔祥舟</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://yangwenbo.com/" title="http:&#x2F;&#x2F;yangwenbo.com&#x2F;" rel="noopener" target="_blank">杨文博</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">隋钟元</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">1.4m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">21:21</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>

