<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"24suixinsuoyu.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一. JVM 运行时数据区域概述">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 编程基础（七）：深入理解 Java 虚拟机">
<meta property="og:url" content="http://24suixinsuoyu.com/2020/04/10/Java-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/index.html">
<meta property="og:site_name" content="隋钟元’s Blog">
<meta property="og:description" content="一. JVM 运行时数据区域概述">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1goxbdwj50qj30s608o0tw.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1goxnz5s7uzj30jx09lq36.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1goyjmnbs41j30ju0cfglx.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1goyk7jy2d6j30hx0e1q3j.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1goylo84tw5j30k70e33z1.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1gp1xror1qsj30r80bnjs5.jpg">
<meta property="article:published_time" content="2020-04-10T02:17:30.000Z">
<meta property="article:modified_time" content="2021-03-30T09:55:37.273Z">
<meta property="article:author" content="隋钟元">
<meta property="article:tag" content="编程基础">
<meta property="article:tag" content="深入理解 Java 虚拟机">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1goxbdwj50qj30s608o0tw.jpg">

<link rel="canonical" href="http://24suixinsuoyu.com/2020/04/10/Java-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>Java 编程基础（七）：深入理解 Java 虚拟机 | 隋钟元’s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">隋钟元’s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-university"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th-list"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-english">

    <a href="/english/" rel="section"><i class="fa fa-fw fa-graduation-cap"></i>英语</a>

  </li>
        <li class="menu-item menu-item-life">

    <a href="/life/" rel="section"><i class="fa fa-fw fa-balance-scale"></i>生活</a>

  </li>
        <li class="menu-item menu-item-resume">

    <a href="/resume/" rel="section"><i class="fa fa-fw fa-user-circle-o"></i>简历</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/commonweal/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/24suixinsuoyu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://24suixinsuoyu.com/2020/04/10/Java-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="隋钟元">
      <meta itemprop="description" content="技术创造价值">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="隋钟元’s Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 编程基础（七）：深入理解 Java 虚拟机
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-10 10:17:30" itemprop="dateCreated datePublished" datetime="2020-04-10T10:17:30+08:00">2020-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-30 17:55:37" itemprop="dateModified" datetime="2021-03-30T17:55:37+08:00">2021-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E3%80%8AJava-%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E3%80%8B/" itemprop="url" rel="index"><span itemprop="name">《Java 编程的逻辑》</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="一-JVM-运行时数据区域概述"><a href="#一-JVM-运行时数据区域概述" class="headerlink" title="一. JVM 运行时数据区域概述"></a>一. JVM 运行时数据区域概述</h2><a id="more"></a>

<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><ul>
<li>Java 虚拟机在执行 Java 程序的过程中会把它所管理的<strong>内存划分</strong>为若干个不同的数据区域</li>
<li>这些区域分为两部分，一部分是<strong>线程私有</strong>的，另一部分是<strong>线程公有</strong>的</li>
</ul>
<h3 id="2-示意图"><a href="#2-示意图" class="headerlink" title="2. 示意图"></a>2. 示意图</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goxbdwj50qj30s608o0tw.jpg" alt="JVM 运行时数据区域示意图"></p>
<h3 id="3-线程私有内存"><a href="#3-线程私有内存" class="headerlink" title="3. 线程私有内存"></a>3. 线程私有内存</h3><h4 id="3-1-程序计数器（Program-Counter-Register）"><a href="#3-1-程序计数器（Program-Counter-Register）" class="headerlink" title="3.1 程序计数器（Program Counter Register）"></a>3.1 程序计数器（Program Counter Register）</h4><ul>
<li>程序计数器是一块<strong>较小的内存空间</strong>，可以看作<strong>当前线程所执行的字节码的行号指示器</strong>。字节码解释器工作时，通过改变程序计数器的值来选取下一条需要执行的字节码指令。它是<strong>程序控制流的指示器</strong>，分支、循环、跳转、异常处理、线程恢复等<strong>基础功能</strong>都需要依赖程序计数器完成</li>
<li>为了<strong>线程切换后能恢复</strong>到正确的位置，<strong>每个线程都需要有独立的程序计数器</strong>。由于每个线程的程序计数器是<strong>独立存储</strong>的，因此各线程之间的程序计数器<strong>互不影响</strong></li>
<li>如果线程正在执行的是一个 <strong>Java 方法</strong>，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 <strong><code>Native</code> 方法</strong>，那么这个计数器的值应为空（<code>Undefined</code>）。<strong>程序计数器是唯一不会出现 <code>OutOfMemoryError</code> 的内存区域</strong></li>
</ul>
<h4 id="3-2-Java-虚拟机栈（JVM-Stack）"><a href="#3-2-Java-虚拟机栈（JVM-Stack）" class="headerlink" title="3.2 Java 虚拟机栈（JVM Stack）"></a>3.2 Java 虚拟机栈（JVM Stack）</h4><ul>
<li><p>和程序计数器一样，Java 虚拟机栈也是<strong>线程私有</strong>的，它的生命周期与线程相同</p>
</li>
<li><p>Java 虚拟机栈描述的是 <strong>Java 方法执行的内存模型</strong></p>
<ul>
<li>每个方法被执行的时候会创建一个<strong>栈帧（Stack Frame）</strong>用于存储：<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法出口</strong>等信息</li>
<li><strong>局部变量表</strong>存放编译器可知的各种：<strong>基本数据类型</strong>、<strong>对象引用 reference 类型</strong>、<strong>返回地址 returnAddres 类型</strong></li>
<li>一个方法<strong>被调用直至执行完成</strong>的过程对应一个栈帧在虚拟机中<strong>从入栈到出栈</strong>的过程</li>
</ul>
</li>
<li><p>Java 虚拟机栈会出现<strong>两种异常</strong></p>
<ul>
<li><p><strong><code>StackOverflowError</code></strong>: 如果虚拟机栈<strong>不可以动态扩展</strong>，当<strong>线程请求的栈深度大于虚拟机所允许的深度</strong>时会抛出该异常</p>
</li>
<li><p><strong><code>OutOfMemoryError</code></strong>: 如果虚拟机栈<strong>可以动态扩展</strong>，当<strong>无法申请到足够的内存</strong>时会抛出该异常</p>
<blockquote>
<p>以前的 Classic 虚拟机栈可以动态扩展，<strong>现在主流的 HotSpot 虚拟机的栈容量不可以动态扩展</strong></p>
<p><strong>HotSpot 虚拟机不会因为无法动态扩展而导致 OOM，只会因为无法申请到足够的内存从而导致 OOM</strong></p>
<p><code>StackOverflowError</code> 更多是在程序刚一开始运行的时候抛出，强调的是<strong>不够用</strong>，一般发生在<strong>栈内存</strong>；<code>OutOfMemoryError</code> 更多是程序运行期间由内存泄漏累积导致抛出，强调的是<strong>被用完</strong>，一般发生在<strong>堆内存</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="3-3-本地方法栈（Native-Method-Stack）"><a href="#3-3-本地方法栈（Native-Method-Stack）" class="headerlink" title="3.3 本地方法栈（Native Method Stack）"></a>3.3 本地方法栈（Native Method Stack）</h4><ul>
<li>本地方法栈和虚拟机栈的作用<strong>非常相似</strong>。区别在于，<strong>虚拟机栈</strong>为虚拟机执行 Java 方法（<strong>字节码</strong>）服务；<strong>本地方法栈</strong>为虚拟机使用到的本地（<strong>Native</strong>）方法服务</li>
<li>具体的虚拟机可以根据需要自由实现本地方法栈，<strong>有的虚拟机（比如 HotSpot）直接把本地方法栈和虚拟机栈合二为一</strong></li>
<li>和虚拟机栈一样，本地方法栈也会在<strong>栈深度溢出</strong>时抛出 <strong><code>StackOverflowError</code></strong> 异常；在<strong>栈扩展失败</strong>时抛出 <strong><code>OutOfMemoryError</code></strong> 异常</li>
</ul>
<h3 id="4-线程共享内存"><a href="#4-线程共享内存" class="headerlink" title="4. 线程共享内存"></a>4. 线程共享内存</h3><h4 id="4-1-堆（Heap）"><a href="#4-1-堆（Heap）" class="headerlink" title="4.1 堆（Heap）"></a>4.1 堆（Heap）</h4><ul>
<li><p>对于 Java 应用程序而言，<strong>Java 堆是虚拟机管理的内存中最大的一块</strong>。Java 堆在虚拟机启动时创建，是被所有<strong>线程共享</strong>的内存区域，其目的是<strong>存放对象实例</strong>，几乎所有的对象实例（包括<strong>数组</strong>）都在堆中分配内存</p>
<blockquote>
<p>需要注意的是，由于即时编译、逃逸分析、栈上分配、标量替换等技术的发展，<strong>Java 对象实例都分配在堆上也渐渐不是那么绝对了</strong></p>
</blockquote>
</li>
<li><p>Java 堆是<strong>垃圾回收器管理</strong>的内存区域，因此也被称为 <strong>GC 堆（Garbage Collected Heap）</strong></p>
<ul>
<li><p>从<strong>回收内存</strong>的角度，由于现代编译器基本都采用<strong>分代垃圾回收算法</strong>，所以 Java 对还可以分为<strong>新生代</strong>和<strong>老年代</strong>，新生代又可以细分成 <code>Eden 空间</code>、<code>From Survivor 空间</code>、<code>To Survivor 空间</code>等</p>
<blockquote>
<p>需要注意的是，这些区域划分只是部分垃圾回收器的<strong>共同特性</strong>或<strong>设计风格</strong>，而非某个 Java 虚拟机具体实现的固有内存布局</p>
<p>随着垃圾回收器技术的发展，<strong>HotSpot 里面也出现了不采用分代设计的新垃圾回收器</strong></p>
</blockquote>
</li>
<li><p>从<strong>分配内存</strong>的角度，所有线程共享的 Java 堆中可以划分出多个<strong>线程私有</strong>的分配缓冲区（Thread Local Allocation Buffer，<strong>TLAB</strong>），以提升对象分配时的效率</p>
</li>
<li><p>Java 堆的作用是存储对象实例，将 Java 堆细分的目的只是为了<strong>更好地回收</strong>内存或者<strong>更快地分配</strong>内存</p>
</li>
</ul>
</li>
<li><p>Java 堆既可以被实现成固定大小的，也可以是可扩展的。当前主流的 Java 虚拟机都是按照<strong>可扩展</strong>来实现的（通过参数 <strong><code>-Xmx</code></strong>和<strong><code>-Xms</code></strong>设定）。如果在 Java 堆中没有内存完成实例分配，并且堆也无法再扩展时，JVM 将抛出 <strong><code>OutOfMemoryError</code></strong> 异常</p>
</li>
</ul>
<h4 id="4-2-方法区（Method-Area）"><a href="#4-2-方法区（Method-Area）" class="headerlink" title="4.2 方法区（Method Area）"></a>4.2 方法区（Method Area）</h4><ul>
<li><p>和堆一样，方法去也是被所有<strong>线程共享</strong>的内存区域。方法区用于存储已经被虚拟机加载的<strong>类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>即时编译器编译后的代码</strong>等数据。方法区还有一个<strong>“非堆（Non-Heap）”</strong>别名，目的是与 Java 堆区分开来。在 JDK 8 以前，也几乎等同于<strong>“永久代（Permanent Generation）”</strong>这个概念</p>
</li>
<li><p>方法区随 JDK 版本的迭代</p>
<ul>
<li><strong>JDK 6</strong>：HotSpot <strong>计划放弃</strong>永久代，采用<strong>本地内存（Native Memory）</strong>实现方法区</li>
<li><strong>JDK 7</strong>：HotSpot <strong>移除了</strong>原本放在永久代的<strong>字符串常量池</strong>、<strong>静态变量</strong>等</li>
<li><strong>JDK 8</strong>：HotSpot <strong>完全废弃了</strong>永久代（方法区），采用<strong>在本地内存中实现的元空间（Meta-space）</strong>来代替。<strong>元空间使用的是直接内存</strong></li>
</ul>
</li>
<li><p>当方法区无法满足新的内存分配需求时，将抛出 <strong><code>OutOfMemoryError</code></strong> 异常</p>
</li>
</ul>
<h4 id="4-3-运行时常量池（Runtime-Constant-Pool）"><a href="#4-3-运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="4.3 运行时常量池（Runtime Constant Pool）"></a>4.3 运行时常量池（Runtime Constant Pool）</h4><ul>
<li><p><strong>运行时常量池是方法区的一部分</strong></p>
<ul>
<li><strong>类信息（Class 文件）</strong>中除了有类的版本、字段、方法、接口等<strong>描述信息</strong>外，还有一项是<strong>常量池表（Constant Pool Table）</strong>，用于存放编译期生成的各种<strong>字面量</strong>与<strong>符号引用</strong></li>
<li>这个<strong>常量池表</strong>和由常量池表中符号引用翻译出来的<strong>直接引用</strong>将在类加载后存放到<strong>方法区的运行时常量池</strong></li>
</ul>
</li>
<li><p>运行时常量池相对于 Class 文件常量池表的另外一个重要特征是具备<strong>动态性</strong></p>
<ul>
<li><strong>Java 语言并不要求常量一定只有编译期才能产生</strong>，也就是说，并非预置入 Class 文件常量池表的内容才能进入方法去运行时常量池</li>
<li><strong>运行期间也可以将新的常量放入运行时常量池</strong>，这种特性被开发人员利用得比较多的就是 <strong><code>String</code> 类的 <code>intern()</code> 方法</strong></li>
</ul>
</li>
<li><p>因为是方法区的一部分，所以运行时常量池受到方法区内存的限制。当运行时常量池无法再申请到内存时会抛出 <strong><code>OutOfMemoryError</code></strong> 异常</p>
</li>
</ul>
<h3 id="5-直接内存（Direct-Memory）"><a href="#5-直接内存（Direct-Memory）" class="headerlink" title="5. 直接内存（Direct Memory）"></a>5. 直接内存（Direct Memory）</h3><ul>
<li><p>直接内存<strong>并不是</strong>虚拟机运行时数据区域的一部分，<strong>也不是</strong>《Java 虚拟机规范》中定义的内存区域，但是这部分内存也会被频繁使用</p>
</li>
<li><p><strong>在 JDK 1.4 中新加入了 NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong>和<strong>缓冲区（Buffer）</strong>的 I/O 方式</p>
<ul>
<li>它可以<strong>使用 Native 函数库直接分配堆外内存</strong>，然后通过一个<strong>存储在 Java 堆里面的 <code>DirectByteBuffer</code> 对象</strong>作为这块内存的引用进行操作</li>
<li>这样能<strong>在一些场景中显著提高性能</strong>，因为避免了在 Java 堆和 Native 堆中来回复制数据</li>
</ul>
</li>
<li><p>本机直接内存的分配不会受到 Java 堆大小的限制，但是会受到本机<strong>总内存</strong>（包括物理内存、SWAP 分区或者分页文件）大小以及<strong>处理器寻址空间</strong>的限制。比如说，服务器管理员根据实际内存去配置 -<code>Xmx</code> 等虚拟机参数时，如果忽略了直接内存使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），此时就会导致动态扩展时抛出 <strong><code>OutOfMemoryError</code></strong> 异常</p>
</li>
</ul>
<h2 id="二-垃圾回收判定算法及四种引用概述"><a href="#二-垃圾回收判定算法及四种引用概述" class="headerlink" title="二. 垃圾回收判定算法及四种引用概述"></a>二. 垃圾回收判定算法及四种引用概述</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h3><ul>
<li><strong>线程私有</strong>的内存区域（程序计数器、虚拟机栈、本地方法栈）：它们的生命周期和<strong>当前线程</strong>保持一致。当<strong>方法结束</strong>（栈帧出栈）或者线程结束时，内存自然被回收，因此不需要过多考虑回收的问题</li>
<li><strong>线程共享</strong>的内存区域（Java 堆、方法区）：由<strong>垃圾回收器</strong>负责管理回收</li>
<li>从<strong>如何判定对象消亡</strong>的角度出发，垃圾回收算法可以分为两大类<ul>
<li><strong>“引用计数式垃圾回收”（Reference Counting GC）</strong>：也被称作<strong>“直接垃圾回收”</strong></li>
<li><strong>“追踪式垃圾回收”（Tracing GC）</strong>：也被称为<strong>“间接垃圾回收”</strong>，<strong>是当前主流</strong> Java 虚拟机的垃圾回收算法实现</li>
</ul>
</li>
</ul>
<h3 id="2-引用计数（Reference-Counting）算法"><a href="#2-引用计数（Reference-Counting）算法" class="headerlink" title="2. 引用计数（Reference Counting）算法"></a>2. 引用计数（Reference Counting）算法</h3><h4 id="2-1-思路"><a href="#2-1-思路" class="headerlink" title="2.1 思路"></a>2.1 思路</h4><ul>
<li>在对象中添加一个<strong>引用计数器</strong>，每增加一个引用关系，值加 1；每失效一个引用关系，值减1</li>
<li>任何时刻<strong>计数器为 0 的对象</strong>就是不可能再被使用的</li>
</ul>
<h4 id="2-2-优点"><a href="#2-2-优点" class="headerlink" title="2.2 优点"></a>2.2 优点</h4><ul>
<li><strong>原理简单</strong>，判定效率高</li>
<li>只占用了很少的内存空间进行计数</li>
</ul>
<h4 id="2-3-缺点"><a href="#2-3-缺点" class="headerlink" title="2.3 缺点"></a>2.3 缺点</h4><ul>
<li>有很多例外情况要考虑，必须配合大量额外处理才能保证正确工作</li>
<li>比如，单纯的引用计数很难解决<strong>对象之间循环引用</strong>的问题</li>
</ul>
<h4 id="2-4-应用"><a href="#2-4-应用" class="headerlink" title="2.4 应用"></a>2.4 应用</h4><ul>
<li>Python 语音、在游戏脚本领域得到很多应用的 Squirrel</li>
<li>微软 COM(Component Object Model) 技术、使用 ActonScript 3 的 FlashPlayer</li>
</ul>
<h3 id="3-可达性分析（Reachability-Analysis）算法"><a href="#3-可达性分析（Reachability-Analysis）算法" class="headerlink" title="3. 可达性分析（Reachability Analysis）算法"></a>3. 可达性分析（Reachability Analysis）算法</h3><h4 id="3-1-示意图"><a href="#3-1-示意图" class="headerlink" title="3.1 示意图"></a>3.1 示意图</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goxnz5s7uzj30jx09lq36.jpg" alt="可达性分析算法示意图"></p>
<h4 id="3-2-思路"><a href="#3-2-思路" class="headerlink" title="3.2 思路"></a>3.2 思路</h4><ul>
<li>通过一系列称为 <strong>“GC Roots” 的根对象</strong>作为起始节点集，从这些节点开始根据引用关系向下搜索，搜索过程所走过的路径称为<strong>“引用链”（Reference Chain）</strong></li>
<li>如果<strong>某个对象到 GC Roots 之间没有任何引用链相连</strong>，用图论的术语就是<strong>从 GC Roots 到这个对象不可达</strong>时，证明该对象是不可能再被使用的</li>
</ul>
<h4 id="3-3-应用"><a href="#3-3-应用" class="headerlink" title="3.3 应用"></a>3.3 应用</h4><ul>
<li>主流的编程语言（<strong>Java</strong>、C#、Lisp 等）的内存管理系统<strong>都是使用可达性分析算法</strong>来判定对象是否存活的</li>
</ul>
<h4 id="3-4-GC-Roots-对象"><a href="#3-4-GC-Roots-对象" class="headerlink" title="3.4 GC Roots 对象"></a>3.4 GC Roots 对象</h4><ul>
<li>在<strong>虚拟机栈</strong>（栈帧中的本地变量表）中引用的对象，比如各个线程中调用的方法堆栈中使用到的参数、局部变量、临时变量等</li>
<li>在方法区中<strong>类静态</strong>属性引用的对象，比如 Java 类的引用类型静态变量</li>
<li>在方法区中<strong>常量</strong>引用的对象，比如字符串常量池（String Table）里的引用</li>
<li>在<strong>本地方法栈</strong>中 JNI（Native 方法）引用的对象</li>
<li>Java 虚拟机内部的引用，如基本数据类型对应的 <code>Class</code> 对象，一些常驻的异常对象（比如 <code>NullPointException</code>、<code>OutOfMemoryError</code>）等，还有系统类加载器</li>
<li>所有被同步锁（<code>synchronized</code> 关键字）持有的对象</li>
<li>反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等</li>
</ul>
<h3 id="4-四种引用类型概述"><a href="#4-四种引用类型概述" class="headerlink" title="4. 四种引用类型概述"></a>4. 四种引用类型概述</h3><h4 id="4-1-强引用（Strong-Reference）"><a href="#4-1-强引用（Strong-Reference）" class="headerlink" title="4.1 强引用（Strong Reference）"></a>4.1 强引用（Strong Reference）</h4><ul>
<li>任何情况下，垃圾回收器<strong>都不会回收</strong>强引用关联的对象</li>
<li>普遍存在的引用赋值，类似 <code>Object obj = new Object();</code></li>
</ul>
<h4 id="4-2-软引用（Soft-Reference）"><a href="#4-2-软引用（Soft-Reference）" class="headerlink" title="4.2 软引用（Soft Reference）"></a>4.2 软引用（Soft Reference）</h4><ul>
<li>发生在<strong>内存溢出异常之前</strong>，如果回收了软引用关联的对象之后内存还不够用，此时就抛出内存溢出异常</li>
<li>JDK 1.2 提供了实现类 <strong><code>SoftReference</code></strong></li>
</ul>
<h4 id="4-3-弱引用（Weak-Reference）"><a href="#4-3-弱引用（Weak-Reference）" class="headerlink" title="4.3 弱引用（Weak Reference）"></a>4.3 弱引用（Weak Reference）</h4><ul>
<li>无论当前内存是否足够，<strong>都会回收</strong>弱引用关联的对象</li>
<li>JDK 1.2 提供了实现类 <strong><code>WeakReference</code></strong></li>
</ul>
<h4 id="4-4-虚引用（Phantom-Reference）"><a href="#4-4-虚引用（Phantom-Reference）" class="headerlink" title="4.4 虚引用（Phantom Reference）"></a>4.4 虚引用（Phantom Reference）</h4><ul>
<li>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也<strong>无法通过虚引用来取得一个对象实例</strong></li>
<li>为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被回收时收到一个<strong>系统通知</strong></li>
<li>JDK 1.2 提供了实现类 <strong><code>PhantomReference</code></strong></li>
</ul>
<h3 id="5-两次标记过程与垃圾回收方法调用概述"><a href="#5-两次标记过程与垃圾回收方法调用概述" class="headerlink" title="5. 两次标记过程与垃圾回收方法调用概述"></a>5. 两次标记过程与垃圾回收方法调用概述</h3><h4 id="5-1-两次标记过程"><a href="#5-1-两次标记过程" class="headerlink" title="5.1 两次标记过程"></a>5.1 两次标记过程</h4><ul>
<li><p><strong>可达性分析算法</strong>中即使判定为不可达对象，也并不代表一个对象真正死亡，只是会被第一次标记</p>
</li>
<li><p><strong>一个对象真正死亡，至少要经历两次标记过程</strong></p>
<ol>
<li>如果对象在进行可达性分析后发现<strong>没有与 GC Roots 相连接的引用链</strong>，此时会被<strong>第一次标记</strong></li>
<li>随后进行一次筛选，如果判断<strong>有必要执行 <code>finalize()</code> 方法</strong>（已覆盖 <code>finalize()</code> 方法或 <code>finalize()</code> 方法还没有被虚拟机调用过）则在 <code>finalize()</code> 方法执行过程中进行<strong>第二次标记</strong></li>
</ol>
</li>
<li><p>在 <strong><code>finalize()</code></strong> 方法执行过程中，对象可以通过重新与引用链上的任何一个对象建立关联即可<strong>“拯救”</strong>自己，然后在<strong>第二次标记</strong>时会被移除“即将回收”的集合。否则该对象会被真正回收</p>
</li>
</ul>
<h4 id="5-2-finalize-方法概述"><a href="#5-2-finalize-方法概述" class="headerlink" title="5.2 finalize() 方法概述"></a>5.2 <code>finalize()</code> 方法概述</h4><ul>
<li>如果一个对象被判定为有必要执行 <code>finalize()</code> 方法，那么该对象首先会被放置在一个名为 <strong>F-Queue</strong> 的队列之中。稍后由一条由虚拟机自动建立的、低调度优先级的 <strong>Finalizer</strong> 线程去执行对象的 <code>finalize()</code> 方法</li>
<li><code>finalize()</code> 方法的<strong>“执行”</strong>是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束，因为 <strong><code>finalize()</code> 方法有可能运行失败</strong>（执行缓慢、甚至死循环导致回收系统崩溃）。 <strong>任何一个对象的 <code>finalize()</code> 方法都只会被系统自动调用一次</strong>，如果对象面临下一次回收，那么它的 <code>finalize()</code> 方法不会被再次执行</li>
<li><code>finalize()</code> 是在 <strong><code>Object</code></strong> 类中定义的，默认实现为空。该方法是 Java 刚诞生时为了使传统 C、C++ 程序员更容易接受 Java 所做出的一项妥协。该方法<strong>运行代价高</strong>、<strong>不确定性大</strong>，无法保证各个对象的调用顺序，已<strong>被官方明确声明不推荐使用</strong>的语法。<code>finalize()</code> 方法能做的工作，使用 <strong><code>try-finally</code></strong> 或者其他方式可以做得更好更及时</li>
</ul>
<h4 id="5-3-gc-方法概述"><a href="#5-3-gc-方法概述" class="headerlink" title="5.3 gc() 方法概述"></a>5.3 <code>gc()</code> 方法概述</h4><ul>
<li>调用垃圾回收器的方法是 <strong><code>gc()</code></strong>，该方法在 <code>System</code> 类和 <code>Runtime</code> 类中都存在</li>
<li>在 <code>System</code> 类中，<code>gc()</code> 是静态方法；在 <code>Runtime</code> 类中，<code>gc()</code> 是实例方法。方法 <code>System.gc()</code> 会调用 <code>Runtime</code> 类中的 <code>gc()</code> 方法，<strong><code>System.gc()</code> 等价于 <code>Runtime.getRuntime().gc()</code></strong></li>
<li><strong><code>System.gc()</code> 的作用是提示 Java 虚拟机进行垃圾回收</strong>。该方法被调用之后，<strong>由 Java 虚拟机决定是立即回收还是延迟回收</strong></li>
</ul>
<h3 id="6-方法区内存回收概述"><a href="#6-方法区内存回收概述" class="headerlink" title="6. 方法区内存回收概述"></a>6. 方法区内存回收概述</h3><h4 id="6-1-常量回收"><a href="#6-1-常量回收" class="headerlink" title="6.1 常量回收"></a>6.1 常量回收</h4><ul>
<li>废弃常量的回收（包括常量池中其他类、接口、方法、字段的符号引用）与 Java 堆对象的回收非常类似，也是<strong>类似二次标记</strong>的回收过程</li>
</ul>
<h4 id="6-2-类型卸载"><a href="#6-2-类型卸载" class="headerlink" title="6.2 类型卸载"></a>6.2 类型卸载</h4><ul>
<li><p><strong>判定一个类型需要回收需要同时满足的三个条件</strong></p>
<ul>
<li>该类所有的<strong>实例</strong>都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例</li>
<li>加载该类的<strong>类加载器</strong>已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景（如 OSGi、JSP 重加载等），否则通常很难达成</li>
<li>该类对应的 <strong><code>java.lang.Class</code></strong> 对象没有在任何地方被引用，无法在任何地方通过<strong>反射</strong>访问该类的方法</li>
</ul>
</li>
<li><p>满足上面三个条件的类只是<strong>“被允许”</strong>回收，HotSpot 虚拟机提供了 <strong><code>-Snoclassgc</code></strong> 参数对类型回收进行控制</p>
</li>
<li><p>在大量使用反射、动态代理、CGLib 等<strong>字节码框架</strong>、动态生成 JSP 以及 OSGi 这类<strong>频繁自定义类加载器</strong>的场景中，通常都需要 Java 虚拟机具备<strong>类型卸载</strong>的能力，以保证不会对<strong>方法区</strong>造成过大的内存压力</p>
</li>
</ul>
<h2 id="三-垃圾回收算法概述"><a href="#三-垃圾回收算法概述" class="headerlink" title="三. 垃圾回收算法概述"></a>三. 垃圾回收算法概述</h2><h3 id="1-分代回收理论概述"><a href="#1-分代回收理论概述" class="headerlink" title="1. 分代回收理论概述"></a>1. 分代回收理论概述</h3><ul>
<li><p>当前商业虚拟机的垃圾回收器，大多数都遵循了<strong>“分代回收”（Generational Collection）</strong>的理论进行设计</p>
<ul>
<li>分代回收名为理论，实质是一套符合大多数程序运行实际情况的<strong>经验法则</strong></li>
<li>需要注意的是，<strong>分代回收理论也有其缺陷</strong>，最新出现（或在实验室中）的几款垃圾回收器都展现出了<strong>面向全区域回收</strong>设计的思想（或者可以支持<strong>全区域不分代回收</strong>的工作模式）</li>
<li>HotSpot 虚拟机把 <strong>Java 堆</strong>划分为<strong>新生代（Young）</strong>和<strong>老年代（Old）</strong>两个区域，这也是现在<strong>业界主流</strong>的命名方式</li>
</ul>
</li>
<li><p>分代回收理论建立在<strong>三个假说</strong>之上</p>
<ul>
<li><strong>弱分代假说（Weak Generational Hypothesis）</strong>：绝大多数对象都是朝生夕灭的，新生代中的对象有 98%熬不过第一轮回收</li>
<li><strong>强分代假说（Strong Generational Hypothesis）</strong>：熬过越多次垃圾回收过程的对象就越难以消亡（越容易从新生代晋升到老年代）</li>
<li><strong>跨代引用假说（Intergenerational Reference Hypothesis）</strong>：跨代引用相对于同代引用来说仅占极少数</li>
</ul>
</li>
<li><p>针对不同分代的<strong>回收类型</strong>划分</p>
<ul>
<li><p><strong>部分回收（Partial GC）</strong>：只是部分回收 Java 堆的垃圾回收方式</p>
<ul>
<li><p><strong>新生代回收（Minor GC/Young GC）</strong>：只是新生代的垃圾回收方式</p>
</li>
<li><p><strong>老年代回收（Major GC/Old GC）</strong>：只是老年代的垃圾回收方式</p>
<blockquote>
<p>目前只有 CMS 垃圾回收器有单独回收老年代的行为</p>
<p>需要注意的是，”Major GC” 这个说法现在有点混淆，需要按上下文区分到底是指老年代回收还是整堆回收</p>
</blockquote>
</li>
<li><p><strong>混合回收（Mixed GC）</strong>：回收整个新生代以及部分老年代的垃圾回收方式</p>
</li>
</ul>
</li>
<li><p><strong>整堆回收（Full GC）</strong>：回收整个 Java 堆和方法区的垃圾回收方式</p>
</li>
</ul>
</li>
<li><p><strong>Minor GC 和 Major GC</strong></p>
<ul>
<li>Minor GC 指发生在新生代的垃圾回收操作。因为大多数对象的生命周期都很短，因此 Minor GC 会<strong>频繁执行</strong>，一般回收速度也<strong>比较快</strong></li>
<li>Major GC 指发生在老年代的垃圾回收操作。出现了 Major GC，经常会伴随至少一次的 Minor GC。老年代对象的存活时间长，因此 Major GC <strong>很少执行</strong>，而且执行速度会比 Minor GC <strong>慢很多</strong></li>
</ul>
</li>
<li><p><strong>对象优先在 Eden 区分配</strong></p>
<ul>
<li>大多数情况下，对象在新生代 Eden 区分配</li>
<li>当 Eden 区空间不够时，发起 Minor GC</li>
</ul>
</li>
<li><p><strong>大对象直接进入老年代</strong></p>
<ul>
<li>大对象是指需要<strong>连续内存空间</strong>的对象，最典型的大对象是那种很长的<strong>字符串</strong>以及<strong>数组</strong></li>
<li>大对象对于虚拟机的内存分配而言是坏消息，经常出现大对象会导致内存还有不少空间时就<strong>提前触发</strong>垃圾回收以获取足够的连续空间分配给大对象</li>
<li>将大对象直接在老年代中分配的目的是<strong>避免</strong>在 Eden 区和 Survivor 区之间出现<strong>大量内存复制</strong></li>
</ul>
</li>
<li><p><strong>长期存活的对象进入老年代</strong></p>
<ul>
<li>Java 虚拟机采用<strong>分代回收</strong>的思想管理内存，因此<strong>需要识别每个对象应该放在新生代还是老年代</strong></li>
<li><strong>虚拟机给每个对象定义了年龄计数器</strong>，对象在 Eden 区出生之后，如果经过第一次 Minor GC 之后仍然存活，将进入 Survivor 区，同时对象年龄变为 1，对象在 Survivor 区每经过一次 Minor GC 且存活，年龄就增加 1，<strong>增加到一定阈值时则进入老年代（阈值默认为 15）</strong></li>
</ul>
</li>
<li><p><strong>动态对象年龄判定</strong></p>
<ul>
<li>为了能<strong>更好地适应</strong>不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到阈值才能进入老年代</li>
<li>如果在 Survivor 区中相同年龄的所有对象的空间总和大于 Survivor 区空间的一半，则年龄大于或等于该年龄的对象<strong>直接进入</strong>老年代</li>
</ul>
</li>
<li><p><strong>空间分配担保</strong></p>
<ul>
<li>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的空间总和，如果这个条件成立，那么 Minor GC 可以确保是安全的</li>
<li>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Major GC</li>
</ul>
</li>
</ul>
<h3 id="2-标记-清除（Mark-Sweep）算法"><a href="#2-标记-清除（Mark-Sweep）算法" class="headerlink" title="2. 标记-清除（Mark-Sweep）算法"></a>2. 标记-清除（Mark-Sweep）算法</h3><ul>
<li><p><strong>示意图</strong></p>
<p>  <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goyjmnbs41j30ju0cfglx.jpg" alt="标记-清除"></p>
</li>
<li><p><strong>思路</strong></p>
<ul>
<li><strong>标记并回收</strong>：首先<strong>标记所有</strong>需要回收的对象，然后<strong>统一回收</strong>所有被标记的对象（也可以反过来，标记存活的对象、统一回收未被标记的对象）</li>
<li><strong>标记的过程</strong>：就是判定对象是否属于垃圾的<strong>两次标记过程</strong></li>
</ul>
</li>
<li><p><strong>缺点</strong></p>
<ul>
<li><strong>执行效率低</strong>：面对大量可回收对象时，必须进行大量的标记和清除动作</li>
<li><strong>内存碎片化</strong>：标记清除之后会产生大量不连续的内存碎片，会影响内存的分配和回收</li>
</ul>
</li>
<li><p><strong>应用</strong></p>
<ul>
<li><strong>CMS 垃圾回收器</strong>：HotSpot 虚拟机里<strong>关注延迟</strong>的 CMS 垃圾回收器是基于<strong>标记-清除算法</strong>的（也会使用<strong>标记-整理算法</strong>）</li>
</ul>
</li>
</ul>
<h3 id="3-标记-复制（Mark-Semispace-Copying）算法"><a href="#3-标记-复制（Mark-Semispace-Copying）算法" class="headerlink" title="3. 标记-复制（Mark-Semispace Copying）算法"></a>3. 标记-复制（Mark-Semispace Copying）算法</h3><ul>
<li><p><strong>示意图</strong></p>
<p>  <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goyk7jy2d6j30hx0e1q3j.jpg" alt="标记-复制"></p>
</li>
<li><p><strong>思路</strong></p>
<ul>
<li><strong>划分及使用</strong>：将可用内存按容量<strong>划分为大小相等的两块</strong>，每次<strong>只使用</strong>其中的一块</li>
<li><strong>复制并清理</strong>：当这一块的内存用完了，就将还存活着的<strong>对象复制</strong>到另外一块上面，然后再把已使用过的内存空间<strong>统一清理</strong></li>
</ul>
</li>
<li><p><strong>优点</strong></p>
<ul>
<li>避免了标记-清除算法的<strong>执行效率低</strong>的问题：内存回收时，每次只针对整个半区进行内存回收操作</li>
<li>避免了标记-清除算法的<strong>内存碎片化</strong>的问题：内存分配时，只需要移动堆顶指针，按顺序分配即可</li>
</ul>
</li>
<li><p><strong>缺点</strong></p>
<ul>
<li><strong>空间浪费</strong>：可用内存缩小为原来的一半</li>
<li><strong>复制开销</strong>：如果内存中多数对象都是存活的，会产生大量的内存复制开销</li>
</ul>
</li>
<li><p><strong>应用</strong></p>
<ul>
<li><strong>回收新生代</strong>：现在的商用 Java 虚拟机大多都采用标记-复制算法（及优化算法）回收新生代</li>
</ul>
</li>
<li><p><strong>优化：Appel 式回收策略</strong></p>
<ul>
<li><strong>原因</strong>：新生代中 <strong>98%</strong> 的对象都是朝生夕灭的，因此<strong>不需要按照 1:1 的比例划分</strong>新生代的内存空间</li>
<li><strong>思路</strong>：把新生代分为一块较大的 <strong>Eden 空间</strong>和两块较小的 <strong>Survivor 空间</strong>，每次内存分配<strong>只使用</strong> Eden 和其中一块 Survivor。发生垃圾回收时，将 Eden 和 Survivor 中仍然存活的对象一次性<strong>复制</strong>到另外一块 Survivor 空间上，然后直接<strong>清理</strong> Eden 和已用过的那块 Survivor 空间</li>
<li><strong>应用</strong>：HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 <strong>8:1</strong>，即只有一个 10% 的 Survivor 新生代内存空间会被浪费。HotSpot 虚拟机的 Serial、ParNew 等新生代垃圾回收器都采用 <strong>Appel 式回收策略</strong>设计新生代的内存布局</li>
<li><strong>安全</strong>：“逃生门”安全设计，即当 Survivor 空间不足以容纳一次 Minor GC 之后存活的对象时，就需要依赖其他内存区域（大多是老年代）进行<strong>分配担保（Handle Promotion）</strong></li>
</ul>
</li>
</ul>
<h3 id="4-标记-整理（Mark-Compact）算法"><a href="#4-标记-整理（Mark-Compact）算法" class="headerlink" title="4. 标记-整理（Mark-Compact）算法"></a>4. 标记-整理（Mark-Compact）算法</h3><ul>
<li><p><strong>示意图</strong></p>
<p>  <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goylo84tw5j30k70e33z1.jpg" alt="标记-整理"></p>
</li>
<li><p><strong>思路</strong></p>
<ul>
<li><strong>标记过程</strong>：仍是判定对象是否属于垃圾的<strong>两次标记过程</strong></li>
<li><strong>整理过程</strong>：不是直接对可回收对象进行清理，而是<strong>让所有存活的对象都向内存空间一端移动</strong>，然后直接<strong>清理边界以外</strong>的内存</li>
</ul>
</li>
<li><p><strong>优点</strong></p>
<ul>
<li>避免了标记-复制算法的<strong>空间浪费</strong>问题：标记-整理是对象<strong>移动式</strong>的算法，不需要额外的空间进行分配担保</li>
<li>避免了标记-复制算法的<strong>复制开销</strong>问题：不需要复制操作，对象存活率较高时，没有复制开销、效率比较高</li>
</ul>
</li>
<li><p><strong>缺点</strong></p>
<ul>
<li><strong>操作复杂</strong>：移动存活对象并<strong>更新所有引用</strong>是一种<strong>极为负重</strong>的操作（但从整个程序的<strong>吞吐量</strong>的角度，移动对象会更划算）</li>
<li><strong>“Stop The World”</strong>：移动对象操作必须<strong>全程暂停</strong>应用程序（最新的 ZGC 和 Shenandoah 垃圾回收器使用 <strong>Read Barrier 读屏障</strong>技术实现了整理过程与用户线程的并发执行）</li>
</ul>
</li>
<li><p><strong>应用</strong></p>
<ul>
<li><strong>Parallel Scavenge 垃圾回收器</strong>：HotSpot 虚拟机里<strong>关注吞吐量</strong>的 Parallel Scavenge 垃圾回收器是基于<strong>标记-整理算法</strong>的</li>
<li><strong>CMS 垃圾回收器</strong>：虚拟机平时多数时间采用<strong>标记-清除算法</strong>，暂时容忍内存碎片的存在。直到内存空间的碎片化程度已经大到影响对象内存分配时，再采用<strong>标记-整理算法</strong>回收一次，以获得规整的内存空间</li>
</ul>
</li>
</ul>
<h2 id="四-Class-类文件结构概述"><a href="#四-Class-类文件结构概述" class="headerlink" title="四. Class 类文件结构概述"></a>四. Class 类文件结构概述</h2><h3 id="1-Class-文件概述"><a href="#1-Class-文件概述" class="headerlink" title="1. Class 文件概述"></a>1. Class 文件概述</h3><ul>
<li><p><strong>Class 文件</strong></p>
<ul>
<li>是一组以 8 个字节为基础单位的<strong>二进制流</strong>，各个数据项目严格按照顺序紧凑排列在文件之中，<strong>中间没有添加任何分隔符</strong></li>
<li>这使得整个 Class 文件中存储的内容几乎全部是程序运行的<strong>必要数据</strong>，没有空隙存在</li>
</ul>
</li>
<li><p><strong>Class 文件格式</strong>：采用一种类似于 C 语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”</p>
<ul>
<li><strong>无符号数</strong>：属于基本的<strong>数据类型</strong>，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数。无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值</li>
<li><strong>表</strong>：是由多个无符号数或者其他表作为数据项构成的<strong>复合数据类型</strong>，为了便于区分，所有的表的命名都习惯性地以 <strong>“info”</strong> 结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上也可以视作一张表</li>
</ul>
</li>
<li><p><strong>Class 文件格式数据项</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u4</td>
<td align="center">magic</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">minor_version</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">major_version</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">constant_pool_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">cp_info</td>
<td align="center">constant_pool</td>
<td align="center">constant_pool_count-1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">access_flags</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">this_class</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">super_class</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">interfaces_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">interfaces</td>
<td align="center">interfaces_count</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">fields_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">field_info</td>
<td align="center">fields</td>
<td align="center">fields_count</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">methods_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">method_info</td>
<td align="center">methods</td>
<td align="center">methods_count</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td align="center">attributes</td>
<td align="center">attributes_count</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-魔数与-Class-文件的版本"><a href="#2-魔数与-Class-文件的版本" class="headerlink" title="2. 魔数与 Class 文件的版本"></a>2. 魔数与 Class 文件的版本</h3><ul>
<li><strong>魔数（Magic Number）</strong><ul>
<li>每个 Class 文件的前 4 个字节，它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接受的 Class 文件</strong>，起到一个<strong>身份标识</strong>的作用</li>
<li>Java 虚拟机中 Class 文件的魔数取名为 <strong>0xCAFEBABE</strong></li>
</ul>
</li>
<li><strong>Class 文件的版本</strong>：魔数后面的 4 个字节存储的是 Class 文件的版本号<ul>
<li>第 5 和第 6 个字节是<strong>次版本号（Minor Version）</strong>，第 7 和第 8 个字节是<strong>主版本号（Major Version）</strong></li>
<li>Java 的版本号是从 <strong>45</strong> 开始的，JDK 1.1 之后的每个 JDK 大版本发布主版本号向上加 1（JDK 1.0 ~ JDK 1.1 使用了 45.0 ~ 45.3 的版本号）</li>
<li>高版本的 JDK <strong>只能向下兼容</strong>以前版本的 Class 文件，但不能运行以后版本的 Class 文件。《Java 虚拟机规范》在 Class 文件校验部分明确要求及时文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的 Class 文件</li>
</ul>
</li>
</ul>
<h3 id="3-常量池"><a href="#3-常量池" class="headerlink" title="3. 常量池"></a>3. 常量池</h3><ul>
<li><p><strong>常量池</strong></p>
<ul>
<li>主、此版本号之后的是常量池入口，可以比喻为 Class 文件里的<strong>资源仓库</strong></li>
<li>常量池是 Class 文件结构中与其他项目<strong>关联最多</strong>的数据，通常也是占用 Class 文件<strong>空间最大</strong>的数据项目之一。另外，<strong>它还是在 Class 文件中第一个出现的表类型数据项目</strong></li>
</ul>
</li>
<li><p><strong>常量池的内容</strong></p>
<ul>
<li><strong>字面量（Literal）</strong>：比较接近 Java 语言层面的常量概念，如文本字符串、被声明为 <code>final</code> 的常量值等</li>
<li><strong>符号引用（Symbolic Reference）</strong>：属于编译原理方面的概念，主要包括下面几类常量<ul>
<li>被模块导出或者开放的包（Package）</li>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
<li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li>
<li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>常量池的项目类型</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">标志</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CONSTANT_Utf8_info</td>
<td align="center">1</td>
<td align="center">UTF-8 编码的字符串</td>
</tr>
<tr>
<td align="center">CONSTANT_Integer_info</td>
<td align="center">3</td>
<td align="center">整型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Float_info</td>
<td align="center">4</td>
<td align="center">浮点型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Long_info</td>
<td align="center">5</td>
<td align="center">长整型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Double_info</td>
<td align="center">6</td>
<td align="center">双精度浮点型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Class_info</td>
<td align="center">7</td>
<td align="center">类或接口的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_String_info</td>
<td align="center">8</td>
<td align="center">字符串类型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Fieldref_info</td>
<td align="center">9</td>
<td align="center">字段的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_Methodref_info</td>
<td align="center">10</td>
<td align="center">类中方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_InterfaceMethodref_info</td>
<td align="center">11</td>
<td align="center">接口中方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_NameAndType_info</td>
<td align="center">12</td>
<td align="center">字段或方法的部分符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodHandle_info</td>
<td align="center">15</td>
<td align="center">表示方法句柄</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodType_info</td>
<td align="center">16</td>
<td align="center">表示方法类型</td>
</tr>
<tr>
<td align="center">CONSTANT_Dynamic_info</td>
<td align="center">17</td>
<td align="center">表示一个动态计算常量</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="4-访问标志"><a href="#4-访问标志" class="headerlink" title="4. 访问标志"></a>4. 访问标志</h3><ul>
<li><p><strong>访问标志（access_flags）</strong></p>
<ul>
<li>用于识别一些类或者接口层次的<strong>访问信息</strong></li>
<li>包括：<strong>这个 <code>Class</code> 是类还是接口</strong>；是否定义为 <code>public</code> 类型；是否定义为 <code>abstract</code> 类型；如果是类的话，是否被声明为 <code>final</code> 等</li>
</ul>
</li>
<li><p><strong>访问标志位</strong></p>
<table>
<thead>
<tr>
<th align="center">标志名称</th>
<th align="center">标志值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ACC_PUBLIC</td>
<td align="center">0x0001</td>
<td align="center">是否为 public 类型</td>
</tr>
<tr>
<td align="center"><strong>ACC_FINAL</strong></td>
<td align="center">0x0010</td>
<td align="center"><strong>是否被声明为 final，只有类可设置（只针对类和接口而言）</strong></td>
</tr>
<tr>
<td align="center">ACC_SUPER</td>
<td align="center">0x0020</td>
<td align="center">是否允许使用 invokespecial 字节码指令的新语义，invokespecial 指令的语义在 JDK 1.0.2 发生过改变，为了区分这条指令使用哪种语义，JDK 1.0.2 之后编译出来的类的这个标志都必须为真</td>
</tr>
<tr>
<td align="center">ACC_INTERFACE</td>
<td align="center">0x0200</td>
<td align="center">标识这是一个接口</td>
</tr>
<tr>
<td align="center">ACC_ABSTRACT</td>
<td align="center">0x0400</td>
<td align="center">是否为 abstract 类型，对于接口或者抽象类来说，此标志为真，其他类型值为假</td>
</tr>
<tr>
<td align="center"><strong>ACC_SYNTHETIC</strong></td>
<td align="center">0x1000</td>
<td align="center"><strong>标识这个类并非由用户代码产生</strong></td>
</tr>
<tr>
<td align="center">ACC_ANNOTATION</td>
<td align="center">0x2000</td>
<td align="center">标识这是一个注解</td>
</tr>
<tr>
<td align="center">ACC_ENUM</td>
<td align="center">0x4000</td>
<td align="center">标识这是一个枚举</td>
</tr>
<tr>
<td align="center"><strong>ACC_MODULE</strong></td>
<td align="center">0x8000</td>
<td align="center"><strong>标识这是一个模块</strong></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="5-类索引、父类索引与接口索引集合"><a href="#5-类索引、父类索引与接口索引集合" class="headerlink" title="5. 类索引、父类索引与接口索引集合"></a>5. 类索引、父类索引与接口索引集合</h3><ul>
<li><strong>类索引（<code>this_class</code>）</strong>和<strong>父类索引（<code>super_class</code>）</strong>都是一个 u2 类型的数据。<strong>接口索引集合（<code>interfaces</code>）</strong>是一组 u2 类型的数据的集合，<strong>Class 文件中由这三项数据来确定该类型的继承关系</strong></li>
<li><strong>类索引</strong>：用于确定这个类的全限定名</li>
<li><strong>父类索引</strong>：用于确定这个类的父类的全限定名</li>
<li><strong>接口索引</strong>：用于描述这个类实现了哪些接口，这些被实现的接口将按 <code>implements</code> 关键字（如果这个索引集合表示的是一个类，则应当是 <code>extends</code> 关键字）后的接口顺序从做到右排列在接口索引集合中</li>
</ul>
<h3 id="6-字段表集合"><a href="#6-字段表集合" class="headerlink" title="6. 字段表集合"></a>6. 字段表集合</h3><ul>
<li><p><strong>字段表（field_info）</strong>用于描述接口或者类中声明的变量。Java 语言中的<strong>字段（Field）</strong>包括类级变量（静态变量）以及实例级变量，但不包括在方法内部声明的局部变量。Java 语言中的字段可以包括的<strong>修饰符</strong>有以下几种</p>
<ul>
<li><strong><code>public/private/protected</code></strong>：字段的作用域</li>
<li><strong><code>static</code></strong>：是实例变量还是类变量</li>
<li><strong><code>final</code></strong>：可变性</li>
<li><strong><code>volatile</code></strong>：并发可见性，是否强制从主内存读写</li>
<li><strong><code>transient</code></strong>：可否被序列化</li>
<li><strong>字段数据类型</strong>：基本数据类型、对象、数组</li>
</ul>
</li>
<li><p><strong>字段表结构</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">access_flags</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">name_index</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">descriptor_index</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td align="center">attributes</td>
<td align="center">attributes_count</td>
</tr>
</tbody></table>
</li>
<li><p><strong>字段访问标志位</strong></p>
<table>
<thead>
<tr>
<th align="center">标志名称</th>
<th align="center">标志值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ACC_PUBLIC</td>
<td align="center">0x0001</td>
<td align="center">字段是否 public</td>
</tr>
<tr>
<td align="center">ACC_PRIVATE</td>
<td align="center">0x0002</td>
<td align="center">字段是否 private</td>
</tr>
<tr>
<td align="center">ACC_PROTECTED</td>
<td align="center">0x0004</td>
<td align="center">字段是否 protected</td>
</tr>
<tr>
<td align="center">ACC_STATIC</td>
<td align="center">0x0008</td>
<td align="center">字段是否 static</td>
</tr>
<tr>
<td align="center">ACC_FINAL</td>
<td align="center">0x0010</td>
<td align="center">字段是否 final</td>
</tr>
<tr>
<td align="center">ACC_VOLATILE</td>
<td align="center">0x0040</td>
<td align="center">字段是否 volatile</td>
</tr>
<tr>
<td align="center">ACC_TRANSIENT</td>
<td align="center">0x0080</td>
<td align="center">字段是否 transient</td>
</tr>
<tr>
<td align="center"><strong>ACC_SYNTHETIC</strong></td>
<td align="center">0x1000</td>
<td align="center"><strong>字段是否由编译器自动产生</strong></td>
</tr>
<tr>
<td align="center"><strong>ACC_ENUM</strong></td>
<td align="center">0x4000</td>
<td align="center"><strong>字段是否 enum</strong></td>
</tr>
</tbody></table>
<ul>
<li><strong><code>ACC_FINAL</code> 和 <code>ACC_VOLATILE</code> 不能同时选择</strong></li>
<li><strong>接口之中的字段必须有 <code>ACC_PUBLIC</code>、<code>ACC_STATIC</code>、<code>ACC_FINAL</code> 标志</strong></li>
<li><strong>Java 语言中字段是无法重载的</strong>，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称</li>
</ul>
</li>
</ul>
<h3 id="7-方法表集合"><a href="#7-方法表集合" class="headerlink" title="7. 方法表集合"></a>7. 方法表集合</h3><ul>
<li><p><strong>方法表</strong>的结构如同字段表一样，依次包括<strong>访问标志（<code>access_flags</code>）</strong>、<strong>名称索引（<code>name_index</code>）</strong>、<strong>描述符索引（<code>descriptor_index</code>）</strong>、<strong>属性表集合（<code>attributes</code>）</strong></p>
</li>
<li><p><strong>方法表的结构</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">access_flags</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">name_index</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">descriptor_index</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">atrribute_info</td>
<td align="center">attributes</td>
<td align="center">attributes_count</td>
</tr>
</tbody></table>
<ul>
<li><strong><code>volatile</code> 关键字和 <code>transient</code> 关键字不能修饰方法</strong></li>
</ul>
</li>
<li><p><strong>方法访问标志位</strong></p>
<table>
<thead>
<tr>
<th align="center">标志名称</th>
<th align="center">标志值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ACC_PUBLIC</td>
<td align="center">0x0001</td>
<td align="center">方法是否为 public</td>
</tr>
<tr>
<td align="center">ACC_PRIVATE</td>
<td align="center">0x0002</td>
<td align="center">方法是否为 private</td>
</tr>
<tr>
<td align="center">ACC_PROTECTED</td>
<td align="center">0x0004</td>
<td align="center">方法是否为 protected</td>
</tr>
<tr>
<td align="center">ACC_STATIC</td>
<td align="center">0x0008</td>
<td align="center">方法是否为 static</td>
</tr>
<tr>
<td align="center">ACC_FINAL</td>
<td align="center">0x0010</td>
<td align="center">方法是否为 final</td>
</tr>
<tr>
<td align="center">ACC_SYNCHRONIZED</td>
<td align="center">0x0020</td>
<td align="center">方法是否为 synchronized</td>
</tr>
<tr>
<td align="center"><strong>ACC_BRIDGE</strong></td>
<td align="center">0x0040</td>
<td align="center"><strong>方法是不是由编译器产生的桥接方法</strong></td>
</tr>
<tr>
<td align="center"><strong>ACC_VARARGS</strong></td>
<td align="center">0x0080</td>
<td align="center"><strong>方法是否接收不定参数</strong></td>
</tr>
<tr>
<td align="center">ACC_NATIVE</td>
<td align="center">0x0100</td>
<td align="center">方法是否为 native</td>
</tr>
<tr>
<td align="center">ACC_ABSTRACT</td>
<td align="center">0x0400</td>
<td align="center">方法是否为 abstract</td>
</tr>
<tr>
<td align="center"><strong>ACC_STATIC</strong></td>
<td align="center">0x0800</td>
<td align="center"><strong>方法是否为 strictfp</strong></td>
</tr>
<tr>
<td align="center"><strong>ACC_SYNTHETIC</strong></td>
<td align="center">0x1000</td>
<td align="center"><strong>方法是否为编译器自动产生</strong></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="8-属性表集合"><a href="#8-属性表集合" class="headerlink" title="8. 属性表集合"></a>8. 属性表集合</h3><ul>
<li><p><strong>属性表（attribute_info）</strong>：Class 文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息</p>
</li>
<li><p>与 Class 文件中其他的数据项目要求严格的顺序、长度和内容不同，<strong>属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格顺序</strong>。《Java 虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，<strong>Java 虚拟机运行时会忽略掉它不认识的属性</strong>。同时，<strong>Java 程序方法体里面的代码经过 Javac 编译器处理之后，最终变为字节码指令存储在 Code 属性内</strong></p>
</li>
<li><p><strong>Code 属性表的结构</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">attribute_name_index</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u4</td>
<td align="center">attribute_length</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">max_stack</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">max_locals</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u4</td>
<td align="center">code_length</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u1</td>
<td align="center">code</td>
<td align="center">code_length</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">exception_table_length</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">exception_info</td>
<td align="center">exception_table</td>
<td align="center">exception_table_length</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td align="center">attributes</td>
<td align="center">attributes_count</td>
</tr>
</tbody></table>
<ul>
<li><strong><code>max_stack</code></strong>：代表了<strong>操作数栈（Operand Stack）</strong>深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配<strong>栈帧（Stack Frame）</strong>中的操作栈深度</li>
<li><strong><code>max_locals</code></strong> 代表了<strong>局部变量表</strong>所需的存储空间。在这里，<strong><code>max_locals</code> 的单位是变量槽（Slot），变量槽是虚拟机为局部变量分配内存所使用的最小单位</strong></li>
</ul>
</li>
<li><p><strong>Code 属性是 Class 文件中最重要的一个属性</strong>。如果可以把一个 Java 程序中的信息分为<strong>代码（Code，方法体里的 Java 代码）</strong>和<strong>元数据（Metadata，包括类、字段、方法定义及其他信息）</strong>两部分，那么在整个 Class 文件里，Code 属性用于<strong>描述代码</strong>，所有的其他数据项目都用于<strong>描述元数据</strong></p>
</li>
</ul>
<h2 id="五-JVM-类加载机制概述"><a href="#五-JVM-类加载机制概述" class="headerlink" title="五. JVM 类加载机制概述"></a>五. JVM 类加载机制概述</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><ul>
<li><strong>虚拟机的类加载机制</strong>：Java 虚拟机把描述类的数据从 <strong>Class 文件</strong>加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 <strong>Java 类型</strong></li>
</ul>
<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4><ul>
<li>在 Java 语言里，类型的加载、连接和初始化过程都是在<strong>程序运行期间</strong>完成的</li>
</ul>
<h4 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h4><ul>
<li>为 Java 应用提供了极高的<strong>扩展性</strong>和<strong>灵活性</strong>，Java 天生可以动态扩展的语言特性就是依赖运行期<strong>动态加载</strong>和<strong>动态连接</strong>实现</li>
</ul>
<h4 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4. 缺点"></a>4. 缺点</h4><ul>
<li>让 Java 语言进行<strong>提前编译</strong>会面临额外的困难，也会让类加载时稍微增加一些<strong>性能开销</strong></li>
</ul>
<h4 id="5-应用"><a href="#5-应用" class="headerlink" title="5. 应用"></a>5. 应用</h4><ul>
<li><strong>动态组装应用</strong>的方式目前已广泛应用于 Java 程序之中，从最基础的 Applet、JSP 到相对复杂的 OSGi 技术，都依赖着 Java 语言<strong>运行期类加载</strong>才得以诞生</li>
</ul>
<h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h4><ul>
<li>代码编译的结果从<strong>本地机器码</strong>转变为<strong>字节码</strong>，是存储格式发展的一小步，却是编程语言发展的一大步</li>
</ul>
<h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><h4 id="1-类的生命周期"><a href="#1-类的生命周期" class="headerlink" title="1. 类的生命周期"></a>1. 类的生命周期</h4><ul>
<li><p><strong>示意图</strong></p>
<p>  <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp1xror1qsj30r80bnjs5.jpg" alt="类的生命周期"></p>
</li>
<li><p><strong>概述</strong></p>
<ul>
<li>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历<strong>加载（Loading）</strong>、<strong>验证（Verification）</strong>、<strong>准备（Preparation）</strong>、<strong>解析（Resolution）</strong>、<strong>初始化（Initialization）</strong>、<strong>使用（Using）</strong>、<strong>卸载（Unloading）</strong> 七个阶段。其中，验证、准备、解析三个阶段统称为<strong>连接（Linking）</strong></li>
<li>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班开始，<strong>而解析阶段则不一定</strong>：它在某些情况下可以在<strong>初始化阶段之后</strong>再开始，这是为了支持 Java 语言的<strong>运行时绑定</strong>特性（也称为动态绑定或晚期绑定）</li>
<li>按部就班开始并不是按部就班进行或按部就班完成的意思，这些节点通常都是<strong>互相交叉混合进行</strong>的，会在一个阶段执行的过程中调用、激活另一个阶段。需要注意的是，<strong>第一个阶段加载（Loading）在《Java 虚拟机规范》中并没有进行强制约束，可以交给虚拟机的具体实现来自由把握</strong></li>
</ul>
</li>
<li><p><strong>有且只有的需要开始初始化操作的六种情况</strong>：加载、验证、准备自然要在此之前开始</p>
<ol>
<li><p>遇到 <strong>new</strong>、<strong>getstatic</strong>、<strong>putstatic</strong> 或 <strong>invokestatic</strong> 这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型 Java 代码场景有</p>
<ul>
<li>使用 <strong><code>new</code> 关键字</strong>实例化对象的时候</li>
<li>读取或设置一个类型的<strong>静态字段</strong>（被 <strong><code>final</code></strong> 修饰、已在编译期把结果放入常量池的静态字段除外）的时候</li>
<li>调用一个类型的<strong>静态方法</strong>的时候</li>
</ul>
</li>
<li><p>使用 <strong><code>java.lang.reflect</code></strong> 包的方法对类型进行<strong>反射调用</strong>的时候，如果类型没有进行过初始化，则需要先触发其初始化</p>
</li>
<li><p>当初始化类的时候，如果发现其父类还没有进行过初始化，则<strong>需要先触发其父类的初始化</strong></p>
</li>
<li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 <strong><code>main()</code></strong> 方法的那个类），<strong>虚拟机会先初始化这个主类</strong></p>
</li>
<li><p>当使用  <strong>JDK 7 新加入的动态语言支持</strong>时，如果一个 <strong><code>java.lang.invoke.MethodHandle</code> 实例</strong>最后的解析结果为 <code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>、<code>REF_newInvokeSpecial</code> 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化</p>
</li>
<li><p>当一个接口中定义了 <strong>JDK 8 新加入的默认方法</strong>（被 <strong><code>default</code></strong> 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化（<del>是不是可以写一个这个版本的单例模式</del>）</p>
</li>
</ol>
</li>
<li><p><strong>被动引用</strong></p>
<ul>
<li><p>概念</p>
<ul>
<li>《Java 虚拟机规范》中规定的<strong>六种</strong>必须立即进行初始化场景中的行为称为<strong>对一个类型进行主动引用</strong>。除此之外，所有引用类型的方式都不会触发初始化，成为<strong>被动引用</strong></li>
</ul>
</li>
<li><p>Demo 1：<strong>通过子类引用父类的静态字段，不会导致子类初始化</strong></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package org.fenixsoft.classloading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SuperClass</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"SuperClass init!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">value</span> = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SubClass</span> <span class="title">extends</span> <span class="title">SuperClass</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"SubClass init!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NotInitialization</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(SubClass.<span class="keyword">value</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>运行结果</strong>：只会输出 <code>&quot;SuperClass init!&quot;</code>，不会输出 <code>&quot;SubClass init!&quot;</code></li>
<li><strong>对于静态字段，只有直接定义这个字段的类才会被初始化</strong>，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化</li>
<li>是否要触发<strong>子类的加载和验证</strong>阶段，在《Java 虚拟机规范》中并未明确规定，取决于虚拟机的具体实现。对于 HotSpot 虚拟机来说，可通过 <code>-XX:+TraceClassLoading</code> 参数观察到此操作是<strong>会导致子类加载</strong>的</li>
</ul>
</li>
<li><p>Demo 2：<strong>通过数组定义来引用类，不会触发此类的初始化</strong></p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.classloading;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	static &#123;</span><br><span class="line">		<span class="type">System</span>.out.println(<span class="string">"SubClass init!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	public static void main(<span class="type">String</span> [] args) &#123;</span><br><span class="line">		<span class="type">SuperClass</span>[] sca = <span class="keyword">new</span> <span class="type">SuperClass</span>[<span class="number">10</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>运行结果</strong>：没有输出 <code>&quot;SuperClass init!&quot;</code>，说明并没有触发 <code>org.fenixsoft.classloading.SuperClass</code> 的初始化阶段</li>
<li>但是这段代码触发了另一个名为 <strong><code>Lorg.fenixsoft.classloading.SuperClass</code></strong> 的类的初始化。对于用户来说，这并不是一个合法的类型名称，它是一个由虚拟机自动生成的、直接继承于 <code>java.lang.Object</code> 的子类，<strong>创建动作由字节码指令 <code>newarray</code> 触发</strong></li>
</ul>
</li>
<li><p>Demo 3：<strong>常量在编译阶段会存入调用类的常量池，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</strong></p>
  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package org.fennixsoft.classloading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> &#123;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"ConstClass init!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> HELLOWORLD = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> &#123;</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(ConstClass.HELLOWORLD);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>运行结果</strong>：没有输出 <code>ConstClass init!</code></li>
<li>虽然在代码中确实引用了 <code>ConstClass</code> 类的常量 <code>HELLOWORLD</code>，但其实<strong>在编译阶段通过常量传播优化</strong>，已经将此常量的值 <code>hello world</code> 直接存储在 <code>NotInitialization</code> 类的常量池中，以后 <code>NotInitialization</code> 对常量 <code>ConstClass.HELLOWORLD</code> 的引用，实际都被转化为 <code>NotInitialization</code> 类对自身常量池的引用</li>
<li>实际上 <code>NotInitialization</code> 的 Class 文件之中并没有 <code>ConstClass</code> 类的<strong>符号引用入口</strong>，<strong>这两个类在编译成 Class 文件后就已不存在任何联系了</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>接口的加载过程</strong></p>
<ul>
<li>接口也有初始化过程，这一点是与类一致的，上面的代码都是用静态代码语句块 <code>static{}</code> 来输出初始化信息的，而<strong>接口中不能使用 <code>static{}</code> 语句块</strong>。但<strong>编译器仍然会为接口生成 <code>&lt;clinit&gt;()</code> 类构造器</strong>，用于初始化接口中所定义的成员变量</li>
<li>接口与类真正有所区别的是前面讲述的<strong>六种“有且仅有”场景中的第三种</strong>：当一个类在初始化时，要求其父类全部都已经初始化过了，但是<strong>一个接口在初始化时，并不要求其父接口全部都完成初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化</strong>    </li>
</ul>
</li>
</ul>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h3 id="Java-模块化系统"><a href="#Java-模块化系统" class="headerlink" title="Java 模块化系统"></a>Java 模块化系统</h3><h2 id="六-Java-内存模型概述"><a href="#六-Java-内存模型概述" class="headerlink" title="六. Java 内存模型概述"></a>六. Java 内存模型概述</h2>
    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;margin-top:80px">-------------------- 本文结束<i class="fa fa-paw"></i>感谢您的阅读 --------------------</div>
    
</div>
      
    </div>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>隋钟元
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://24suixinsuoyu.com/2020/04/10/Java-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="Java 编程基础（七）：深入理解 Java 虚拟机">http://24suixinsuoyu.com/2020/04/10/Java-编程基础（七）：深入理解-Java-虚拟机/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> 编程基础</a>
              <a href="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag"><i class="fa fa-tag"></i> 深入理解 Java 虚拟机</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/10/Java-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%96%B9%E6%B3%95%E5%8F%8A%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/" rel="prev" title="Java 编程基础（六）：方法及方法调用">
      <i class="fa fa-chevron-left"></i> Java 编程基础（六）：方法及方法调用
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/11/Java-%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80/" rel="next" title="Java 理解数据背后的二进制（一）：二进制基础">
      Java 理解数据背后的二进制（一）：二进制基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-JVM-运行时数据区域概述"><span class="nav-text">一. JVM 运行时数据区域概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-概述"><span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-示意图"><span class="nav-text">2. 示意图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-线程私有内存"><span class="nav-text">3. 线程私有内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-程序计数器（Program-Counter-Register）"><span class="nav-text">3.1 程序计数器（Program Counter Register）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-Java-虚拟机栈（JVM-Stack）"><span class="nav-text">3.2 Java 虚拟机栈（JVM Stack）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-本地方法栈（Native-Method-Stack）"><span class="nav-text">3.3 本地方法栈（Native Method Stack）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-线程共享内存"><span class="nav-text">4. 线程共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-堆（Heap）"><span class="nav-text">4.1 堆（Heap）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-方法区（Method-Area）"><span class="nav-text">4.2 方法区（Method Area）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-运行时常量池（Runtime-Constant-Pool）"><span class="nav-text">4.3 运行时常量池（Runtime Constant Pool）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-直接内存（Direct-Memory）"><span class="nav-text">5. 直接内存（Direct Memory）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-垃圾回收判定算法及四种引用概述"><span class="nav-text">二. 垃圾回收判定算法及四种引用概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-概述-1"><span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-引用计数（Reference-Counting）算法"><span class="nav-text">2. 引用计数（Reference Counting）算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-思路"><span class="nav-text">2.1 思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-优点"><span class="nav-text">2.2 优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-缺点"><span class="nav-text">2.3 缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-应用"><span class="nav-text">2.4 应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-可达性分析（Reachability-Analysis）算法"><span class="nav-text">3. 可达性分析（Reachability Analysis）算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-示意图"><span class="nav-text">3.1 示意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-思路"><span class="nav-text">3.2 思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-应用"><span class="nav-text">3.3 应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-GC-Roots-对象"><span class="nav-text">3.4 GC Roots 对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-四种引用类型概述"><span class="nav-text">4. 四种引用类型概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-强引用（Strong-Reference）"><span class="nav-text">4.1 强引用（Strong Reference）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-软引用（Soft-Reference）"><span class="nav-text">4.2 软引用（Soft Reference）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-弱引用（Weak-Reference）"><span class="nav-text">4.3 弱引用（Weak Reference）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-虚引用（Phantom-Reference）"><span class="nav-text">4.4 虚引用（Phantom Reference）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-两次标记过程与垃圾回收方法调用概述"><span class="nav-text">5. 两次标记过程与垃圾回收方法调用概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-两次标记过程"><span class="nav-text">5.1 两次标记过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-finalize-方法概述"><span class="nav-text">5.2 finalize() 方法概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-gc-方法概述"><span class="nav-text">5.3 gc() 方法概述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-方法区内存回收概述"><span class="nav-text">6. 方法区内存回收概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-常量回收"><span class="nav-text">6.1 常量回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-类型卸载"><span class="nav-text">6.2 类型卸载</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-垃圾回收算法概述"><span class="nav-text">三. 垃圾回收算法概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-分代回收理论概述"><span class="nav-text">1. 分代回收理论概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-标记-清除（Mark-Sweep）算法"><span class="nav-text">2. 标记-清除（Mark-Sweep）算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-标记-复制（Mark-Semispace-Copying）算法"><span class="nav-text">3. 标记-复制（Mark-Semispace Copying）算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-标记-整理（Mark-Compact）算法"><span class="nav-text">4. 标记-整理（Mark-Compact）算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四-Class-类文件结构概述"><span class="nav-text">四. Class 类文件结构概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Class-文件概述"><span class="nav-text">1. Class 文件概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-魔数与-Class-文件的版本"><span class="nav-text">2. 魔数与 Class 文件的版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-常量池"><span class="nav-text">3. 常量池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-访问标志"><span class="nav-text">4. 访问标志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-类索引、父类索引与接口索引集合"><span class="nav-text">5. 类索引、父类索引与接口索引集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-字段表集合"><span class="nav-text">6. 字段表集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-方法表集合"><span class="nav-text">7. 方法表集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-属性表集合"><span class="nav-text">8. 属性表集合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五-JVM-类加载机制概述"><span class="nav-text">五. JVM 类加载机制概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-概念"><span class="nav-text">1. 概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-特点"><span class="nav-text">2. 特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-优点"><span class="nav-text">3. 优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-缺点"><span class="nav-text">4. 缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-应用"><span class="nav-text">5. 应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-总结"><span class="nav-text">6. 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载时机"><span class="nav-text">类加载时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-类的生命周期"><span class="nav-text">1. 类的生命周期</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载过程"><span class="nav-text">类加载过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载器"><span class="nav-text">类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-模块化系统"><span class="nav-text">Java 模块化系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六-Java-内存模型概述"><span class="nav-text">六. Java 内存模型概述</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="隋钟元"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">隋钟元</p>
  <div class="site-description" itemprop="description">技术创造价值</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">340</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">465</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:24suixinsuoyu@gmail.com" title="E-Mail → mailto:24suixinsuoyu@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/24suixinsuoyu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;24suixinsuoyu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/24sxsy" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;24sxsy" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/guolin_blog" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;guolin_blog" rel="noopener" target="_blank">郭霖</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/lmj623565791/" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;lmj623565791&#x2F;" rel="noopener" target="_blank">鸿洋</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.520monkey.com/" title="http:&#x2F;&#x2F;www.520monkey.com&#x2F;" rel="noopener" target="_blank">姜维</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://daimajia.com/" title="https:&#x2F;&#x2F;daimajia.com&#x2F;" rel="noopener" target="_blank">代码家</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://kmxz.net/" title="https:&#x2F;&#x2F;kmxz.net&#x2F;" rel="noopener" target="_blank">孔祥舟</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://yangwenbo.com/" title="http:&#x2F;&#x2F;yangwenbo.com&#x2F;" rel="noopener" target="_blank">杨文博</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">隋钟元</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">1.4m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">21:25</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>

