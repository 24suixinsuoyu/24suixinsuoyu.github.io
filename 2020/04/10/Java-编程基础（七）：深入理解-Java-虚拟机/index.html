<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"24suixinsuoyu.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一. JVM 运行时数据区域概述">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 编程基础（七）：深入理解 Java 虚拟机">
<meta property="og:url" content="http://24suixinsuoyu.com/2020/04/10/Java-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/index.html">
<meta property="og:site_name" content="隋钟元’s Blog">
<meta property="og:description" content="一. JVM 运行时数据区域概述">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1goxbdwj50qj30s608o0tw.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1goxnz5s7uzj30jx09lq36.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1goyjmnbs41j30ju0cfglx.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1goyk7jy2d6j30hx0e1q3j.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1goylo84tw5j30k70e33z1.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1gp1xror1qsj30r80bnjs5.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gp37q7qrvjj30dn0gh0u0.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gp3bqjp8kaj30sg0lc48y.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1gp3kukyavcj30rq0cktcu.jpg">
<meta property="article:published_time" content="2020-04-10T02:17:30.000Z">
<meta property="article:modified_time" content="2021-03-31T19:02:40.082Z">
<meta property="article:author" content="隋钟元">
<meta property="article:tag" content="编程基础">
<meta property="article:tag" content="深入理解 Java 虚拟机">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1goxbdwj50qj30s608o0tw.jpg">

<link rel="canonical" href="http://24suixinsuoyu.com/2020/04/10/Java-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>Java 编程基础（七）：深入理解 Java 虚拟机 | 隋钟元’s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">隋钟元’s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-university"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th-list"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-english">

    <a href="/english/" rel="section"><i class="fa fa-fw fa-graduation-cap"></i>英语</a>

  </li>
        <li class="menu-item menu-item-life">

    <a href="/life/" rel="section"><i class="fa fa-fw fa-balance-scale"></i>生活</a>

  </li>
        <li class="menu-item menu-item-resume">

    <a href="/resume/" rel="section"><i class="fa fa-fw fa-user-circle-o"></i>简历</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/commonweal/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/24suixinsuoyu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://24suixinsuoyu.com/2020/04/10/Java-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="隋钟元">
      <meta itemprop="description" content="技术创造价值">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="隋钟元’s Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 编程基础（七）：深入理解 Java 虚拟机
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-10 10:17:30" itemprop="dateCreated datePublished" datetime="2020-04-10T10:17:30+08:00">2020-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-01 03:02:40" itemprop="dateModified" datetime="2021-04-01T03:02:40+08:00">2021-04-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E3%80%8AJava-%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E3%80%8B/" itemprop="url" rel="index"><span itemprop="name">《Java 编程的逻辑》</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>31k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>28 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="一-JVM-运行时数据区域概述"><a href="#一-JVM-运行时数据区域概述" class="headerlink" title="一. JVM 运行时数据区域概述"></a>一. JVM 运行时数据区域概述</h2><a id="more"></a>

<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><ul>
<li>Java 虚拟机在执行 Java 程序的过程中会把它所管理的<strong>内存划分</strong>为若干个不同的数据区域</li>
<li>这些区域分为两部分，一部分是<strong>线程私有</strong>的，另一部分是<strong>线程公有</strong>的</li>
</ul>
<h3 id="2-示意图"><a href="#2-示意图" class="headerlink" title="2. 示意图"></a>2. 示意图</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goxbdwj50qj30s608o0tw.jpg" alt="JVM 运行时数据区域示意图"></p>
<h3 id="3-线程私有内存"><a href="#3-线程私有内存" class="headerlink" title="3. 线程私有内存"></a>3. 线程私有内存</h3><h4 id="3-1-程序计数器（Program-Counter-Register）"><a href="#3-1-程序计数器（Program-Counter-Register）" class="headerlink" title="3.1 程序计数器（Program Counter Register）"></a>3.1 程序计数器（Program Counter Register）</h4><ul>
<li>程序计数器是一块<strong>较小的内存空间</strong>，可以看作<strong>当前线程所执行的字节码的行号指示器</strong>。字节码解释器工作时，通过改变程序计数器的值来选取下一条需要执行的字节码指令。它是<strong>程序控制流的指示器</strong>，分支、循环、跳转、异常处理、线程恢复等<strong>基础功能</strong>都需要依赖程序计数器完成</li>
<li>为了<strong>线程切换后能恢复</strong>到正确的位置，<strong>每个线程都需要有独立的程序计数器</strong>。由于每个线程的程序计数器是<strong>独立存储</strong>的，因此各线程之间的程序计数器<strong>互不影响</strong></li>
<li>如果线程正在执行的是一个 <strong>Java 方法</strong>，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 <strong><code>Native</code> 方法</strong>，那么这个计数器的值应为空（<code>Undefined</code>）。<strong>程序计数器是唯一不会出现 <code>OutOfMemoryError</code> 的内存区域</strong></li>
</ul>
<h4 id="3-2-Java-虚拟机栈（JVM-Stack）"><a href="#3-2-Java-虚拟机栈（JVM-Stack）" class="headerlink" title="3.2 Java 虚拟机栈（JVM Stack）"></a>3.2 Java 虚拟机栈（JVM Stack）</h4><ul>
<li><p>和程序计数器一样，Java 虚拟机栈也是<strong>线程私有</strong>的，它的生命周期与线程相同</p>
</li>
<li><p>Java 虚拟机栈描述的是 <strong>Java 方法执行的内存模型</strong></p>
<ul>
<li>每个方法被执行的时候会创建一个<strong>栈帧（Stack Frame）</strong>用于存储：<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法出口</strong>等信息</li>
<li><strong>局部变量表</strong>存放编译器可知的各种：<strong>基本数据类型</strong>、<strong>对象引用 reference 类型</strong>、<strong>返回地址 returnAddres 类型</strong></li>
<li>一个方法<strong>被调用直至执行完成</strong>的过程对应一个栈帧在虚拟机中<strong>从入栈到出栈</strong>的过程</li>
</ul>
</li>
<li><p>Java 虚拟机栈会出现<strong>两种异常</strong></p>
<ul>
<li><p><strong><code>StackOverflowError</code></strong>: 如果虚拟机栈<strong>不可以动态扩展</strong>，当<strong>线程请求的栈深度大于虚拟机所允许的深度</strong>时会抛出该异常</p>
</li>
<li><p><strong><code>OutOfMemoryError</code></strong>: 如果虚拟机栈<strong>可以动态扩展</strong>，当<strong>无法申请到足够的内存</strong>时会抛出该异常</p>
<blockquote>
<p>以前的 Classic 虚拟机栈可以动态扩展，<strong>现在主流的 HotSpot 虚拟机的栈容量不可以动态扩展</strong></p>
<p><strong>HotSpot 虚拟机不会因为无法动态扩展而导致 OOM，只会因为无法申请到足够的内存从而导致 OOM</strong></p>
<p><code>StackOverflowError</code> 更多是在程序刚一开始运行的时候抛出，强调的是<strong>不够用</strong>，一般发生在<strong>栈内存</strong>；<code>OutOfMemoryError</code> 更多是程序运行期间由内存泄漏累积导致抛出，强调的是<strong>被用完</strong>，一般发生在<strong>堆内存</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="3-3-本地方法栈（Native-Method-Stack）"><a href="#3-3-本地方法栈（Native-Method-Stack）" class="headerlink" title="3.3 本地方法栈（Native Method Stack）"></a>3.3 本地方法栈（Native Method Stack）</h4><ul>
<li>本地方法栈和虚拟机栈的作用<strong>非常相似</strong>。区别在于，<strong>虚拟机栈</strong>为虚拟机执行 Java 方法（<strong>字节码</strong>）服务；<strong>本地方法栈</strong>为虚拟机使用到的本地（<strong>Native</strong>）方法服务</li>
<li>具体的虚拟机可以根据需要自由实现本地方法栈，<strong>有的虚拟机（比如 HotSpot）直接把本地方法栈和虚拟机栈合二为一</strong></li>
<li>和虚拟机栈一样，本地方法栈也会在<strong>栈深度溢出</strong>时抛出 <strong><code>StackOverflowError</code></strong> 异常；在<strong>栈扩展失败</strong>时抛出 <strong><code>OutOfMemoryError</code></strong> 异常</li>
</ul>
<h3 id="4-线程共享内存"><a href="#4-线程共享内存" class="headerlink" title="4. 线程共享内存"></a>4. 线程共享内存</h3><h4 id="4-1-堆（Heap）"><a href="#4-1-堆（Heap）" class="headerlink" title="4.1 堆（Heap）"></a>4.1 堆（Heap）</h4><ul>
<li><p>对于 Java 应用程序而言，<strong>Java 堆是虚拟机管理的内存中最大的一块</strong>。Java 堆在虚拟机启动时创建，是被所有<strong>线程共享</strong>的内存区域，其目的是<strong>存放对象实例</strong>，几乎所有的对象实例（包括<strong>数组</strong>）都在堆中分配内存</p>
<blockquote>
<p>需要注意的是，由于即时编译、逃逸分析、栈上分配、标量替换等技术的发展，<strong>Java 对象实例都分配在堆上也渐渐不是那么绝对了</strong></p>
</blockquote>
</li>
<li><p>Java 堆是<strong>垃圾回收器管理</strong>的内存区域，因此也被称为 <strong>GC 堆（Garbage Collected Heap）</strong></p>
<ul>
<li><p>从<strong>回收内存</strong>的角度，由于现代编译器基本都采用<strong>分代垃圾回收算法</strong>，所以 Java 对还可以分为<strong>新生代</strong>和<strong>老年代</strong>，新生代又可以细分成 <code>Eden 空间</code>、<code>From Survivor 空间</code>、<code>To Survivor 空间</code>等</p>
<blockquote>
<p>需要注意的是，这些区域划分只是部分垃圾回收器的<strong>共同特性</strong>或<strong>设计风格</strong>，而非某个 Java 虚拟机具体实现的固有内存布局</p>
<p>随着垃圾回收器技术的发展，<strong>HotSpot 里面也出现了不采用分代设计的新垃圾回收器</strong></p>
</blockquote>
</li>
<li><p>从<strong>分配内存</strong>的角度，所有线程共享的 Java 堆中可以划分出多个<strong>线程私有</strong>的分配缓冲区（Thread Local Allocation Buffer，<strong>TLAB</strong>），以提升对象分配时的效率</p>
</li>
<li><p>Java 堆的作用是存储对象实例，将 Java 堆细分的目的只是为了<strong>更好地回收</strong>内存或者<strong>更快地分配</strong>内存</p>
</li>
</ul>
</li>
<li><p>Java 堆既可以被实现成固定大小的，也可以是可扩展的。当前主流的 Java 虚拟机都是按照<strong>可扩展</strong>来实现的（通过参数 <strong><code>-Xmx</code></strong>和<strong><code>-Xms</code></strong>设定）。如果在 Java 堆中没有内存完成实例分配，并且堆也无法再扩展时，JVM 将抛出 <strong><code>OutOfMemoryError</code></strong> 异常</p>
</li>
</ul>
<h4 id="4-2-方法区（Method-Area）"><a href="#4-2-方法区（Method-Area）" class="headerlink" title="4.2 方法区（Method Area）"></a>4.2 方法区（Method Area）</h4><ul>
<li><p>和堆一样，方法去也是被所有<strong>线程共享</strong>的内存区域。方法区用于存储已经被虚拟机加载的<strong>类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>即时编译器编译后的代码</strong>等数据。方法区还有一个<strong>“非堆（Non-Heap）”</strong>别名，目的是与 Java 堆区分开来。在 JDK 8 以前，也几乎等同于<strong>“永久代（Permanent Generation）”</strong>这个概念</p>
</li>
<li><p>方法区随 JDK 版本的迭代</p>
<ul>
<li><strong>JDK 6</strong>：HotSpot <strong>计划放弃</strong>永久代，采用<strong>本地内存（Native Memory）</strong>实现方法区</li>
<li><strong>JDK 7</strong>：HotSpot <strong>移除了</strong>原本放在永久代的<strong>字符串常量池</strong>、<strong>静态变量</strong>等</li>
<li><strong>JDK 8</strong>：HotSpot <strong>完全废弃了</strong>永久代（方法区），采用<strong>在本地内存中实现的元空间（Meta-space）</strong>来代替。<strong>元空间使用的是直接内存</strong></li>
</ul>
</li>
<li><p>当方法区无法满足新的内存分配需求时，将抛出 <strong><code>OutOfMemoryError</code></strong> 异常</p>
</li>
</ul>
<h4 id="4-3-运行时常量池（Runtime-Constant-Pool）"><a href="#4-3-运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="4.3 运行时常量池（Runtime Constant Pool）"></a>4.3 运行时常量池（Runtime Constant Pool）</h4><ul>
<li><p><strong>运行时常量池是方法区的一部分</strong></p>
<ul>
<li><strong>类信息（Class 文件）</strong>中除了有类的版本、字段、方法、接口等<strong>描述信息</strong>外，还有一项是<strong>常量池表（Constant Pool Table）</strong>，用于存放编译期生成的各种<strong>字面量</strong>与<strong>符号引用</strong></li>
<li>这个<strong>常量池表</strong>和由常量池表中符号引用翻译出来的<strong>直接引用</strong>将在类加载后存放到<strong>方法区的运行时常量池</strong></li>
</ul>
</li>
<li><p>运行时常量池相对于 Class 文件常量池表的另外一个重要特征是具备<strong>动态性</strong></p>
<ul>
<li><strong>Java 语言并不要求常量一定只有编译期才能产生</strong>，也就是说，并非预置入 Class 文件常量池表的内容才能进入方法去运行时常量池</li>
<li><strong>运行期间也可以将新的常量放入运行时常量池</strong>，这种特性被开发人员利用得比较多的就是 <strong><code>String</code> 类的 <code>intern()</code> 方法</strong></li>
</ul>
</li>
<li><p>因为是方法区的一部分，所以运行时常量池受到方法区内存的限制。当运行时常量池无法再申请到内存时会抛出 <strong><code>OutOfMemoryError</code></strong> 异常</p>
</li>
</ul>
<h3 id="5-直接内存（Direct-Memory）"><a href="#5-直接内存（Direct-Memory）" class="headerlink" title="5. 直接内存（Direct Memory）"></a>5. 直接内存（Direct Memory）</h3><ul>
<li><p>直接内存<strong>并不是</strong>虚拟机运行时数据区域的一部分，<strong>也不是</strong>《Java 虚拟机规范》中定义的内存区域，但是这部分内存也会被频繁使用</p>
</li>
<li><p><strong>在 JDK 1.4 中新加入了 NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong>和<strong>缓冲区（Buffer）</strong>的 I/O 方式</p>
<ul>
<li>它可以<strong>使用 Native 函数库直接分配堆外内存</strong>，然后通过一个<strong>存储在 Java 堆里面的 <code>DirectByteBuffer</code> 对象</strong>作为这块内存的引用进行操作</li>
<li>这样能<strong>在一些场景中显著提高性能</strong>，因为避免了在 Java 堆和 Native 堆中来回复制数据</li>
</ul>
</li>
<li><p>本机直接内存的分配不会受到 Java 堆大小的限制，但是会受到本机<strong>总内存</strong>（包括物理内存、SWAP 分区或者分页文件）大小以及<strong>处理器寻址空间</strong>的限制。比如说，服务器管理员根据实际内存去配置 -<code>Xmx</code> 等虚拟机参数时，如果忽略了直接内存使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），此时就会导致动态扩展时抛出 <strong><code>OutOfMemoryError</code></strong> 异常</p>
</li>
</ul>
<h2 id="二-垃圾回收判定算法及四种引用概述"><a href="#二-垃圾回收判定算法及四种引用概述" class="headerlink" title="二. 垃圾回收判定算法及四种引用概述"></a>二. 垃圾回收判定算法及四种引用概述</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h3><ul>
<li><strong>线程私有</strong>的内存区域（程序计数器、虚拟机栈、本地方法栈）：它们的生命周期和<strong>当前线程</strong>保持一致。当<strong>方法结束</strong>（栈帧出栈）或者线程结束时，内存自然被回收，因此不需要过多考虑回收的问题</li>
<li><strong>线程共享</strong>的内存区域（Java 堆、方法区）：由<strong>垃圾回收器</strong>负责管理回收</li>
<li>从<strong>如何判定对象消亡</strong>的角度出发，垃圾回收算法可以分为两大类<ul>
<li><strong>“引用计数式垃圾回收”（Reference Counting GC）</strong>：也被称作<strong>“直接垃圾回收”</strong></li>
<li><strong>“追踪式垃圾回收”（Tracing GC）</strong>：也被称为<strong>“间接垃圾回收”</strong>，<strong>是当前主流</strong> Java 虚拟机的垃圾回收算法实现</li>
</ul>
</li>
</ul>
<h3 id="2-引用计数（Reference-Counting）算法"><a href="#2-引用计数（Reference-Counting）算法" class="headerlink" title="2. 引用计数（Reference Counting）算法"></a>2. 引用计数（Reference Counting）算法</h3><h4 id="2-1-思路"><a href="#2-1-思路" class="headerlink" title="2.1 思路"></a>2.1 思路</h4><ul>
<li>在对象中添加一个<strong>引用计数器</strong>，每增加一个引用关系，值加 1；每失效一个引用关系，值减1</li>
<li>任何时刻<strong>计数器为 0 的对象</strong>就是不可能再被使用的</li>
</ul>
<h4 id="2-2-优点"><a href="#2-2-优点" class="headerlink" title="2.2 优点"></a>2.2 优点</h4><ul>
<li><strong>原理简单</strong>，判定效率高</li>
<li>只占用了很少的内存空间进行计数</li>
</ul>
<h4 id="2-3-缺点"><a href="#2-3-缺点" class="headerlink" title="2.3 缺点"></a>2.3 缺点</h4><ul>
<li>有很多例外情况要考虑，必须配合大量额外处理才能保证正确工作</li>
<li>比如，单纯的引用计数很难解决<strong>对象之间循环引用</strong>的问题</li>
</ul>
<h4 id="2-4-应用"><a href="#2-4-应用" class="headerlink" title="2.4 应用"></a>2.4 应用</h4><ul>
<li>Python 语音、在游戏脚本领域得到很多应用的 Squirrel</li>
<li>微软 COM(Component Object Model) 技术、使用 ActonScript 3 的 FlashPlayer</li>
</ul>
<h3 id="3-可达性分析（Reachability-Analysis）算法"><a href="#3-可达性分析（Reachability-Analysis）算法" class="headerlink" title="3. 可达性分析（Reachability Analysis）算法"></a>3. 可达性分析（Reachability Analysis）算法</h3><h4 id="3-1-示意图"><a href="#3-1-示意图" class="headerlink" title="3.1 示意图"></a>3.1 示意图</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goxnz5s7uzj30jx09lq36.jpg" alt="可达性分析算法示意图"></p>
<h4 id="3-2-思路"><a href="#3-2-思路" class="headerlink" title="3.2 思路"></a>3.2 思路</h4><ul>
<li>通过一系列称为 <strong>“GC Roots” 的根对象</strong>作为起始节点集，从这些节点开始根据引用关系向下搜索，搜索过程所走过的路径称为<strong>“引用链”（Reference Chain）</strong></li>
<li>如果<strong>某个对象到 GC Roots 之间没有任何引用链相连</strong>，用图论的术语就是<strong>从 GC Roots 到这个对象不可达</strong>时，证明该对象是不可能再被使用的</li>
</ul>
<h4 id="3-3-应用"><a href="#3-3-应用" class="headerlink" title="3.3 应用"></a>3.3 应用</h4><ul>
<li>主流的编程语言（<strong>Java</strong>、C#、Lisp 等）的内存管理系统<strong>都是使用可达性分析算法</strong>来判定对象是否存活的</li>
</ul>
<h4 id="3-4-GC-Roots-对象"><a href="#3-4-GC-Roots-对象" class="headerlink" title="3.4 GC Roots 对象"></a>3.4 GC Roots 对象</h4><ul>
<li>在<strong>虚拟机栈</strong>（栈帧中的本地变量表）中引用的对象，比如各个线程中调用的方法堆栈中使用到的参数、局部变量、临时变量等</li>
<li>在方法区中<strong>类静态</strong>属性引用的对象，比如 Java 类的引用类型静态变量</li>
<li>在方法区中<strong>常量</strong>引用的对象，比如字符串常量池（String Table）里的引用</li>
<li>在<strong>本地方法栈</strong>中 JNI（Native 方法）引用的对象</li>
<li>Java 虚拟机内部的引用，如基本数据类型对应的 <code>Class</code> 对象，一些常驻的异常对象（比如 <code>NullPointException</code>、<code>OutOfMemoryError</code>）等，还有系统类加载器</li>
<li>所有被同步锁（<code>synchronized</code> 关键字）持有的对象</li>
<li>反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等</li>
</ul>
<h3 id="4-四种引用类型概述"><a href="#4-四种引用类型概述" class="headerlink" title="4. 四种引用类型概述"></a>4. 四种引用类型概述</h3><h4 id="4-1-强引用（Strong-Reference）"><a href="#4-1-强引用（Strong-Reference）" class="headerlink" title="4.1 强引用（Strong Reference）"></a>4.1 强引用（Strong Reference）</h4><ul>
<li>任何情况下，垃圾回收器<strong>都不会回收</strong>强引用关联的对象</li>
<li>普遍存在的引用赋值，类似 <code>Object obj = new Object();</code></li>
</ul>
<h4 id="4-2-软引用（Soft-Reference）"><a href="#4-2-软引用（Soft-Reference）" class="headerlink" title="4.2 软引用（Soft Reference）"></a>4.2 软引用（Soft Reference）</h4><ul>
<li>发生在<strong>内存溢出异常之前</strong>，如果回收了软引用关联的对象之后内存还不够用，此时就抛出内存溢出异常</li>
<li>JDK 1.2 提供了实现类 <strong><code>SoftReference</code></strong></li>
</ul>
<h4 id="4-3-弱引用（Weak-Reference）"><a href="#4-3-弱引用（Weak-Reference）" class="headerlink" title="4.3 弱引用（Weak Reference）"></a>4.3 弱引用（Weak Reference）</h4><ul>
<li>无论当前内存是否足够，<strong>都会回收</strong>弱引用关联的对象</li>
<li>JDK 1.2 提供了实现类 <strong><code>WeakReference</code></strong></li>
</ul>
<h4 id="4-4-虚引用（Phantom-Reference）"><a href="#4-4-虚引用（Phantom-Reference）" class="headerlink" title="4.4 虚引用（Phantom Reference）"></a>4.4 虚引用（Phantom Reference）</h4><ul>
<li>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也<strong>无法通过虚引用来取得一个对象实例</strong></li>
<li>为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被回收时收到一个<strong>系统通知</strong></li>
<li>JDK 1.2 提供了实现类 <strong><code>PhantomReference</code></strong></li>
</ul>
<h3 id="5-两次标记过程与垃圾回收方法调用概述"><a href="#5-两次标记过程与垃圾回收方法调用概述" class="headerlink" title="5. 两次标记过程与垃圾回收方法调用概述"></a>5. 两次标记过程与垃圾回收方法调用概述</h3><h4 id="5-1-两次标记过程"><a href="#5-1-两次标记过程" class="headerlink" title="5.1 两次标记过程"></a>5.1 两次标记过程</h4><ul>
<li><p><strong>可达性分析算法</strong>中即使判定为不可达对象，也并不代表一个对象真正死亡，只是会被第一次标记</p>
</li>
<li><p><strong>一个对象真正死亡，至少要经历两次标记过程</strong></p>
<ol>
<li>如果对象在进行可达性分析后发现<strong>没有与 GC Roots 相连接的引用链</strong>，此时会被<strong>第一次标记</strong></li>
<li>随后进行一次筛选，如果判断<strong>有必要执行 <code>finalize()</code> 方法</strong>（已覆盖 <code>finalize()</code> 方法或 <code>finalize()</code> 方法还没有被虚拟机调用过）则在 <code>finalize()</code> 方法执行过程中进行<strong>第二次标记</strong></li>
</ol>
</li>
<li><p>在 <strong><code>finalize()</code></strong> 方法执行过程中，对象可以通过重新与引用链上的任何一个对象建立关联即可<strong>“拯救”</strong>自己，然后在<strong>第二次标记</strong>时会被移除“即将回收”的集合。否则该对象会被真正回收</p>
</li>
</ul>
<h4 id="5-2-finalize-方法概述"><a href="#5-2-finalize-方法概述" class="headerlink" title="5.2 finalize() 方法概述"></a>5.2 <code>finalize()</code> 方法概述</h4><ul>
<li>如果一个对象被判定为有必要执行 <code>finalize()</code> 方法，那么该对象首先会被放置在一个名为 <strong>F-Queue</strong> 的队列之中。稍后由一条由虚拟机自动建立的、低调度优先级的 <strong>Finalizer</strong> 线程去执行对象的 <code>finalize()</code> 方法</li>
<li><code>finalize()</code> 方法的<strong>“执行”</strong>是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束，因为 <strong><code>finalize()</code> 方法有可能运行失败</strong>（执行缓慢、甚至死循环导致回收系统崩溃）。 <strong>任何一个对象的 <code>finalize()</code> 方法都只会被系统自动调用一次</strong>，如果对象面临下一次回收，那么它的 <code>finalize()</code> 方法不会被再次执行</li>
<li><code>finalize()</code> 是在 <strong><code>Object</code></strong> 类中定义的，默认实现为空。该方法是 Java 刚诞生时为了使传统 C、C++ 程序员更容易接受 Java 所做出的一项妥协。该方法<strong>运行代价高</strong>、<strong>不确定性大</strong>，无法保证各个对象的调用顺序，已<strong>被官方明确声明不推荐使用</strong>的语法。<code>finalize()</code> 方法能做的工作，使用 <strong><code>try-finally</code></strong> 或者其他方式可以做得更好更及时</li>
</ul>
<h4 id="5-3-gc-方法概述"><a href="#5-3-gc-方法概述" class="headerlink" title="5.3 gc() 方法概述"></a>5.3 <code>gc()</code> 方法概述</h4><ul>
<li>调用垃圾回收器的方法是 <strong><code>gc()</code></strong>，该方法在 <code>System</code> 类和 <code>Runtime</code> 类中都存在</li>
<li>在 <code>System</code> 类中，<code>gc()</code> 是静态方法；在 <code>Runtime</code> 类中，<code>gc()</code> 是实例方法。方法 <code>System.gc()</code> 会调用 <code>Runtime</code> 类中的 <code>gc()</code> 方法，<strong><code>System.gc()</code> 等价于 <code>Runtime.getRuntime().gc()</code></strong></li>
<li><strong><code>System.gc()</code> 的作用是提示 Java 虚拟机进行垃圾回收</strong>。该方法被调用之后，<strong>由 Java 虚拟机决定是立即回收还是延迟回收</strong></li>
</ul>
<h3 id="6-方法区内存回收概述"><a href="#6-方法区内存回收概述" class="headerlink" title="6. 方法区内存回收概述"></a>6. 方法区内存回收概述</h3><h4 id="6-1-常量回收"><a href="#6-1-常量回收" class="headerlink" title="6.1 常量回收"></a>6.1 常量回收</h4><ul>
<li>废弃常量的回收（包括常量池中其他类、接口、方法、字段的符号引用）与 Java 堆对象的回收非常类似，也是<strong>类似二次标记</strong>的回收过程</li>
</ul>
<h4 id="6-2-类型卸载"><a href="#6-2-类型卸载" class="headerlink" title="6.2 类型卸载"></a>6.2 类型卸载</h4><ul>
<li><p><strong>判定一个类型需要回收需要同时满足的三个条件</strong></p>
<ul>
<li>该类所有的<strong>实例</strong>都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例</li>
<li>加载该类的<strong>类加载器</strong>已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景（如 OSGi、JSP 重加载等），否则通常很难达成</li>
<li>该类对应的 <strong><code>java.lang.Class</code></strong> 对象没有在任何地方被引用，无法在任何地方通过<strong>反射</strong>访问该类的方法</li>
</ul>
</li>
<li><p>满足上面三个条件的类只是<strong>“被允许”</strong>回收，HotSpot 虚拟机提供了 <strong><code>-Snoclassgc</code></strong> 参数对类型回收进行控制</p>
</li>
<li><p>在大量使用反射、动态代理、CGLib 等<strong>字节码框架</strong>、动态生成 JSP 以及 OSGi 这类<strong>频繁自定义类加载器</strong>的场景中，通常都需要 Java 虚拟机具备<strong>类型卸载</strong>的能力，以保证不会对<strong>方法区</strong>造成过大的内存压力</p>
</li>
</ul>
<h2 id="三-垃圾回收算法概述"><a href="#三-垃圾回收算法概述" class="headerlink" title="三. 垃圾回收算法概述"></a>三. 垃圾回收算法概述</h2><h3 id="1-分代回收理论概述"><a href="#1-分代回收理论概述" class="headerlink" title="1. 分代回收理论概述"></a>1. 分代回收理论概述</h3><ul>
<li><p>当前商业虚拟机的垃圾回收器，大多数都遵循了<strong>“分代回收”（Generational Collection）</strong>的理论进行设计</p>
<ul>
<li>分代回收名为理论，实质是一套符合大多数程序运行实际情况的<strong>经验法则</strong></li>
<li>需要注意的是，<strong>分代回收理论也有其缺陷</strong>，最新出现（或在实验室中）的几款垃圾回收器都展现出了<strong>面向全区域回收</strong>设计的思想（或者可以支持<strong>全区域不分代回收</strong>的工作模式）</li>
<li>HotSpot 虚拟机把 <strong>Java 堆</strong>划分为<strong>新生代（Young）</strong>和<strong>老年代（Old）</strong>两个区域，这也是现在<strong>业界主流</strong>的命名方式</li>
</ul>
</li>
<li><p>分代回收理论建立在<strong>三个假说</strong>之上</p>
<ul>
<li><strong>弱分代假说（Weak Generational Hypothesis）</strong>：绝大多数对象都是朝生夕灭的，新生代中的对象有 98%熬不过第一轮回收</li>
<li><strong>强分代假说（Strong Generational Hypothesis）</strong>：熬过越多次垃圾回收过程的对象就越难以消亡（越容易从新生代晋升到老年代）</li>
<li><strong>跨代引用假说（Intergenerational Reference Hypothesis）</strong>：跨代引用相对于同代引用来说仅占极少数</li>
</ul>
</li>
<li><p>针对不同分代的<strong>回收类型</strong>划分</p>
<ul>
<li><p><strong>部分回收（Partial GC）</strong>：只是部分回收 Java 堆的垃圾回收方式</p>
<ul>
<li><p><strong>新生代回收（Minor GC/Young GC）</strong>：只是新生代的垃圾回收方式</p>
</li>
<li><p><strong>老年代回收（Major GC/Old GC）</strong>：只是老年代的垃圾回收方式</p>
<blockquote>
<p>目前只有 CMS 垃圾回收器有单独回收老年代的行为</p>
<p>需要注意的是，”Major GC” 这个说法现在有点混淆，需要按上下文区分到底是指老年代回收还是整堆回收</p>
</blockquote>
</li>
<li><p><strong>混合回收（Mixed GC）</strong>：回收整个新生代以及部分老年代的垃圾回收方式</p>
</li>
</ul>
</li>
<li><p><strong>整堆回收（Full GC）</strong>：回收整个 Java 堆和方法区的垃圾回收方式</p>
</li>
</ul>
</li>
<li><p><strong>Minor GC 和 Major GC</strong></p>
<ul>
<li>Minor GC 指发生在新生代的垃圾回收操作。因为大多数对象的生命周期都很短，因此 Minor GC 会<strong>频繁执行</strong>，一般回收速度也<strong>比较快</strong></li>
<li>Major GC 指发生在老年代的垃圾回收操作。出现了 Major GC，经常会伴随至少一次的 Minor GC。老年代对象的存活时间长，因此 Major GC <strong>很少执行</strong>，而且执行速度会比 Minor GC <strong>慢很多</strong></li>
</ul>
</li>
<li><p><strong>对象优先在 Eden 区分配</strong></p>
<ul>
<li>大多数情况下，对象在新生代 Eden 区分配</li>
<li>当 Eden 区空间不够时，发起 Minor GC</li>
</ul>
</li>
<li><p><strong>大对象直接进入老年代</strong></p>
<ul>
<li>大对象是指需要<strong>连续内存空间</strong>的对象，最典型的大对象是那种很长的<strong>字符串</strong>以及<strong>数组</strong></li>
<li>大对象对于虚拟机的内存分配而言是坏消息，经常出现大对象会导致内存还有不少空间时就<strong>提前触发</strong>垃圾回收以获取足够的连续空间分配给大对象</li>
<li>将大对象直接在老年代中分配的目的是<strong>避免</strong>在 Eden 区和 Survivor 区之间出现<strong>大量内存复制</strong></li>
</ul>
</li>
<li><p><strong>长期存活的对象进入老年代</strong></p>
<ul>
<li>Java 虚拟机采用<strong>分代回收</strong>的思想管理内存，因此<strong>需要识别每个对象应该放在新生代还是老年代</strong></li>
<li><strong>虚拟机给每个对象定义了年龄计数器</strong>，对象在 Eden 区出生之后，如果经过第一次 Minor GC 之后仍然存活，将进入 Survivor 区，同时对象年龄变为 1，对象在 Survivor 区每经过一次 Minor GC 且存活，年龄就增加 1，<strong>增加到一定阈值时则进入老年代（阈值默认为 15）</strong></li>
</ul>
</li>
<li><p><strong>动态对象年龄判定</strong></p>
<ul>
<li>为了能<strong>更好地适应</strong>不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到阈值才能进入老年代</li>
<li>如果在 Survivor 区中相同年龄的所有对象的空间总和大于 Survivor 区空间的一半，则年龄大于或等于该年龄的对象<strong>直接进入</strong>老年代</li>
</ul>
</li>
<li><p><strong>空间分配担保</strong></p>
<ul>
<li>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的空间总和，如果这个条件成立，那么 Minor GC 可以确保是安全的</li>
<li>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Major GC</li>
</ul>
</li>
</ul>
<h3 id="2-标记-清除（Mark-Sweep）算法"><a href="#2-标记-清除（Mark-Sweep）算法" class="headerlink" title="2. 标记-清除（Mark-Sweep）算法"></a>2. 标记-清除（Mark-Sweep）算法</h3><ul>
<li><p><strong>示意图</strong></p>
<p>  <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goyjmnbs41j30ju0cfglx.jpg" alt="标记-清除"></p>
</li>
<li><p><strong>思路</strong></p>
<ul>
<li><strong>标记并回收</strong>：首先<strong>标记所有</strong>需要回收的对象，然后<strong>统一回收</strong>所有被标记的对象（也可以反过来，标记存活的对象、统一回收未被标记的对象）</li>
<li><strong>标记的过程</strong>：就是判定对象是否属于垃圾的<strong>两次标记过程</strong></li>
</ul>
</li>
<li><p><strong>缺点</strong></p>
<ul>
<li><strong>执行效率低</strong>：面对大量可回收对象时，必须进行大量的标记和清除动作</li>
<li><strong>内存碎片化</strong>：标记清除之后会产生大量不连续的内存碎片，会影响内存的分配和回收</li>
</ul>
</li>
<li><p><strong>应用</strong></p>
<ul>
<li><strong>CMS 垃圾回收器</strong>：HotSpot 虚拟机里<strong>关注延迟</strong>的 CMS 垃圾回收器是基于<strong>标记-清除算法</strong>的（也会使用<strong>标记-整理算法</strong>）</li>
</ul>
</li>
</ul>
<h3 id="3-标记-复制（Mark-Semispace-Copying）算法"><a href="#3-标记-复制（Mark-Semispace-Copying）算法" class="headerlink" title="3. 标记-复制（Mark-Semispace Copying）算法"></a>3. 标记-复制（Mark-Semispace Copying）算法</h3><ul>
<li><p><strong>示意图</strong></p>
<p>  <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goyk7jy2d6j30hx0e1q3j.jpg" alt="标记-复制"></p>
</li>
<li><p><strong>思路</strong></p>
<ul>
<li><strong>划分及使用</strong>：将可用内存按容量<strong>划分为大小相等的两块</strong>，每次<strong>只使用</strong>其中的一块</li>
<li><strong>复制并清理</strong>：当这一块的内存用完了，就将还存活着的<strong>对象复制</strong>到另外一块上面，然后再把已使用过的内存空间<strong>统一清理</strong></li>
</ul>
</li>
<li><p><strong>优点</strong></p>
<ul>
<li>避免了标记-清除算法的<strong>执行效率低</strong>的问题：内存回收时，每次只针对整个半区进行内存回收操作</li>
<li>避免了标记-清除算法的<strong>内存碎片化</strong>的问题：内存分配时，只需要移动堆顶指针，按顺序分配即可</li>
</ul>
</li>
<li><p><strong>缺点</strong></p>
<ul>
<li><strong>空间浪费</strong>：可用内存缩小为原来的一半</li>
<li><strong>复制开销</strong>：如果内存中多数对象都是存活的，会产生大量的内存复制开销</li>
</ul>
</li>
<li><p><strong>应用</strong></p>
<ul>
<li><strong>回收新生代</strong>：现在的商用 Java 虚拟机大多都采用标记-复制算法（及优化算法）回收新生代</li>
</ul>
</li>
<li><p><strong>优化：Appel 式回收策略</strong></p>
<ul>
<li><strong>原因</strong>：新生代中 <strong>98%</strong> 的对象都是朝生夕灭的，因此<strong>不需要按照 1:1 的比例划分</strong>新生代的内存空间</li>
<li><strong>思路</strong>：把新生代分为一块较大的 <strong>Eden 空间</strong>和两块较小的 <strong>Survivor 空间</strong>，每次内存分配<strong>只使用</strong> Eden 和其中一块 Survivor。发生垃圾回收时，将 Eden 和 Survivor 中仍然存活的对象一次性<strong>复制</strong>到另外一块 Survivor 空间上，然后直接<strong>清理</strong> Eden 和已用过的那块 Survivor 空间</li>
<li><strong>应用</strong>：HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 <strong>8:1</strong>，即只有一个 10% 的 Survivor 新生代内存空间会被浪费。HotSpot 虚拟机的 Serial、ParNew 等新生代垃圾回收器都采用 <strong>Appel 式回收策略</strong>设计新生代的内存布局</li>
<li><strong>安全</strong>：“逃生门”安全设计，即当 Survivor 空间不足以容纳一次 Minor GC 之后存活的对象时，就需要依赖其他内存区域（大多是老年代）进行<strong>分配担保（Handle Promotion）</strong></li>
</ul>
</li>
</ul>
<h3 id="4-标记-整理（Mark-Compact）算法"><a href="#4-标记-整理（Mark-Compact）算法" class="headerlink" title="4. 标记-整理（Mark-Compact）算法"></a>4. 标记-整理（Mark-Compact）算法</h3><ul>
<li><p><strong>示意图</strong></p>
<p>  <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goylo84tw5j30k70e33z1.jpg" alt="标记-整理"></p>
</li>
<li><p><strong>思路</strong></p>
<ul>
<li><strong>标记过程</strong>：仍是判定对象是否属于垃圾的<strong>两次标记过程</strong></li>
<li><strong>整理过程</strong>：不是直接对可回收对象进行清理，而是<strong>让所有存活的对象都向内存空间一端移动</strong>，然后直接<strong>清理边界以外</strong>的内存</li>
</ul>
</li>
<li><p><strong>优点</strong></p>
<ul>
<li>避免了标记-复制算法的<strong>空间浪费</strong>问题：标记-整理是对象<strong>移动式</strong>的算法，不需要额外的空间进行分配担保</li>
<li>避免了标记-复制算法的<strong>复制开销</strong>问题：不需要复制操作，对象存活率较高时，没有复制开销、效率比较高</li>
</ul>
</li>
<li><p><strong>缺点</strong></p>
<ul>
<li><strong>操作复杂</strong>：移动存活对象并<strong>更新所有引用</strong>是一种<strong>极为负重</strong>的操作（但从整个程序的<strong>吞吐量</strong>的角度，移动对象会更划算）</li>
<li><strong>“Stop The World”</strong>：移动对象操作必须<strong>全程暂停</strong>应用程序（最新的 ZGC 和 Shenandoah 垃圾回收器使用 <strong>Read Barrier 读屏障</strong>技术实现了整理过程与用户线程的并发执行）</li>
</ul>
</li>
<li><p><strong>应用</strong></p>
<ul>
<li><strong>Parallel Scavenge 垃圾回收器</strong>：HotSpot 虚拟机里<strong>关注吞吐量</strong>的 Parallel Scavenge 垃圾回收器是基于<strong>标记-整理算法</strong>的</li>
<li><strong>CMS 垃圾回收器</strong>：虚拟机平时多数时间采用<strong>标记-清除算法</strong>，暂时容忍内存碎片的存在。直到内存空间的碎片化程度已经大到影响对象内存分配时，再采用<strong>标记-整理算法</strong>回收一次，以获得规整的内存空间</li>
</ul>
</li>
</ul>
<h2 id="四-Class-类文件结构概述"><a href="#四-Class-类文件结构概述" class="headerlink" title="四. Class 类文件结构概述"></a>四. Class 类文件结构概述</h2><h3 id="1-Class-文件概述"><a href="#1-Class-文件概述" class="headerlink" title="1. Class 文件概述"></a>1. Class 文件概述</h3><ul>
<li><p><strong>Class 文件</strong></p>
<ul>
<li>是一组以 8 个字节为基础单位的<strong>二进制流</strong>，各个数据项目严格按照顺序紧凑排列在文件之中，<strong>中间没有添加任何分隔符</strong></li>
<li>这使得整个 Class 文件中存储的内容几乎全部是程序运行的<strong>必要数据</strong>，没有空隙存在</li>
</ul>
</li>
<li><p><strong>Class 文件格式</strong>：采用一种类似于 C 语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”</p>
<ul>
<li><strong>无符号数</strong>：属于基本的<strong>数据类型</strong>，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数。无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值</li>
<li><strong>表</strong>：是由多个无符号数或者其他表作为数据项构成的<strong>复合数据类型</strong>，为了便于区分，所有的表的命名都习惯性地以 <strong>“info”</strong> 结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上也可以视作一张表</li>
</ul>
</li>
<li><p><strong>Class 文件格式数据项</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u4</td>
<td align="center">magic</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">minor_version</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">major_version</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">constant_pool_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">cp_info</td>
<td align="center">constant_pool</td>
<td align="center">constant_pool_count-1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">access_flags</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">this_class</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">super_class</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">interfaces_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">interfaces</td>
<td align="center">interfaces_count</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">fields_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">field_info</td>
<td align="center">fields</td>
<td align="center">fields_count</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">methods_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">method_info</td>
<td align="center">methods</td>
<td align="center">methods_count</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td align="center">attributes</td>
<td align="center">attributes_count</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-魔数与-Class-文件的版本"><a href="#2-魔数与-Class-文件的版本" class="headerlink" title="2. 魔数与 Class 文件的版本"></a>2. 魔数与 Class 文件的版本</h3><ul>
<li><strong>魔数（Magic Number）</strong><ul>
<li>每个 Class 文件的前 4 个字节，它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接受的 Class 文件</strong>，起到一个<strong>身份标识</strong>的作用</li>
<li>Java 虚拟机中 Class 文件的魔数取名为 <strong>0xCAFEBABE</strong></li>
</ul>
</li>
<li><strong>Class 文件的版本</strong>：魔数后面的 4 个字节存储的是 Class 文件的版本号<ul>
<li>第 5 和第 6 个字节是<strong>次版本号（Minor Version）</strong>，第 7 和第 8 个字节是<strong>主版本号（Major Version）</strong></li>
<li>Java 的版本号是从 <strong>45</strong> 开始的，JDK 1.1 之后的每个 JDK 大版本发布主版本号向上加 1（JDK 1.0 ~ JDK 1.1 使用了 45.0 ~ 45.3 的版本号）</li>
<li>高版本的 JDK <strong>只能向下兼容</strong>以前版本的 Class 文件，但不能运行以后版本的 Class 文件。《Java 虚拟机规范》在 Class 文件校验部分明确要求及时文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的 Class 文件</li>
</ul>
</li>
</ul>
<h3 id="3-常量池"><a href="#3-常量池" class="headerlink" title="3. 常量池"></a>3. 常量池</h3><ul>
<li><p><strong>常量池</strong></p>
<ul>
<li>主、此版本号之后的是常量池入口，可以比喻为 Class 文件里的<strong>资源仓库</strong></li>
<li>常量池是 Class 文件结构中与其他项目<strong>关联最多</strong>的数据，通常也是占用 Class 文件<strong>空间最大</strong>的数据项目之一。另外，<strong>它还是在 Class 文件中第一个出现的表类型数据项目</strong></li>
</ul>
</li>
<li><p><strong>常量池的内容</strong></p>
<ul>
<li><strong>字面量（Literal）</strong>：比较接近 Java 语言层面的常量概念，如文本字符串、被声明为 <code>final</code> 的常量值等</li>
<li><strong>符号引用（Symbolic Reference）</strong>：属于编译原理方面的概念，主要包括下面几类常量<ul>
<li>被模块导出或者开放的包（Package）</li>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
<li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li>
<li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>常量池的项目类型</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">标志</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CONSTANT_Utf8_info</td>
<td align="center">1</td>
<td align="center">UTF-8 编码的字符串</td>
</tr>
<tr>
<td align="center">CONSTANT_Integer_info</td>
<td align="center">3</td>
<td align="center">整型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Float_info</td>
<td align="center">4</td>
<td align="center">浮点型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Long_info</td>
<td align="center">5</td>
<td align="center">长整型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Double_info</td>
<td align="center">6</td>
<td align="center">双精度浮点型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Class_info</td>
<td align="center">7</td>
<td align="center">类或接口的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_String_info</td>
<td align="center">8</td>
<td align="center">字符串类型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Fieldref_info</td>
<td align="center">9</td>
<td align="center">字段的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_Methodref_info</td>
<td align="center">10</td>
<td align="center">类中方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_InterfaceMethodref_info</td>
<td align="center">11</td>
<td align="center">接口中方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_NameAndType_info</td>
<td align="center">12</td>
<td align="center">字段或方法的部分符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodHandle_info</td>
<td align="center">15</td>
<td align="center">表示方法句柄</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodType_info</td>
<td align="center">16</td>
<td align="center">表示方法类型</td>
</tr>
<tr>
<td align="center">CONSTANT_Dynamic_info</td>
<td align="center">17</td>
<td align="center">表示一个动态计算常量</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="4-访问标志"><a href="#4-访问标志" class="headerlink" title="4. 访问标志"></a>4. 访问标志</h3><ul>
<li><p><strong>访问标志（access_flags）</strong></p>
<ul>
<li>用于识别一些类或者接口层次的<strong>访问信息</strong></li>
<li>包括：<strong>这个 <code>Class</code> 是类还是接口</strong>；是否定义为 <code>public</code> 类型；是否定义为 <code>abstract</code> 类型；如果是类的话，是否被声明为 <code>final</code> 等</li>
</ul>
</li>
<li><p><strong>访问标志位</strong></p>
<table>
<thead>
<tr>
<th align="center">标志名称</th>
<th align="center">标志值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ACC_PUBLIC</td>
<td align="center">0x0001</td>
<td align="center">是否为 public 类型</td>
</tr>
<tr>
<td align="center"><strong>ACC_FINAL</strong></td>
<td align="center">0x0010</td>
<td align="center"><strong>是否被声明为 final，只有类可设置（只针对类和接口而言）</strong></td>
</tr>
<tr>
<td align="center">ACC_SUPER</td>
<td align="center">0x0020</td>
<td align="center">是否允许使用 invokespecial 字节码指令的新语义，invokespecial 指令的语义在 JDK 1.0.2 发生过改变，为了区分这条指令使用哪种语义，JDK 1.0.2 之后编译出来的类的这个标志都必须为真</td>
</tr>
<tr>
<td align="center">ACC_INTERFACE</td>
<td align="center">0x0200</td>
<td align="center">标识这是一个接口</td>
</tr>
<tr>
<td align="center">ACC_ABSTRACT</td>
<td align="center">0x0400</td>
<td align="center">是否为 abstract 类型，对于接口或者抽象类来说，此标志为真，其他类型值为假</td>
</tr>
<tr>
<td align="center"><strong>ACC_SYNTHETIC</strong></td>
<td align="center">0x1000</td>
<td align="center"><strong>标识这个类并非由用户代码产生</strong></td>
</tr>
<tr>
<td align="center">ACC_ANNOTATION</td>
<td align="center">0x2000</td>
<td align="center">标识这是一个注解</td>
</tr>
<tr>
<td align="center">ACC_ENUM</td>
<td align="center">0x4000</td>
<td align="center">标识这是一个枚举</td>
</tr>
<tr>
<td align="center"><strong>ACC_MODULE</strong></td>
<td align="center">0x8000</td>
<td align="center"><strong>标识这是一个模块</strong></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="5-类索引、父类索引与接口索引集合"><a href="#5-类索引、父类索引与接口索引集合" class="headerlink" title="5. 类索引、父类索引与接口索引集合"></a>5. 类索引、父类索引与接口索引集合</h3><ul>
<li><strong>类索引（<code>this_class</code>）</strong>和<strong>父类索引（<code>super_class</code>）</strong>都是一个 u2 类型的数据。<strong>接口索引集合（<code>interfaces</code>）</strong>是一组 u2 类型的数据的集合，<strong>Class 文件中由这三项数据来确定该类型的继承关系</strong></li>
<li><strong>类索引</strong>：用于确定这个类的全限定名</li>
<li><strong>父类索引</strong>：用于确定这个类的父类的全限定名</li>
<li><strong>接口索引</strong>：用于描述这个类实现了哪些接口，这些被实现的接口将按 <code>implements</code> 关键字（如果这个索引集合表示的是一个类，则应当是 <code>extends</code> 关键字）后的接口顺序从做到右排列在接口索引集合中</li>
</ul>
<h3 id="6-字段表集合"><a href="#6-字段表集合" class="headerlink" title="6. 字段表集合"></a>6. 字段表集合</h3><ul>
<li><p><strong>字段表（field_info）</strong>用于描述接口或者类中声明的变量。Java 语言中的<strong>字段（Field）</strong>包括类级变量（静态变量）以及实例级变量，但不包括在方法内部声明的局部变量。Java 语言中的字段可以包括的<strong>修饰符</strong>有以下几种</p>
<ul>
<li><strong><code>public/private/protected</code></strong>：字段的作用域</li>
<li><strong><code>static</code></strong>：是实例变量还是类变量</li>
<li><strong><code>final</code></strong>：可变性</li>
<li><strong><code>volatile</code></strong>：并发可见性，是否强制从主内存读写</li>
<li><strong><code>transient</code></strong>：可否被序列化</li>
<li><strong>字段数据类型</strong>：基本数据类型、对象、数组</li>
</ul>
</li>
<li><p><strong>字段表结构</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">access_flags</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">name_index</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">descriptor_index</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td align="center">attributes</td>
<td align="center">attributes_count</td>
</tr>
</tbody></table>
</li>
<li><p><strong>字段访问标志位</strong></p>
<table>
<thead>
<tr>
<th align="center">标志名称</th>
<th align="center">标志值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ACC_PUBLIC</td>
<td align="center">0x0001</td>
<td align="center">字段是否 public</td>
</tr>
<tr>
<td align="center">ACC_PRIVATE</td>
<td align="center">0x0002</td>
<td align="center">字段是否 private</td>
</tr>
<tr>
<td align="center">ACC_PROTECTED</td>
<td align="center">0x0004</td>
<td align="center">字段是否 protected</td>
</tr>
<tr>
<td align="center">ACC_STATIC</td>
<td align="center">0x0008</td>
<td align="center">字段是否 static</td>
</tr>
<tr>
<td align="center">ACC_FINAL</td>
<td align="center">0x0010</td>
<td align="center">字段是否 final</td>
</tr>
<tr>
<td align="center">ACC_VOLATILE</td>
<td align="center">0x0040</td>
<td align="center">字段是否 volatile</td>
</tr>
<tr>
<td align="center">ACC_TRANSIENT</td>
<td align="center">0x0080</td>
<td align="center">字段是否 transient</td>
</tr>
<tr>
<td align="center"><strong>ACC_SYNTHETIC</strong></td>
<td align="center">0x1000</td>
<td align="center"><strong>字段是否由编译器自动产生</strong></td>
</tr>
<tr>
<td align="center"><strong>ACC_ENUM</strong></td>
<td align="center">0x4000</td>
<td align="center"><strong>字段是否 enum</strong></td>
</tr>
</tbody></table>
<ul>
<li><strong><code>ACC_FINAL</code> 和 <code>ACC_VOLATILE</code> 不能同时选择</strong></li>
<li><strong>接口之中的字段必须有 <code>ACC_PUBLIC</code>、<code>ACC_STATIC</code>、<code>ACC_FINAL</code> 标志</strong></li>
<li><strong>Java 语言中字段是无法重载的</strong>，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称</li>
</ul>
</li>
</ul>
<h3 id="7-方法表集合"><a href="#7-方法表集合" class="headerlink" title="7. 方法表集合"></a>7. 方法表集合</h3><ul>
<li><p><strong>方法表</strong>的结构如同字段表一样，依次包括<strong>访问标志（<code>access_flags</code>）</strong>、<strong>名称索引（<code>name_index</code>）</strong>、<strong>描述符索引（<code>descriptor_index</code>）</strong>、<strong>属性表集合（<code>attributes</code>）</strong></p>
</li>
<li><p><strong>方法表的结构</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">access_flags</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">name_index</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">descriptor_index</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">atrribute_info</td>
<td align="center">attributes</td>
<td align="center">attributes_count</td>
</tr>
</tbody></table>
<ul>
<li><strong><code>volatile</code> 关键字和 <code>transient</code> 关键字不能修饰方法</strong></li>
</ul>
</li>
<li><p><strong>方法访问标志位</strong></p>
<table>
<thead>
<tr>
<th align="center">标志名称</th>
<th align="center">标志值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ACC_PUBLIC</td>
<td align="center">0x0001</td>
<td align="center">方法是否为 public</td>
</tr>
<tr>
<td align="center">ACC_PRIVATE</td>
<td align="center">0x0002</td>
<td align="center">方法是否为 private</td>
</tr>
<tr>
<td align="center">ACC_PROTECTED</td>
<td align="center">0x0004</td>
<td align="center">方法是否为 protected</td>
</tr>
<tr>
<td align="center">ACC_STATIC</td>
<td align="center">0x0008</td>
<td align="center">方法是否为 static</td>
</tr>
<tr>
<td align="center">ACC_FINAL</td>
<td align="center">0x0010</td>
<td align="center">方法是否为 final</td>
</tr>
<tr>
<td align="center">ACC_SYNCHRONIZED</td>
<td align="center">0x0020</td>
<td align="center">方法是否为 synchronized</td>
</tr>
<tr>
<td align="center"><strong>ACC_BRIDGE</strong></td>
<td align="center">0x0040</td>
<td align="center"><strong>方法是不是由编译器产生的桥接方法</strong></td>
</tr>
<tr>
<td align="center"><strong>ACC_VARARGS</strong></td>
<td align="center">0x0080</td>
<td align="center"><strong>方法是否接收不定参数</strong></td>
</tr>
<tr>
<td align="center">ACC_NATIVE</td>
<td align="center">0x0100</td>
<td align="center">方法是否为 native</td>
</tr>
<tr>
<td align="center">ACC_ABSTRACT</td>
<td align="center">0x0400</td>
<td align="center">方法是否为 abstract</td>
</tr>
<tr>
<td align="center"><strong>ACC_STATIC</strong></td>
<td align="center">0x0800</td>
<td align="center"><strong>方法是否为 strictfp</strong></td>
</tr>
<tr>
<td align="center"><strong>ACC_SYNTHETIC</strong></td>
<td align="center">0x1000</td>
<td align="center"><strong>方法是否为编译器自动产生</strong></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="8-属性表集合"><a href="#8-属性表集合" class="headerlink" title="8. 属性表集合"></a>8. 属性表集合</h3><ul>
<li><p><strong>属性表（attribute_info）</strong>：Class 文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息</p>
</li>
<li><p>与 Class 文件中其他的数据项目要求严格的顺序、长度和内容不同，<strong>属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格顺序</strong>。《Java 虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，<strong>Java 虚拟机运行时会忽略掉它不认识的属性</strong>。同时，<strong>Java 程序方法体里面的代码经过 Javac 编译器处理之后，最终变为字节码指令存储在 Code 属性内</strong></p>
</li>
<li><p><strong>Code 属性表的结构</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">attribute_name_index</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u4</td>
<td align="center">attribute_length</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">max_stack</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">max_locals</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u4</td>
<td align="center">code_length</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u1</td>
<td align="center">code</td>
<td align="center">code_length</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">exception_table_length</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">exception_info</td>
<td align="center">exception_table</td>
<td align="center">exception_table_length</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td align="center">attributes</td>
<td align="center">attributes_count</td>
</tr>
</tbody></table>
<ul>
<li><strong><code>max_stack</code></strong>：代表了<strong>操作数栈（Operand Stack）</strong>深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配<strong>栈帧（Stack Frame）</strong>中的操作栈深度</li>
<li><strong><code>max_locals</code></strong> 代表了<strong>局部变量表</strong>所需的存储空间。在这里，<strong><code>max_locals</code> 的单位是变量槽（Slot），变量槽是虚拟机为局部变量分配内存所使用的最小单位</strong></li>
</ul>
</li>
<li><p><strong>Code 属性是 Class 文件中最重要的一个属性</strong>。如果可以把一个 Java 程序中的信息分为<strong>代码（Code，方法体里的 Java 代码）</strong>和<strong>元数据（Metadata，包括类、字段、方法定义及其他信息）</strong>两部分，那么在整个 Class 文件里，Code 属性用于<strong>描述代码</strong>，所有的其他数据项目都用于<strong>描述元数据</strong></p>
</li>
</ul>
<h2 id="五-JVM-类加载机制概述"><a href="#五-JVM-类加载机制概述" class="headerlink" title="五. JVM 类加载机制概述"></a>五. JVM 类加载机制概述</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><ul>
<li><strong>虚拟机的类加载机制</strong>：Java 虚拟机把描述类的数据从 <strong>Class 文件</strong>加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 <strong>Java 类型</strong></li>
</ul>
<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4><ul>
<li>在 Java 语言里，类型的加载、连接和初始化过程都是在<strong>程序运行期间</strong>完成的</li>
</ul>
<h4 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h4><ul>
<li>为 Java 应用提供了极高的<strong>扩展性</strong>和<strong>灵活性</strong>，Java 天生可以动态扩展的语言特性就是依赖运行期<strong>动态加载</strong>和<strong>动态连接</strong>实现</li>
</ul>
<h4 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4. 缺点"></a>4. 缺点</h4><ul>
<li>让 Java 语言进行<strong>提前编译</strong>会面临额外的困难，也会让类加载时稍微增加一些<strong>性能开销</strong></li>
</ul>
<h4 id="5-应用"><a href="#5-应用" class="headerlink" title="5. 应用"></a>5. 应用</h4><ul>
<li><strong>动态组装应用</strong>的方式目前已广泛应用于 Java 程序之中，从最基础的 Applet、JSP 到相对复杂的 OSGi 技术，都依赖着 Java 语言<strong>运行期类加载</strong>才得以诞生</li>
</ul>
<h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h4><ul>
<li>代码编译的结果从<strong>本地机器码</strong>转变为<strong>字节码</strong>，是存储格式发展的一小步，却是编程语言发展的一大步</li>
</ul>
<h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><h4 id="1-类的生命周期示意图"><a href="#1-类的生命周期示意图" class="headerlink" title="1. 类的生命周期示意图"></a>1. 类的生命周期示意图</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp1xror1qsj30r80bnjs5.jpg" alt="类的生命周期"></p>
<h4 id="2-类生命周期概述"><a href="#2-类生命周期概述" class="headerlink" title="2. 类生命周期概述"></a>2. 类生命周期概述</h4><ul>
<li>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历<strong>加载（Loading）</strong>、<strong>验证（Verification）</strong>、<strong>准备（Preparation）</strong>、<strong>解析（Resolution）</strong>、<strong>初始化（Initialization）</strong>、<strong>使用（Using）</strong>、<strong>卸载（Unloading）</strong> 七个阶段。其中，验证、准备、解析三个阶段统称为<strong>连接（Linking）</strong></li>
<li>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班开始，<strong>而解析阶段则不一定</strong>：它在某些情况下可以在<strong>初始化阶段之后</strong>再开始，这是为了支持 Java 语言的<strong>运行时绑定</strong>特性（也称为动态绑定或晚期绑定）</li>
<li>按部就班开始并不是按部就班进行或按部就班完成的意思，这些节点通常都是<strong>互相交叉混合进行</strong>的，会在一个阶段执行的过程中调用、激活另一个阶段。需要注意的是，<strong>第一个阶段加载（Loading）在《Java 虚拟机规范》中并没有进行强制约束，可以交给虚拟机的具体实现来自由把握</strong></li>
</ul>
<h4 id="3-有且只有的需要开始初始化操作的六种情况"><a href="#3-有且只有的需要开始初始化操作的六种情况" class="headerlink" title="3. 有且只有的需要开始初始化操作的六种情况"></a>3. 有且只有的需要开始初始化操作的六种情况</h4><ol>
<li><p>遇到 <strong>new</strong>、<strong>getstatic</strong>、<strong>putstatic</strong> 或 <strong>invokestatic</strong> 这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型 Java 代码场景有</p>
<ul>
<li>使用 <strong><code>new</code> 关键字</strong>实例化对象的时候</li>
<li>读取或设置一个类型的<strong>静态字段</strong>（被 <strong><code>final</code></strong> 修饰、已在编译期把结果放入常量池的静态字段除外）的时候</li>
<li>调用一个类型的<strong>静态方法</strong>的时候</li>
</ul>
</li>
<li><p>使用 <strong><code>java.lang.reflect</code></strong> 包的方法对类型进行<strong>反射调用</strong>的时候，如果类型没有进行过初始化，则需要先触发其初始化</p>
</li>
<li><p>当初始化类的时候，如果发现其父类还没有进行过初始化，则<strong>需要先触发其父类的初始化</strong></p>
</li>
<li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 <strong><code>main()</code></strong> 方法的那个类），<strong>虚拟机会先初始化这个主类</strong></p>
</li>
<li><p>当使用  <strong>JDK 7 新加入的动态语言支持</strong>时，如果一个 <strong><code>java.lang.invoke.MethodHandle</code> 实例</strong>最后的解析结果为 <code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>、<code>REF_newInvokeSpecial</code> 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化</p>
</li>
<li><p>当一个接口中定义了 <strong>JDK 8 新加入的默认方法</strong>（被 <strong><code>default</code></strong> 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化（<del>是不是可以写一个这个版本的单例模式</del>）</p>
</li>
</ol>
<h4 id="4-被动引用"><a href="#4-被动引用" class="headerlink" title="4. 被动引用"></a>4. 被动引用</h4><ul>
<li><p>概念</p>
<ul>
<li>《Java 虚拟机规范》中规定的<strong>六种</strong>必须立即进行初始化场景中的行为称为<strong>对一个类型进行主动引用</strong>。除此之外，所有引用类型的方式都不会触发初始化，成为<strong>被动引用</strong></li>
</ul>
</li>
<li><p>Demo 1：<strong>通过子类引用父类的静态字段，不会导致子类初始化</strong></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package org.fenixsoft.classloading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SuperClass</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"SuperClass init!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">value</span> = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SubClass</span> <span class="title">extends</span> <span class="title">SuperClass</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"SubClass init!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NotInitialization</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(SubClass.<span class="keyword">value</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>运行结果</strong>：只会输出 <code>&quot;SuperClass init!&quot;</code>，不会输出 <code>&quot;SubClass init!&quot;</code></li>
<li><strong>对于静态字段，只有直接定义这个字段的类才会被初始化</strong>，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化</li>
<li>是否要触发<strong>子类的加载和验证</strong>阶段，在《Java 虚拟机规范》中并未明确规定，取决于虚拟机的具体实现。对于 HotSpot 虚拟机来说，可通过 <code>-XX:+TraceClassLoading</code> 参数观察到此操作是<strong>会导致子类加载</strong>的</li>
</ul>
</li>
<li><p>Demo 2：<strong>通过数组定义来引用类，不会触发此类的初始化</strong></p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.classloading;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	static &#123;</span><br><span class="line">		<span class="type">System</span>.out.println(<span class="string">"SubClass init!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	public static void main(<span class="type">String</span> [] args) &#123;</span><br><span class="line">		<span class="type">SuperClass</span>[] sca = <span class="keyword">new</span> <span class="type">SuperClass</span>[<span class="number">10</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>运行结果</strong>：没有输出 <code>&quot;SuperClass init!&quot;</code>，说明并没有触发 <code>org.fenixsoft.classloading.SuperClass</code> 的初始化阶段</li>
<li>但是这段代码触发了另一个名为 <strong><code>Lorg.fenixsoft.classloading.SuperClass</code></strong> 的类的初始化。对于用户来说，这并不是一个合法的类型名称，它是一个由虚拟机自动生成的、直接继承于 <code>java.lang.Object</code> 的子类，<strong>创建动作由字节码指令 <code>newarray</code> 触发</strong></li>
</ul>
</li>
<li><p>Demo 3：<strong>常量在编译阶段会存入调用类的常量池，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</strong></p>
  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package org.fennixsoft.classloading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> &#123;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"ConstClass init!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> HELLOWORLD = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> &#123;</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(ConstClass.HELLOWORLD);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>运行结果</strong>：没有输出 <code>ConstClass init!</code></li>
<li>虽然在代码中确实引用了 <code>ConstClass</code> 类的常量 <code>HELLOWORLD</code>，但其实<strong>在编译阶段通过常量传播优化</strong>，已经将此常量的值 <code>hello world</code> 直接存储在 <code>NotInitialization</code> 类的常量池中，以后 <code>NotInitialization</code> 对常量 <code>ConstClass.HELLOWORLD</code> 的引用，实际都被转化为 <code>NotInitialization</code> 类对自身常量池的引用</li>
<li>实际上 <code>NotInitialization</code> 的 Class 文件之中并没有 <code>ConstClass</code> 类的<strong>符号引用入口</strong>，<strong>这两个类在编译成 Class 文件后就已不存在任何联系了</strong></li>
</ul>
</li>
</ul>
<h4 id="5-接口的加载过程"><a href="#5-接口的加载过程" class="headerlink" title="5. 接口的加载过程"></a>5. 接口的加载过程</h4><ul>
<li>接口也有初始化过程，这一点是与类一致的，上面的代码都是用静态代码语句块 <code>static{}</code> 来输出初始化信息的，而<strong>接口中不能使用 <code>static{}</code> 语句块</strong>。但<strong>编译器仍然会为接口生成 <code>&lt;clinit&gt;()</code> 类构造器</strong>，用于初始化接口中所定义的成员变量</li>
<li>接口与类真正有所区别的是前面讲述的<strong>六种“有且仅有”场景中的第三种</strong>：当一个类在初始化时，要求其父类全部都已经初始化过了，但是<strong>一个接口在初始化时，并不要求其父接口全部都完成初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化</strong>    </li>
</ul>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><h4 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h4><ul>
<li><p><strong>概述</strong></p>
<ul>
<li><p><strong>“加载”（Loading）</strong>阶段是整个<strong>“类加载（Class Loading）”</strong>过程中的一个阶段。在加载阶段，Java 虚拟机需要完成以下三件事情</p>
<ul>
<li>通过一个类的<strong>全限定名</strong>来获取定义此类的<strong>二进制字节流</strong></li>
<li>将这个字节流所代表的<strong>静态存储结构</strong>转化为<strong>方法区的运行时数据结构</strong></li>
<li>在内存中生成一个代表这个类的 <strong><code>java.lang.Class</code> 对象</strong>，作为方法区这个类的各种数据的<strong>访问入口</strong></li>
</ul>
</li>
<li><p><strong>《Java 虚拟机规范》对这三点要求其实并不是特别具体，留给虚拟机实现与 Java 应用的灵活度都是相当大的</strong>。许多举足轻重的 Java 技术都建立在这一基础之上，比如</p>
<ul>
<li><strong>从 ZIP 压缩包中读取</strong>，这很常见，最终成为日后 JAR、EAR、WAR 格式的基础</li>
<li><strong>从网络中获取</strong>，这种场景最典型的应用就是 Web Applet</li>
<li><strong>运行时计算生成</strong>，这种场景使用得最多的就是<strong>动态代理</strong>技术，在 <code>java.lang.reflect.Proxy</code> 中就是利用了 <code>ProxyGenerator.generateProxyClass()</code> 来为特定接口生成形式为 <code>*$Proxy</code> 的代理类的二进制字节流</li>
<li><strong>由其他文件生成</strong>，典型场景是 JSP 应用，由 JSP 文件生成对应的 Class 文件</li>
<li><strong>从数据库中读取</strong>，这种场景相对少见，例如有些中间件服务器（如 SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发</li>
<li><strong>从加密文件中获取</strong>，这是典型的防 Class 文件被反编译的保护措施，通过加载时解密 Class 文件来保障程序运行逻辑不被窥探</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>数组加载</strong></p>
<ul>
<li>数组类的情况有所不同，<strong>数组类本身不通过类加载器创建，它是由 Java 虚拟机直接在内存中动态构造出来的</strong></li>
<li>但数组类与类加载器仍然有很密切的关系，<strong>因为数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载</strong>。一个数组类（简称 C）创建过程遵循以下规则<ul>
<li>如果数组的组件类型（<strong>Component Type</strong>，指的是数组去掉一个维度的类型，<del>注意和前面的元素类型区分开来</del>）是<strong>引用类型</strong>，那就<strong>递归加载</strong>这个组件类型，数组 C 将被标识在加载该组件类型的类加载器的类名称空间上</li>
<li>如果数组的组件类型<strong>不是引用类型</strong>（例如 <code>int[]</code> 数组的组件类型为 <code>int</code>），Java 虚拟机将会把数组 C 标记为与引导类加载器关联</li>
<li>数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为 <strong><code>public</code></strong>，可被所有的类和接口访问到</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h4><ul>
<li><p><strong>概述</strong></p>
<ul>
<li><strong>目标</strong>：确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部<strong>约束要求</strong>，保证这些信息被当作代码运行后<strong>不会危害</strong>虚拟机自身的安全</li>
<li><strong>理由</strong>：Class 文件不一定只能由 Java 源码编译而来，Java 虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有错误或有恶意企图的字节码流而导致真个系统受攻击甚至崩溃，所以验证字节码是 <strong>Java 虚拟机保护自身</strong>的一项必要措施。从代码量和耗费的执行性能的角度，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重</li>
<li><strong>设置</strong>：相关验证步骤均可以通过相关虚拟机参数进行设置</li>
</ul>
</li>
<li><p><strong>文件格式验证：验证字节流是否符合 Class 文件格式规范</strong></p>
<ul>
<li>是否以<strong>魔数</strong> <code>0xCAFEBABE</code> 开头</li>
<li><strong>主、次版本号</strong>是否在当前 Java 虚拟机接受范围之内</li>
<li>常量池的<strong>常量</strong>中是否有不被支持的常量类型（检查常量 tag 标志）</li>
<li>指向常量的各种<strong>索引值</strong>中是否有指向不存在的常量或不符合类型的常量</li>
<li><code>CONSTANT_Utf8_info</code> 型的常量中是否有不符合 <strong>UTF-8</strong> 编码的数据</li>
<li>Class 文件中各个部分及文件本身是否有被删除的或附加的<strong>其他信息</strong></li>
</ul>
</li>
<li><p><strong>元数据验证：对字节码描述的信息进行语义分析和语义校验</strong></p>
<ul>
<li>这个类是否有<strong>父类</strong>（除了 <code>java.lang.Object</code> 之外，所有的类都应当有父类）</li>
<li>这个类的父类是否<strong>继承</strong>了不允许被继承的类（被 <code>final</code> 修饰的类）</li>
<li>如果这个类不是<strong>抽象类</strong>，是否实现了其父类或接口中要求实现的所有方法</li>
<li>类中的<strong>字段</strong>、方法是否与父类产生矛盾（例如覆盖了父类的 <code>final</code> 字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）</li>
</ul>
</li>
<li><p><strong>字节码验证：整个验证过程中最复杂的一个阶段</strong></p>
<ul>
<li><p><strong>目标</strong>：通过<strong>数据流分析</strong>和<strong>控制流分析</strong>，确定程序语义是合法的、符合逻辑的</p>
</li>
<li><p><strong>作用</strong>：对类的<strong>方法体（Class 文件中的 <code>Code</code> 属性）</strong>进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为</p>
<ul>
<li>保证任意时刻<strong>操作数栈</strong>的数据类型与指令代码序列都能配合工作（例如不会出现类似于“在操作数栈放置了一个 <code>int</code> 类型的数据，使用时却按 <code>long</code> 类型类载入本地变量表中”这样的情况）</li>
<li>保证任何<strong>跳转指令</strong>都不会跳转到方法体以外的字节码指令上</li>
<li>保证方法体中的<strong>类型转换</strong>总是有效的（例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型、甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的）</li>
</ul>
</li>
<li><p><strong>停机问题（Halting Problem）</strong>：这是<strong>离散数学</strong>中的一个概念，即不能通过程序准确检查出程序是否能在有限时间之内结束运行</p>
<ul>
<li>字节码验证阶段进行了再大量再严密的检查，也依然不能保证程序绝对没有问题</li>
<li>通过程序去校验程序逻辑是无法做到绝对准确的，不可能用程序来准确判定一段程序是否存在 Bug（<del>程序员甩锅的理论依据，go home</del>）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>符号引用验证：对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，即该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源</strong></p>
<ul>
<li>符号引用中通过字符串描述的<strong>全限定名</strong>是否能找到对应的类</li>
<li>在指定类中是否存在符合方法的<strong>字段描述</strong>及简单名称所描述的方法和字段</li>
<li>符号引用中的类、字段、方法的<strong>可访问性</strong>（<code>private</code>、<code>protected</code>、<code>public</code>、<code>&lt;package&gt;</code>）是否可被当前类访问</li>
</ul>
</li>
</ul>
<h4 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h4><ul>
<li><p><strong>概念</strong></p>
<ul>
<li><strong>为静态变量分配内存并设置默认值（不包括 <code>final</code> 修饰的情况）</strong></li>
</ul>
</li>
<li><p><strong>存储区域</strong></p>
<ul>
<li>为静态变量分配内存是在<strong>方法区</strong>上进行，但方法区本身是一个<strong>逻辑上</strong>的区域</li>
<li><strong>在 JDK 7 及之前</strong>，HotSpot 虚拟机使用永久代来实现方法区，是符合这种逻辑概念的</li>
<li><strong>在 JDK 8 及之后</strong>，静态变量会随着 Class 对象一起存放在 Java 堆中</li>
</ul>
</li>
<li><p><strong>操作对象</strong></p>
<ul>
<li>准备阶段进行内存分配<strong>仅针对静态变量</strong>，<strong>不包括实例变量</strong></li>
<li>实例变量将会在对象实例化时随着对象一起分配在 <strong>Java 堆</strong>中</li>
</ul>
</li>
<li><p><strong>特殊情况</strong></p>
<ul>
<li>如果静态变量被 <strong><code>final</code></strong> 修饰，那么编译时 Javac 将会为该变量生成 <code>ConstantValue</code> 属性</li>
<li>在准备阶段虚拟机根据 <strong><code>ConstantValue</code></strong> 的设置将变量初始化赋值为设置的值</li>
</ul>
</li>
</ul>
<h4 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h4><ul>
<li><p><strong>概念</strong></p>
<ul>
<li><p>Java 虚拟机将常量池内的<strong>符号引用</strong>替换为<strong>直接引用</strong></p>
</li>
<li><p><strong>符号引用（Symbolic References）</strong></p>
<ul>
<li>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可</li>
<li>符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容</li>
</ul>
</li>
<li><p><strong>直接引用（Direct References）</strong></p>
<ul>
<li>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄</li>
<li>直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同</li>
<li>如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>过程</strong></p>
<ul>
<li>解析动作主要针对<strong>类或接口</strong>、<strong>字段</strong>、<strong>类方法</strong>、<strong>接口方法</strong>、<strong>方法类型</strong>、<strong>方法句柄</strong>和<strong>调用点限定符</strong>这 7 类符号引用进行</li>
<li>分别对应于常量池的 <code>CONSTANT_Class_info</code>、<code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Methodref_info</code>、<code>CONSTANT_InterfaceMethodref_info</code>、<code>CONSTANT_MethodType_info</code>、<code>CONSTANT_Dynamic_info</code> 和 <code>CONSTANT_InvokeDynamic_info</code> 8 种常量类型</li>
<li>主要思路：<strong>递归查找</strong>对应的数据信息，并进行相应的<strong>权限验证</strong>，如果没有相关访问权限则抛出异常</li>
</ul>
</li>
<li><p><strong>注意</strong></p>
<ul>
<li>在接口方法解析的过程中，<strong>在 JDK 9 中增加了接口的静态私有方法，也有了模块化的访问约束</strong>。所以从 JDK 9 起，接口方法的访问也完全有可能因访问权限控制而出现 <code>java.lang.IllegalAccessError</code> 异常</li>
</ul>
</li>
</ul>
<h4 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h4><ul>
<li><p><strong>概述</strong></p>
<ul>
<li><strong>类的初始化是类加载过程的最后一个步骤</strong>，在加载阶段用户应用程序可以通过<strong>自定义类加载器</strong>的方式局部参与，连接阶段（验证、准备、解析）由 Java 虚拟机来主导控制</li>
<li><strong>直到初始化阶段</strong>，Java 虚拟机才真正开始执行类中编写的 Java 代码，将主导权移交给应用程序</li>
</ul>
</li>
<li><p><strong>概念</strong></p>
<ul>
<li>初始化阶段会根据程序员通过程序编码制定的主观计划去<strong>初始化静态变量和其他资源</strong></li>
<li><strong>初始化阶段就是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程</strong>，<code>&lt;clinit&gt;()</code> 方法并不是程序员在 Java 代码中直接编写的方法，<strong>它是 Javac 编译器的自动生成物</strong></li>
</ul>
</li>
<li><p><strong><code>&lt;clinit&gt;()</code> 方法概述</strong></p>
<ul>
<li><code>&lt;clinit&gt;()</code> 方法是由编译器自动收集类中的所有<strong>静态变量</strong>的赋值动作和<strong>静态语句块</strong>（<code>&lt;static{}&gt;</code> 块）中的语句合并产生的，编译器收集的顺序是由语句<strong>在源文件中出现的顺序</strong>决定的。<strong>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值（可以正常编译通过），但是不能访问（编译器提示：非法向前引用）</strong></li>
<li><code>&lt;clinit&gt;()</code> 方法与类的构造函数（即在虚拟机视角中的实例构造器 <code>&lt;init&gt;()</code> 方法）不同，<strong>它不需要显示调用父类构造器，Java 虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕</strong>。因此，在 Java 虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code> 方法的类型肯定是 <strong><code>java.lang.Object</code></strong>。由于父类的 <code>&lt;clinit&gt;()</code> 方法先执行，<strong>即父类中定义的静态语句块要优先于子类的变量赋值操作</strong></li>
<li><strong><code>&lt;clinit&gt;()</code> 方法对于类或接口来说并不是必须的</strong>，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 <code>&lt;clinit&gt;()</code> 方法</li>
<li><strong>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成 <code>&lt;clinit&gt;()</code> 方法</strong>。但接口与类不同的是，<strong>执行接口的 <code>&lt;clinit&gt;()</code> 方法不需要先执行父接口的 <code>&lt;clinit&gt;()</code> 方法</strong>，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，<strong>接口的实现类在初始化时也一样不会执行接口的 <code>&lt;clinit&gt;()</code> 方法</strong></li>
<li>Java 虚拟机必须保证一个类的 <code>&lt;clinit&gt;()</code> 方法<strong>在多线程环境中被正确地加锁同步</strong>。如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的 <code>&lt;clinit&gt;()</code> 方法，其他线程都需要阻塞等待，直到活动线程执行完毕 <code>&lt;clinit&gt;()</code> 方法</li>
</ul>
</li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="1-类与类加载器"><a href="#1-类与类加载器" class="headerlink" title="1. 类与类加载器"></a>1. 类与类加载器</h4><ul>
<li><p><strong>概述</strong></p>
<ul>
<li>类加载器虽然只用于实现类的加载动作，但它在 Java 程序中起到的作用<strong>远超类加载阶段</strong></li>
<li>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在 Java 虚拟机中的唯一性，每一个类加载器都拥有一个独立的类名称空间</li>
<li>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类来源于同一个 Class 文件，被同一个 Java 虚拟机加载，<strong>只要加载它们的类加载器不同，那这两个类必定不相等</strong></li>
<li>这里的“相等”，包括<strong>代表类的 Class 对象</strong>的 <strong><code>equals()</code></strong> 方法、<strong><code>isAssignableFrom()</code></strong> 方法、<strong><code>isInstance()</code></strong> 方法的返回结果，也包括了使用 <strong><code>instanceof</code></strong> 关键字做对象所属关系判定等情况</li>
</ul>
</li>
<li><p><strong>Demo</strong>：不同的类加载器对 <code>instanceof</code> 关键字运算的结果的影响</p>
  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> ClassLoaderTest &#123;</span><br><span class="line">	<span class="built_in">public</span> static <span class="type">void</span> main(String[] args) throws <span class="keyword">Exception</span> &#123;</span><br><span class="line">		ClassLoader myLoader = <span class="built_in">new</span> ClassLoader () &#123;</span><br><span class="line">			@Override</span><br><span class="line">			<span class="built_in">public</span> <span class="keyword">Class</span>&lt;?&gt; loadClass(String <span class="type">name</span>) throws ClassNotFoundException &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					String  fileName = <span class="type">name</span>.substring(<span class="type">name</span>.lastIndexOf(".") + <span class="number">1</span>) + ".class";</span><br><span class="line">					InputStream <span class="keyword">is</span> = getClass().getResourceAsStream(fileName);</span><br><span class="line">					<span class="keyword">if</span> (<span class="keyword">is</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">return</span> super.loadClass(<span class="type">name</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					byte[] b = <span class="built_in">new</span> byte[<span class="keyword">is</span>.available()];</span><br><span class="line">					<span class="keyword">is</span>.<span class="keyword">read</span>(b);</span><br><span class="line">					<span class="keyword">return</span> defineClass(<span class="type">name</span>, b, <span class="number">0</span>, b.length);</span><br><span class="line">				&#125; catch (IOException e) &#123;</span><br><span class="line">					throw <span class="built_in">new</span> ClassNotFoundException(<span class="type">name</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">Object</span> obj = myLoader.loadClass("org.fenixsoft.classloading.ClassLoaderTest").newInstance();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">System</span>.<span class="keyword">out</span>.println(obj.getClass());</span><br><span class="line">	<span class="keyword">System</span>.<span class="keyword">out</span>.println(obj instanceof org.fenixsoft.classloading.ClassLoaderTest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果：<code>org.fenixsoft.classloading.ClassLoaderTest</code> 和 <code>false</code></li>
</ul>
</li>
</ul>
<h4 id="2-双亲委派模型（Parents-Delegation-Model）"><a href="#2-双亲委派模型（Parents-Delegation-Model）" class="headerlink" title="2. 双亲委派模型（Parents Delegation Model）"></a>2. 双亲委派模型（Parents Delegation Model）</h4><ul>
<li><p><strong>示意图</strong></p>
<p>  <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp37q7qrvjj30dn0gh0u0.jpg" alt="双亲委派模型"></p>
</li>
<li><p><strong>类加载器概述</strong></p>
<ul>
<li><p><strong>从 Java 虚拟机的角度</strong>：只存在两种不同的类加载器</p>
<ul>
<li>一种是<strong>启动类加载器（Bootstrap ClassLoader）</strong>，这个类加载器使用 C++ 语言实现（只限 HotSpot），是虚拟机自身的一部分</li>
<li>一种就是<strong>其他所有的类加载器</strong>，这些类加载器使用 Java 实现，独立存在于虚拟机外部且全部继承自抽象类 <code>java.lang.ClassLoader</code></li>
</ul>
</li>
<li><p><strong>从 Java 开发人员的角度</strong></p>
<ul>
<li>从 <strong>JDK 1.2</strong> 版本，Java 一直保持<strong>三层类加载器 + 双亲委派</strong>的类加载架构</li>
<li>从 <strong>JDK 9</strong> 版本，出现了<strong>模块化系统</strong>，对三层架构有了一些调整</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>类加载器分类</strong></p>
<ul>
<li><p><strong>启动类加载器（Bootstrap ClassLoader）</strong></p>
<ul>
<li>负责加载存放在 <strong><code>&lt;JAVA_HOME&gt;\lib</code> 目录</strong>，或者被 <strong><code>-Xbootclasspath</code> 参数</strong>所指定的路径中存放的，而且是 Java 虚拟机能够识别的（按照文件名识别，如 rt.jar、tools.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）<strong>类库</strong>加载到虚拟机的内存中</li>
<li><strong>启动类加载器无法被 Java 程序直接引用</strong>，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器去处理，那直接使用 <strong><code>null</code></strong> 代替即可</li>
</ul>
</li>
<li><p><strong>扩展类加载器（Extension ClassLoader）</strong></p>
<ul>
<li>该类加载器是在类 <code>sun.misc.Launcher$ExtClassLoader</code> 中实现</li>
<li>负责加载 <strong><code>&lt;JAVA_HOME&gt;\lib\ext</code></strong> 目录中，或者被 <strong><code>java.ext.dirs</code> 系统变量</strong>所指定的路径中所有的类库</li>
<li>这是一种 Java 系统类库的<strong>扩展机制</strong>，JDK 的开发团队允许开发者将具有通用性的类库放置在 <code>ext</code> 目录里以扩展 Java SE 的功能。在 <strong>JDK 9</strong> 之后，这种扩展机制被<strong>模块化</strong>带来的天然的扩展能力所取代</li>
</ul>
</li>
<li><p><strong>应用程序类加载器（Application ClassLoader）</strong></p>
<ul>
<li>该类加载器由 <code>sun.misc.Launcher$AppClassLoader</code> 来实现。由于应用程序类加载器是 <code>ClassLoader</code> 类中的 <code>getSystemClassLoader()</code> 方法的返回值，所以有些场合中也称它为<strong>“系统类加载器”</strong></li>
<li>负责加载<strong>用户类路径（ClassPath）</strong>上所有的类库，开发者同样可以直接在代码中使用这个类加载器。<strong>如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>工作过程</strong></p>
<ul>
<li>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求<strong>委派给父类加载器</strong>去完成，每一个层次的类加载器都是如此</li>
<li>因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当<strong>父加载器反馈</strong>自己无法完成这个加载请求（它的搜索范围内没有找到所需的类）时，子加载器才会尝试自己去完成加载</li>
</ul>
</li>
<li><p><strong>优点</strong></p>
<ul>
<li>双亲委派模型很好地解决了各个类加载器协作时<strong>基础类型的一致性问题：越基础的类由越上层的加载器进行加载</strong></li>
<li>Java 中<strong>类随着它的类加载器</strong>一起具备了一种<strong>带有优先级的层级关系</strong>，可以保证 Java 类型体系中<strong>最基础</strong>的行为，对保证 Java 程序的<strong>稳定运行</strong>极为重要</li>
</ul>
</li>
<li><p><strong><code>loadClass()</code> 方法实现</strong></p>
  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized Class&lt;?&gt; load<span class="constructor">Class(String <span class="params">name</span>, <span class="params">boolean</span> <span class="params">resolve</span>)</span> throws ClassNotFoundException &#123;</span><br><span class="line">	<span class="comment">// 首先，检查请求的类是否已经被加载过了</span></span><br><span class="line">	Class c = find<span class="constructor">LoadedClass(<span class="params">name</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span> (c<span class="operator"> == </span>null) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (parent != null) &#123;</span><br><span class="line">				c = parent.load<span class="constructor">Class(<span class="params">name</span>, <span class="params">false</span>)</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				c = fiind<span class="constructor">BootStrapClassOrNull(<span class="params">name</span>)</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">			<span class="comment">// 如果父类加载器抛出 ClassNotFoundException，说明父类加载器无法完成加载请求</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (c<span class="operator"> == </span>null) &#123;</span><br><span class="line">			<span class="comment">// 在父类加载器无法加载时，再调用本身的 findClass() 方法来进行类加载</span></span><br><span class="line">			c = find<span class="constructor">Class(<span class="params">name</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">		resolve<span class="constructor">Class(<span class="params">c</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>首先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的 <code>loadClass()</code> 方法，若父加载器为空则默认使用启动类加载器作为父加载器</strong></li>
<li><strong>如果父类加载器加载失败抛出 <code>ClassNotFoundexception</code> 异常，再调用自己的 <code>findClass()</code> 方法尝试进行加载</strong></li>
</ul>
</li>
</ul>
<h4 id="3-破坏双亲委派模型"><a href="#3-破坏双亲委派模型" class="headerlink" title="3. 破坏双亲委派模型"></a>3. 破坏双亲委派模型</h4><ul>
<li><p><strong>概述</strong></p>
<ul>
<li><strong>双亲委派模型并非强制性约束</strong>，而是 Java 设计者<strong>推荐</strong>给开发者们的类加载器实现方式</li>
</ul>
</li>
<li><p><strong>双亲委派模型的 “3 次破坏”</strong></p>
<ol>
<li><p><strong>第一次</strong></p>
<ul>
<li>发生在双亲委派模型出现之前，即 JDK 1.2 版本之前，<strong>因为类加载器概念和抽象类 <code>java.lang.ClassLoader</code> 是在第一个版本就已经存在</strong></li>
<li>面对 JDK 1.2 版本的双亲委派模式，<strong>考虑到兼容性（避免 <code>loadClass()</code> 方法被子类覆盖），所以增加了一个 <code>protected</code> 的 <code>findClass()</code> 方法，并引导用户编写类加载逻辑时尽可能去重写这个方法</strong></li>
</ul>
</li>
<li><p><strong>第二次</strong></p>
<ul>
<li>由于模型本身的<strong>设计缺陷</strong>导致。双亲委派模型很好地解决了各个类加载器协作时基础类型的一致性问题，但是如果有基础类型又要<strong>调用回用户的代码</strong>则无能为力</li>
<li>Java 的设计团队只好引入一个<strong>不太优雅</strong>的设计：<strong>线程上下文类加载器（Thread Context ClassLoader）</strong>。这个类加载器可以通过 <code>java.lang.Thread</code> 类的 <strong><code>setContextClassLoader()</code></strong> 方法进行设置。如果创建线程时还未设置，它将会从父线程中继承一个；<strong>如果在应用程序的全局范围内都没有设置过的话，那这个线程上下文类加载器默认就是应用程序类加载器</strong></li>
<li>这种行为实际上是打通了双亲委派模型的层次结构来<strong>逆向使用类加载器</strong>，已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事</li>
</ul>
</li>
<li><p><strong>第三次</strong></p>
<ul>
<li>由于用户对程序<strong>动态性</strong>的追求而导致的，这里的动态性指的是：代码热替换（Hot Swap）、模块热部署（Hot Deployment）。其中，IBM 主导的关于 Java 模块化规范的 <strong>OSGi</strong> 技术是其中典型的代表</li>
<li>OSGi 实现模块化热部署的关键是<strong>它自定义的类加载器机制的实现</strong>，每一个程序模块（<strong>OSGi 中称为 Bundle</strong>）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 环境下，类加载器不再是双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的<strong>网状结构</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="Java-模块化系统"><a href="#Java-模块化系统" class="headerlink" title="Java 模块化系统"></a>Java 模块化系统</h3><ul>
<li><p><strong>关键目标</strong></p>
<ul>
<li>在 JDK 9 中引入的 <strong>Java 模块化系统（Java Platform Module System，JPMS）</strong>是对 Java 技术的一次重要升级，为了能够实现模块化的关键目标：<strong>可配置的封装隔离机制</strong></li>
</ul>
</li>
<li><p><strong>模块定义</strong>：JDK 9 的模块不仅仅像之前的 JAR 包那样只是简单充当代码容器，除了代码，Java 的模块定义还包括以下内容</p>
<ul>
<li>依赖其他模块的列表</li>
<li>导出的包列表，即其他模块可以使用的列表</li>
<li>开放的包列表，即其他模块可以反射访问模块的列表</li>
<li>使用的服务列表</li>
<li>提供服务的实现列表</li>
</ul>
</li>
<li><p><strong>解决的问题</strong></p>
<ul>
<li>可配置的封装隔离机制首先解决了 JDK 9 之前基于<strong>类路径（ClassPath）</strong>来查找依赖的可靠性问题</li>
<li>其次还解决了原来类路径上跨 JAR 文件的 <strong><code>public</code> 类型的可访问性问题</strong>。JDK 9 中的 <code>public</code> 类型不再意味着程序的所有地方的代码都可以随意访问到它们，<strong>模块提供了更精细的可访问性控制，必须明确声明其中哪一些 <code>public</code> 的类型可以被其他哪一些模块访问</strong>，使出现 <strong><code>ClassNotFoundException</code></strong> 异常的概率大大降低</li>
</ul>
</li>
</ul>
<h4 id="1-模块的兼容性"><a href="#1-模块的兼容性" class="headerlink" title="1. 模块的兼容性"></a>1. 模块的兼容性</h4><ul>
<li>为了使可配置的封装隔离机制能够兼容传统的类路径查找机制，JDK 9 提出了与类路径（ClassPath）相对应的<strong>模块路径（ModulePath）</strong>概念</li>
<li>JDK 9 的可配置的封装隔离机制也<strong>仍然保证了传统程序</strong>可以访问到所有标准类库模块中导出的包</li>
</ul>
<h4 id="2-模块化下的类加载器"><a href="#2-模块化下的类加载器" class="headerlink" title="2. 模块化下的类加载器"></a>2. 模块化下的类加载器</h4><ul>
<li><p><strong>对比示意图</strong></p>
<p>  <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp3bqjp8kaj30sg0lc48y.jpg" alt="对比示意图"></p>
</li>
<li><p><strong>概述</strong></p>
<ul>
<li>扩展类加载器（Extension ClassLoader）被<strong>平台类加载器（Platfor ClassLoader）</strong>取代</li>
<li>启动类加载器、平台类加载器、应用程序类加载器全部继承于 <code>jdk.internal.loader.BuiltinClassLoader</code>，在 <strong><code>BuiltinClassLoader</code></strong> 中实现了新的模块化架构下类如何从模块中加载的逻辑，以及模块中资源可访问性的处理</li>
<li>类加载的委派关系发生了变动，也许可以算是对双亲委派的<strong>第 4 次破坏</strong>。JDK 9 中的模块化系统明确规定了<strong>三个类加载器负责各自加载的模块</strong></li>
</ul>
</li>
</ul>
<h2 id="六-Java-内存模型概述"><a href="#六-Java-内存模型概述" class="headerlink" title="六. Java 内存模型概述"></a>六. Java 内存模型概述</h2><ul>
<li><strong>Java 内存模型（Java Memory Model, JMM）</strong>：屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能<strong>达到一致的内存访问</strong>效果</li>
<li>特指：在 <strong>JDK 1.2</strong> 之后建立起来并在 <strong>JDK 5</strong> 中完善过的内存模型</li>
</ul>
<h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><h4 id="1-线程、主内存、工作内存三者的交互关系"><a href="#1-线程、主内存、工作内存三者的交互关系" class="headerlink" title="1. 线程、主内存、工作内存三者的交互关系"></a>1. 线程、主内存、工作内存三者的交互关系</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp3kukyavcj30rq0cktcu.jpg" alt="线程、主内存、工作内存三者的交互关系"></p>
<h4 id="2-Java-内存模型的主要目的"><a href="#2-Java-内存模型的主要目的" class="headerlink" title="2. Java 内存模型的主要目的"></a>2. Java 内存模型的主要目的</h4><ul>
<li><p><strong>定义程序中各种变量的访问规则</strong>，即关注在虚拟机中把变量值<strong>存储到内存</strong>和<strong>从内存中取出</strong>变量值这样的底层细节</p>
</li>
<li><p>此处的<strong>变量（Variables）</strong>与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题</p>
<blockquote>
<p>如果局部变量是一个 <strong>reference 类型</strong>，它引用的对象在 <strong>Java 堆</strong>中可被各个线程共享，但是 reference 本身在 <strong>Java 栈</strong>的局部变量表中是线程私有的</p>
</blockquote>
</li>
<li><p>为了获得更好的执行效能，Java 内存模型<strong>没有限制执行引擎</strong>使用处理器的特定寄存器或缓存来和主存进行交互，<strong>也没有限制即时编译器</strong>是否要进行调整代码执行顺序这类优化措施</p>
</li>
</ul>
<h4 id="3-Java-内存模型含义"><a href="#3-Java-内存模型含义" class="headerlink" title="3. Java 内存模型含义"></a>3. Java 内存模型含义</h4><ul>
<li><p><strong>所有的变量都存储在主内存（Main Memory）中</strong>（可以类比物理硬件层主内存，但物理上它仅是虚拟机内存的一部分）</p>
</li>
<li><p><strong>每条线程还有自己的工作内存（Working Memory）</strong>（可类比处理器高速缓存），线程的工作内存中保存了被该线程使用的变量的<strong>主内存副本</strong>。线程对变量的所有操作（读取、赋值等）<strong>都必须在工作内存中进行</strong>，而不能直接读写主内存中的数据</p>
</li>
<li><p>不同的线程之间也无法直接访问对方工作内存中的变量，<strong>线程间变量值的传递均需要通过主内存来完成</strong></p>
<blockquote>
<p><strong>工作内存中主内存副本</strong>：一个对象的<strong>引用</strong>、对象中某个在线程<strong>访问到的字段</strong>是有可能被复制的，<strong>但不会有虚拟机把整个对象复制一次</strong></p>
<p><strong>volatile</strong> 变量依然有工作内存的拷贝，但由于它特殊的操作顺序性，<strong>看起来如同直接在主内存中读写访问一样</strong></p>
</blockquote>
</li>
</ul>
<h4 id="4-Java-内存模型与-JVM-运行时数据区域划分的区别"><a href="#4-Java-内存模型与-JVM-运行时数据区域划分的区别" class="headerlink" title="4. Java 内存模型与 JVM 运行时数据区域划分的区别"></a>4. Java 内存模型与 JVM 运行时数据区域划分的区别</h4><ul>
<li><strong>二者并不是同一个层次的对内存的划分，基本上是没有任何关系的</strong></li>
<li><strong>如果二者一定要勉强对应起来</strong>，那么从变量、主内存、工作内容的定义来看，主内存主要对应于 Java 堆中的对象实例数据部分；工作内存对应于虚拟机栈中的部分区域</li>
<li><strong>从更基础的层次</strong>，主内存直接对应于物理硬件的内存；为了获取更好的运行速度，虚拟机（或是硬件、操作系统本身的优化措施）<br>可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问的是工作内存</li>
</ul>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><ul>
<li>关于主内存与工作内存之间具体的<strong>交互协议</strong>的实现细节，<strong>Java 内存模型定义了：lock（锁定）、unlock（解锁）、load（载入）、use（使用）、assign（赋值）、store（存储）、write（写入）8 种原子性操作</strong>（对于 <code>double</code> 和 <code>long</code> 类型的变量来说，<code>load</code>、<code>store</code>、<code>read</code> 和 <code>write</code> 操作在某些平台上允许有例外）</li>
<li>除此之外，Java 内存模型还规定了执行 8 种基本操作时必须要满足的 <strong>8 个规则</strong>（见《深入理解 Java 虚拟机（第三版）第 443 页》）</li>
</ul>
<h3 id="针对-volatile-型变量的特殊规则"><a href="#针对-volatile-型变量的特殊规则" class="headerlink" title="针对 volatile 型变量的特殊规则"></a>针对 <code>volatile</code> 型变量的特殊规则</h3><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h4><ul>
<li><strong>关键字 <code>volatile</code> 是 Java 虚拟机提供的最轻量级的同步机制</strong></li>
</ul>
<h4 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h4><ul>
<li><p>保证被 <code>volatile</code> 修饰的变量<strong>对所有线程的内存可见性</strong></p>
<blockquote>
<p><code>volatile</code> 变量在各个线程的工作内存中是不存在一致性问题的（从物理存储的角度看，各个线程的工作内存中 <code>volatile</code> 变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以人文不存在不一致问题）</p>
<p>但是，<strong>Java 里面的运算操作符并非原子操作，这导致 <code>volatile</code> 变量的非原子操作运算在并发环境下一样是不安全的</strong></p>
<p>在需要保证原子性操作的运算场景中，<strong>可以通过加锁：<code>synchronized</code>、<code>java.util.concurrent</code> 中的锁或原子类来保证原子性</strong></p>
</blockquote>
</li>
<li><p><strong>禁止指令重排（Instruction Reorder）</strong>，即 Java 内存模型中描述的<strong>线程内表现为串行的语义（Within-Thread As-If-Serial Semantics）</strong></p>
<blockquote>
<p><strong><code>volatile</code> 禁止指令重排的语义在 JDK 5 中才被完全修复</strong>，此前版本的 JDK 中即使将变量声明为 <code>volatile</code> 也仍然不能完全避免指令重排所导致的问题，这一点也是 JDK 5 之前版本的 Java 中无法安全使用 DCL（双锁检测）来实现单例模式的原因</p>
</blockquote>
</li>
</ul>
<h4 id="3-性能"><a href="#3-性能" class="headerlink" title="3. 性能"></a>3. 性能</h4><ul>
<li><strong>大多数情况下，<code>volatile</code> 的同步机制性能确实要优于锁</strong>（使用 <code>synchronized</code> 或 <code>java.util.concurrent</code> 包里面的锁）。但是优于虚拟机对锁实行的许多消除和优化，<strong>很难确切说 <code>volatile</code> 就会比 <code>synchronized</code> 快上多少</strong></li>
<li><code>volatile</code> 横向对比原则：<strong>读操作</strong>的性能消耗与普通变量几乎没有什么差别，但是<strong>写操作</strong>可能会慢一些（因为它需要在本地代码中插入许多<strong>内存屏障（Memory Barrier 或 Memory Fence）指令</strong>来保证处理器不发生<strong>乱序执行（OutOfOrder Execution）</strong>）</li>
</ul>
<h3 id="针对-long-和-double-型变量的特殊规则"><a href="#针对-long-和-double-型变量的特殊规则" class="headerlink" title="针对 long 和 double 型变量的特殊规则"></a>针对 <code>long</code> 和 <code>double</code> 型变量的特殊规则</h3><ul>
<li><strong><code>long</code> 和 <code>double</code> 的非原子性协定（Non-Atomic Treatment of double and long Variables）</strong>：Java 内存模型允许虚拟机将没有被 <code>volatile</code> 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现自行选择是否要保证 64 位数据类型的 load、store、read 和 write 这四个操作的原子性</li>
<li>在实际开发中，除非该数据有明确可知的线程竞争，否则在编写代码时<strong>一般不需要</strong>因为这个原因刻意把用到的 <code>long</code> 和 <code>double</code> 变量专门声明为 <code>volatile</code></li>
</ul>
<h3 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1. 概述"></a>1. 概述</h4><ul>
<li>Java 内存模型是围绕着<strong>在并发过程中</strong>如何处理<strong>原子性</strong>、<strong>可见性</strong>、<strong>有序性</strong>这三个特征来建立的</li>
</ul>
<h4 id="2-原子性（Atomicity）"><a href="#2-原子性（Atomicity）" class="headerlink" title="2. 原子性（Atomicity）"></a>2. 原子性（Atomicity）</h4><ul>
<li>大致可以认为：<strong>基本数据类型的访问、读写都是具备原子性的（例外就是 <code>long</code> 和 <code>double</code> 的非原子性协定）</strong></li>
<li>在需要更大范围的原子性保证的场景：Java 内存模型提供了 <strong>lock</strong> 和 <strong>unlock</strong> 操作来满足这种需求，对应 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 字节码指令。反映到 Java 代码中就是同步块：<strong><code>synchronized</code> 关键字，因此在 <code>synchronized</code> 块之间的操作也具备原子性</strong></li>
</ul>
<h4 id="3-可见性（Visibility）"><a href="#3-可见性（Visibility）" class="headerlink" title="3. 可见性（Visibility）"></a>3. 可见性（Visibility）</h4><ul>
<li>概念：当一个线程修改了<strong>共享变量</strong>的值时，其他线程能<strong>立即得知</strong>这个修改</li>
<li><strong><code>volatile</code> 的特殊性保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新</strong>，普通变量保证不了这一点</li>
<li>除了 <code>volatile</code>，<strong>Java 还有两个关键字 <code>synchronized</code> 和 <code>final</code> 能实现可见性</strong><ul>
<li><strong><code>synchronized</code></strong>：由“对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write操作）”这条规则获得</li>
<li><strong><code>final</code></strong>：被 <code>final</code> 修饰的字段在构造器中一旦被初始化完成，并且构造器没有把 <code>this</code> 的引用传递出去（<strong><code>this</code> 引用逃逸</strong>是一件很危险的事：其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见 <code>final</code> 字段的值</li>
</ul>
</li>
</ul>
<h4 id="4-有序性（Ordering）"><a href="#4-有序性（Ordering）" class="headerlink" title="4. 有序性（Ordering）"></a>4. 有序性（Ordering）</h4><ul>
<li><p><strong>Java 程序中天然的有序性</strong>：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的</p>
<blockquote>
<p>前半句是指“线程内似表现为串行的语义”（Within-Thread As-If-Serial Semantics）（<del>与上面这个的含义解释冲突了</del>）</p>
<p>后半句是指“指令重排”现象和“工作内存与主内存同步延迟”现象</p>
</blockquote>
</li>
<li><p>Java 提供了 <strong><code>volatile</code></strong> 和 <strong><code>synchronized</code></strong> 两个关键字来保证线程之间操作的有序性</p>
<ul>
<li><strong><code>volatile</code></strong>：本身就包含了禁止指令重排的语义</li>
<li><strong><code>synchronized</code></strong>：由“一个变量在同一时刻只允许一条线程对其进行 lock 操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入</li>
</ul>
</li>
</ul>
<h3 id="先行发生（Happens-Before）原则"><a href="#先行发生（Happens-Before）原则" class="headerlink" title="先行发生（Happens-Before）原则"></a>先行发生（Happens-Before）原则</h3><h4 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1. 概念"></a>1. 概念</h4><ul>
<li><strong>先行发生是 Java 内存模型中定义的两项操作之间的偏序关系</strong></li>
<li>比如，操作 A 先行发生于操作 B，其实就是说在发送操作 B 之前，<strong>操作 A 产生的影响能被操作 B 观察到</strong>，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等</li>
</ul>
<h4 id="2-内容"><a href="#2-内容" class="headerlink" title="2. 内容"></a>2. 内容</h4><ul>
<li>Java 内存模型下无须任何同步手段就能成立的有且仅有的先行发生规则：<strong>程序次序规则</strong>（Program Order Rule）、<strong>管程锁定规则</strong>（Monitor Lock Rule）、<strong><code>volatile</code> 变量规则</strong>（Volatile Variable Rule）、<strong>线程启动规则</strong>（Thread Start Rule）、<strong>线程终止规则</strong>（Thread Termination Rule）、<strong>线程中断规则</strong>（Thread Interruption Rule）、<strong>对象终结规则</strong>（Finalizer Rule）、<strong>传递性</strong>（Transitivity）</li>
</ul>
<h4 id="3-结论"><a href="#3-结论" class="headerlink" title="3. 结论"></a>3. 结论</h4><ul>
<li><strong>时间先后顺序与先行发生原则之间基本没有因果关系，衡量并发安全问题时一切必须以先行发生原则为准</strong></li>
</ul>

    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;margin-top:80px">-------------------- 本文结束<i class="fa fa-paw"></i>感谢您的阅读 --------------------</div>
    
</div>
      
    </div>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>隋钟元
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://24suixinsuoyu.com/2020/04/10/Java-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="Java 编程基础（七）：深入理解 Java 虚拟机">http://24suixinsuoyu.com/2020/04/10/Java-编程基础（七）：深入理解-Java-虚拟机/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> 编程基础</a>
              <a href="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag"><i class="fa fa-tag"></i> 深入理解 Java 虚拟机</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/10/Java-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%96%B9%E6%B3%95%E5%8F%8A%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/" rel="prev" title="Java 编程基础（六）：方法及方法调用">
      <i class="fa fa-chevron-left"></i> Java 编程基础（六）：方法及方法调用
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/11/Java-%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80/" rel="next" title="Java 理解数据背后的二进制（一）：二进制基础">
      Java 理解数据背后的二进制（一）：二进制基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-JVM-运行时数据区域概述"><span class="nav-text">一. JVM 运行时数据区域概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-概述"><span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-示意图"><span class="nav-text">2. 示意图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-线程私有内存"><span class="nav-text">3. 线程私有内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-程序计数器（Program-Counter-Register）"><span class="nav-text">3.1 程序计数器（Program Counter Register）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-Java-虚拟机栈（JVM-Stack）"><span class="nav-text">3.2 Java 虚拟机栈（JVM Stack）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-本地方法栈（Native-Method-Stack）"><span class="nav-text">3.3 本地方法栈（Native Method Stack）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-线程共享内存"><span class="nav-text">4. 线程共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-堆（Heap）"><span class="nav-text">4.1 堆（Heap）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-方法区（Method-Area）"><span class="nav-text">4.2 方法区（Method Area）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-运行时常量池（Runtime-Constant-Pool）"><span class="nav-text">4.3 运行时常量池（Runtime Constant Pool）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-直接内存（Direct-Memory）"><span class="nav-text">5. 直接内存（Direct Memory）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-垃圾回收判定算法及四种引用概述"><span class="nav-text">二. 垃圾回收判定算法及四种引用概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-概述-1"><span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-引用计数（Reference-Counting）算法"><span class="nav-text">2. 引用计数（Reference Counting）算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-思路"><span class="nav-text">2.1 思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-优点"><span class="nav-text">2.2 优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-缺点"><span class="nav-text">2.3 缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-应用"><span class="nav-text">2.4 应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-可达性分析（Reachability-Analysis）算法"><span class="nav-text">3. 可达性分析（Reachability Analysis）算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-示意图"><span class="nav-text">3.1 示意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-思路"><span class="nav-text">3.2 思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-应用"><span class="nav-text">3.3 应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-GC-Roots-对象"><span class="nav-text">3.4 GC Roots 对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-四种引用类型概述"><span class="nav-text">4. 四种引用类型概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-强引用（Strong-Reference）"><span class="nav-text">4.1 强引用（Strong Reference）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-软引用（Soft-Reference）"><span class="nav-text">4.2 软引用（Soft Reference）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-弱引用（Weak-Reference）"><span class="nav-text">4.3 弱引用（Weak Reference）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-虚引用（Phantom-Reference）"><span class="nav-text">4.4 虚引用（Phantom Reference）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-两次标记过程与垃圾回收方法调用概述"><span class="nav-text">5. 两次标记过程与垃圾回收方法调用概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-两次标记过程"><span class="nav-text">5.1 两次标记过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-finalize-方法概述"><span class="nav-text">5.2 finalize() 方法概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-gc-方法概述"><span class="nav-text">5.3 gc() 方法概述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-方法区内存回收概述"><span class="nav-text">6. 方法区内存回收概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-常量回收"><span class="nav-text">6.1 常量回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-类型卸载"><span class="nav-text">6.2 类型卸载</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-垃圾回收算法概述"><span class="nav-text">三. 垃圾回收算法概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-分代回收理论概述"><span class="nav-text">1. 分代回收理论概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-标记-清除（Mark-Sweep）算法"><span class="nav-text">2. 标记-清除（Mark-Sweep）算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-标记-复制（Mark-Semispace-Copying）算法"><span class="nav-text">3. 标记-复制（Mark-Semispace Copying）算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-标记-整理（Mark-Compact）算法"><span class="nav-text">4. 标记-整理（Mark-Compact）算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四-Class-类文件结构概述"><span class="nav-text">四. Class 类文件结构概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Class-文件概述"><span class="nav-text">1. Class 文件概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-魔数与-Class-文件的版本"><span class="nav-text">2. 魔数与 Class 文件的版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-常量池"><span class="nav-text">3. 常量池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-访问标志"><span class="nav-text">4. 访问标志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-类索引、父类索引与接口索引集合"><span class="nav-text">5. 类索引、父类索引与接口索引集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-字段表集合"><span class="nav-text">6. 字段表集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-方法表集合"><span class="nav-text">7. 方法表集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-属性表集合"><span class="nav-text">8. 属性表集合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五-JVM-类加载机制概述"><span class="nav-text">五. JVM 类加载机制概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-概念"><span class="nav-text">1. 概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-特点"><span class="nav-text">2. 特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-优点"><span class="nav-text">3. 优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-缺点"><span class="nav-text">4. 缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-应用"><span class="nav-text">5. 应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-总结"><span class="nav-text">6. 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载时机"><span class="nav-text">类加载时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-类的生命周期示意图"><span class="nav-text">1. 类的生命周期示意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-类生命周期概述"><span class="nav-text">2. 类生命周期概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-有且只有的需要开始初始化操作的六种情况"><span class="nav-text">3. 有且只有的需要开始初始化操作的六种情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-被动引用"><span class="nav-text">4. 被动引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-接口的加载过程"><span class="nav-text">5. 接口的加载过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载过程"><span class="nav-text">类加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-加载"><span class="nav-text">1. 加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-验证"><span class="nav-text">2. 验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-准备"><span class="nav-text">3. 准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-解析"><span class="nav-text">4. 解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-初始化"><span class="nav-text">5. 初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载器"><span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-类与类加载器"><span class="nav-text">1. 类与类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-双亲委派模型（Parents-Delegation-Model）"><span class="nav-text">2. 双亲委派模型（Parents Delegation Model）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-破坏双亲委派模型"><span class="nav-text">3. 破坏双亲委派模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-模块化系统"><span class="nav-text">Java 模块化系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-模块的兼容性"><span class="nav-text">1. 模块的兼容性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-模块化下的类加载器"><span class="nav-text">2. 模块化下的类加载器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六-Java-内存模型概述"><span class="nav-text">六. Java 内存模型概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#主内存与工作内存"><span class="nav-text">主内存与工作内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-线程、主内存、工作内存三者的交互关系"><span class="nav-text">1. 线程、主内存、工作内存三者的交互关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Java-内存模型的主要目的"><span class="nav-text">2. Java 内存模型的主要目的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Java-内存模型含义"><span class="nav-text">3. Java 内存模型含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Java-内存模型与-JVM-运行时数据区域划分的区别"><span class="nav-text">4. Java 内存模型与 JVM 运行时数据区域划分的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存间交互操作"><span class="nav-text">内存间交互操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#针对-volatile-型变量的特殊规则"><span class="nav-text">针对 volatile 型变量的特殊规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-概念-1"><span class="nav-text">1. 概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-作用"><span class="nav-text">2. 作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-性能"><span class="nav-text">3. 性能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#针对-long-和-double-型变量的特殊规则"><span class="nav-text">针对 long 和 double 型变量的特殊规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性、可见性与有序性"><span class="nav-text">原子性、可见性与有序性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-概述-2"><span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-原子性（Atomicity）"><span class="nav-text">2. 原子性（Atomicity）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-可见性（Visibility）"><span class="nav-text">3. 可见性（Visibility）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-有序性（Ordering）"><span class="nav-text">4. 有序性（Ordering）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#先行发生（Happens-Before）原则"><span class="nav-text">先行发生（Happens-Before）原则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-概念-2"><span class="nav-text">1. 概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-内容"><span class="nav-text">2. 内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-结论"><span class="nav-text">3. 结论</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="隋钟元"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">隋钟元</p>
  <div class="site-description" itemprop="description">技术创造价值</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">343</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">473</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:24suixinsuoyu@gmail.com" title="E-Mail → mailto:24suixinsuoyu@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/24suixinsuoyu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;24suixinsuoyu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/24sxsy" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;24sxsy" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/guolin_blog" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;guolin_blog" rel="noopener" target="_blank">郭霖</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/lmj623565791/" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;lmj623565791&#x2F;" rel="noopener" target="_blank">鸿洋</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.520monkey.com/" title="http:&#x2F;&#x2F;www.520monkey.com&#x2F;" rel="noopener" target="_blank">姜维</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://daimajia.com/" title="https:&#x2F;&#x2F;daimajia.com&#x2F;" rel="noopener" target="_blank">代码家</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://kmxz.net/" title="https:&#x2F;&#x2F;kmxz.net&#x2F;" rel="noopener" target="_blank">孔祥舟</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://yangwenbo.com/" title="http:&#x2F;&#x2F;yangwenbo.com&#x2F;" rel="noopener" target="_blank">杨文博</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">隋钟元</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">1.6m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">23:56</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>

